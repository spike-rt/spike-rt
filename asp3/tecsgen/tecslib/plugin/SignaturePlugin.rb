# -*- coding: utf-8 -*-
#
#  TECS Generator
#      Generator for TOPPERS Embedded Component System
#  
#   Copyright (C) 2008-2021 by TOPPERS Project
#--
#   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
#   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
#   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
#   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
#       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
#       スコード中に含まれていること．
#   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
#       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
#       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
#       の無保証規定を掲載すること．
#   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
#       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
#       と．
#     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
#         作権表示，この利用条件および下記の無保証規定を掲載すること．
#     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
#         報告すること．
#   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
#       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
#       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
#       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
#       免責すること．
#  
#   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
#   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
#   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
#   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
#   の責任を負わない．
#  
#   $Id: SignaturePlugin.rb 3225 2021-09-26 05:08:38Z okuma-top $
#++

#== signature プラグインの共通の親クラス
# SignaturePlugin は、シグニチャプラグインの共通の親クラスであるが
# 何もしないで受け口から呼び口を呼び出す（スルーする）プラグインとしても
# 使用できる。
class SignaturePlugin < Plugin
#@signature:: Signature   プラグインの対象となるシグニチャ
#@option:: String   '"', '"' で囲まれた文字列

  SignaturePluginArgProc = {
    "celltypeName"    => Proc.new { |obj,rhs| obj.set_celltypeName rhs },
    "callName"        => Proc.new { |obj,rhs| obj.set_callName rhs },
    "entryName"       => Proc.new { |obj,rhs| obj.set_entryName rhs },
  }

  #signature::     Signature        シグニチャ（インスタンス）
  def initialize( signature, option )
    super()
    @signature = signature
    # @plugin_arg_str = option.gsub( /\A"(.*)/, '\1' )    # 前後の "" を取り除く
    # @plugin_arg_str.sub!( /(.*)"\z/, '\1' )
    @plugin_arg_str = CDLString.remove_dquote option
    @plugin_arg_list = {}
    @celltype_name = :"t#{self.class.name}_#{@signature.get_global_name}"

    # シグニチャ名の接頭文字 s を取り除く(なければ取り除かない)
    port_name = @signature.get_name.to_s.sub( /\As(.*)/, "\\1" )  
    @entry_port_name = :"e#{port_name}"
    @call_port_name  = :"c#{port_name}"

    # 子クラスの場合は、SignaturePlugin の引数は受け付けない
    if self.class.name == "SignaturePlugin" then
      @plugin_arg_check_proc_tab = SignaturePluginArgProc
      parse_plugin_arg
    end
  end

  #=== 後ろのコードを生成
  #プラグインの後ろの CDL コードを生成
  #file:: File: 
  def self.gen_post_code( file )
    # 複数のプラグインの post_code が一つのファイルに含まれるため、以下のような見出しをつけること
    # file.print "/* '#{self.class.name}' post code */\n"
  end

  ### 構文解釈段階で呼び出されるメソッド ###
  # generate 指定子の場合、構文解釈次第(end_of_parseで)呼び出される
  # generate 文の場合、出現次第呼び出される
  #===  CDL ファイルの生成
  #file::        FILE       生成するファイル
  def gen_cdl_file file
    send_receive = []
    if @signature != nil then
      @signature.each_param{ |fd,param|
        dir =param.get_direction
        case dir
        when :SEND, :RECEIVE
          send_receive << [ dir, fd, param ]
        end
      }
    end

    file.print <<EOT
/*
 * generated by SignaturePlugin 
 *   signature: #{@signature.get_namespace_path.to_s}
 *   celltype:  #{@celltype_name} (identity celltype)
 */
celltype #{@celltype_name} {
EOT

    if send_receive.length > 0 then
      file.print "  [allocator(             /* relay allocator */\n"
      delim = ""
      send_receive.each { |a|
        file.print "#{delim}\t#{a[1].get_name}.#{a[2].get_name}<=#{@call_port_name}.#{a[1].get_name}.#{a[2].get_name}"
        delim = ",\n"
      }
      file.print "), inline]\n"
    else
      file.print "  [inline]\n"
    end

    file.print <<EOT
  entry #{@signature.get_namespace_path} #{@entry_port_name};
  call  #{@signature.get_namespace_path} #{@call_port_name};
};
EOT
  end

  #===  受け口関数の本体(C言語)を生成する
  #     通常であれば、ジェネレータは受け口関数のテンプレートを生成する
  #     プラグインの場合、変更する必要のないセルタイプコードを生成する
  #file::           FILE        出力先ファイル
  #b_singleton::    bool        true if singleton
  #ct_name::        Symbol
  #global_ct_name:: string
  #sig_name::       string
  #ep_name::        string
  #func_name::      string
  #func_global_name:: string
  #func_type::      class derived from Type
  def gen_ep_func_body( file, b_singleton, ct_name, global_ct_name, sig_name, ep_name, func_name, func_global_name, func_type, params )

    ret_type = func_type.get_type
    b_ret_void = ret_type.is_void?

    if ! b_ret_void then
      file.print( "  #{ret_type.get_type_str}  retval;\n" )
    end

    if ! b_singleton then
      file.print <<EOT
  CELLCB *p_cellcb = #{global_ct_name}_GET_CELLCB(idx);

EOT
    end

    delim = ""
    if ! b_ret_void then
      file.print( "  retval = " )
    else
      file.print( "  " )
    end

    file.print( "#{@call_port_name}_#{func_name}(" )

    params.each{ |param|
      file.printf( "#{delim} #{param.get_name}" )
      delim = ","
    }

    file.print( " );\n" )

    if ! b_ret_void then
      file.print( "  return retval;\n" )
    end
  end

  #=== プラグイン引数 callName のチェック
  def set_celltypeName rhs
    @celltype_name = rhs.to_sym
    if @celltype_name !~ /\A[A-Za-z_][0-9A-Za-z_]*\Z/ then
      cdl_error( "SignaturePlugin: '$1' celltype_name using unsuitable character", @celltype_name )
    end
  end

  #=== プラグイン引数 callName のチェック
  def set_callName rhs
    @call_port_name = rhs.to_sym
    if @call_port_name !~ /\A[A-Za-z_][0-9A-Za-z_]*\Z/ then
      cdl_error( "SignaturePlugin: '$1' callName using unsuitable character", @call_port_name )
    end
  end

  #=== プラグイン引数 entryName のチェック
  def set_entryName rhs
    @entry_port_name = rhs.to_sym
    if @entry_port_name !~ /\A[A-Za-z_][0-9A-Za-z_]*\Z/ then
      cdl_error( "SignaturePlugin: '$1' entryName using unsuitable character", @entry_port_name )
    end
  end
end

