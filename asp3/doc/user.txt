
		TOPPERS/ASP3カーネル
		ユーザーズマニュアル

		対応バージョン: Release 3.7.0
		最終更新: 2023年1月13日

このドキュメントは，TOPPERS/ASP3カーネルを使用するために必要な事項を説
明するものである．

このドキュメントでは，TOPPERS組込みコンポーネントシステム（TECS）をシス
テムサービスの構築にのみ用い，アプリケーションプログラムはC言語により記
述することを想定している．アプリケーションプログラムを含むシステム全体
をTECSを用いて構築する方法については，以下のURLにあるTECSリファレンスマ
ニュアルを参考にすること．

	http://dev.toppers.jp/trac_user/tecs/wiki/WikiStart

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2023 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: user.txt 1796 2023-03-14 04:35:15Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．TOPPERS/ASP3カーネルの概要
	1.1 TOPPERS/ASP3カーネルの位置付け
	1.2 TOPPERS/ASP3カーネルの仕様
	1.3 マイグレーションガイド
	1.4 機能拡張・チューニングガイド
	1.5 既知の問題
	1.6 Cygwin環境における注意事項
２．ターゲット依存部
	2.1 ターゲット依存部の概要
	2.2 簡易パッケージ
	2.3 個別パッケージ
３．クイックスタートガイド
	3.1 開発環境の準備
	3.2 TECSジェネレータの準備
	3.3 サンプルプログラムの構築と実行
	3.4 カーネルを関数単位でライブラリ化する方法
	3.5 アプリケーションとカーネルを別々に構築する方法
４．ディレクトリ構成・ファイル構成
	4.1 配布パッケージのディレクトリ構成
	4.2 ターゲット非依存部のファイル構成
５．コンフィギュレーションスクリプトの使い方
６．標準のMakefileの修正方法
	6.1 Makefileの変数定義
	6.2 コンパイルオプション
７．コンフィギュレータの使い方
	7.1 コンフィギュレータの起動
	7.2 タイマドライバの組込み
８．システムサービス
	8.1 システムログ機能
		8.1.1 システムログ機能の位置付け
		8.1.2 ログバッファへの記録と低レベル出力
		8.1.3 ログ情報の種別
		8.1.4 ログ情報の重要度
		8.1.5 ログ情報のデータ構造
		8.1.6 システムログ機能のサービスコールとマクロ
		8.1.7 システムログ出力のためのライブラリ関数
		8.1.8 システムログ機能の組込みと取外し
	8.2 シリアルインタフェースドライバ
		8.2.1 シリアルインタフェースドライバのサービスコール
		8.2.2 シリアルインタフェースドライバのその他のサービス
		8.2.3 シリアルインタフェースドライバの組込みと取外し
	8.3 システムログタスク
		8.3.1 システムログタスクの機能
		8.3.2 システムログタスクのその他のサービス
		8.3.3 システムログタスクの組込みと取外し
	8.4 実行時間分布集計サービス
		8.4.1 実行時間分布集計サービスの概要
		8.4.2 実行時間分布集計サービスのサービスコール
		8.4.3 実行時間分布集計サービスの組込みと取外し
	8.5 カーネル起動メッセージ出力
９．サポートライブラリ
	9.1 基本的なライブラリ関数
	9.2 キュー操作ライブラリ関数
	9.3 システムログ出力用ライブラリ関数
１０．テストプログラム
	10.1 テストプログラム用サービス
		10.1.1 テストプログラム用サービスのサービスコール
		10.1.2 テストプログラム用サービスの組込みと取外し
	10.2 カーネルの自己診断機能
	10.3 機能テストプログラム
	10.4 タイマドライバシミュレータを用いたテストプログラム
	10.5 性能評価プログラム
	10.6 コンフィギュレータのテスト
		10.6.1 ビルドに成功するテスト
		10.6.2 コンフィギュレータのパス3でエラーになるテスト
		10.6.3 コンフィギュレータのパス2でエラーになるテスト
		10.6.4 コンフィギュレータのパス1でエラーになるテスト
	10.7 テスト実行スクリプト
		10.7.1 ランタイムテストの実行スクリプトの基本的な使い方
		10.7.2 ランタイムテストの実行スクリプトの使用例
		10.7.3 ランタイムテストの実行スクリプトの進んだ使い方
		10.7.4 コンフィギュレータテストの実行スクリプトの使い方
１１．使用上の注意とヒント
	11.1 実行時間と割込み禁止時間に関する注意事項
	11.2 assertマクロの処理
	11.3 システムログ機能の扱い
	11.4 オブジェクトIDの管理
	11.5 カーネルの内部シンボルのリネーム
	11.6 トレースログ記録のサンプルコードの使用方法
	11.7 システムの起動時の初期化処理
	11.8 rodataセクションをRAMに置く場合
	11.9 カーネルからのシステムログ出力
１２．参考情報
	12.1 利用条件と利用報告
	12.2 保証・適用性・サポート
	12.3 バグレポート
	12.4 ウェブサイト
	12.5 TOPPERSユーザーズメーリングリスト
	12.6 TOPPERSプロジェクトのメンバ向けのサービス
	12.7 TOPPERSプロジェクトへの参加
１３．リファレンス
	13.1 サービスコール一覧
	13.2 静的API一覧
	13.3 バージョン履歴


１．TOPPERS/ASP3カーネルの概要

1.1 TOPPERS/ASP3カーネルの位置付け

TOPPERS/ASP3カーネル（以下，ASP3カーネル）は，TOPPERS/ASPカーネルを拡張・
改良したもので，TOPPERS第3世代カーネル（ITRON系）の基盤となるものとして
開発したリアルタイムカーネルである．

TOPPERS/ASPカーネルは，μITRON4.0仕様のスタンダードプロファイル準拠のリ
アルタイムカーネルであるTOPPERS/JSPカーネルを拡張・改良する形で開発した
ものである．

1.2 TOPPERS/ASP3カーネルの仕様

ASP3カーネルの仕様の概要については，「TOPPERS/ASP3カーネルの仕様概要」
を参照すること．また，ASP3カーネルを含むTOPPERS第3世代カーネル（ITRON系）
の仕様の詳細については，別途PDFファイルの形で配布している「TOPPERS第3世
代カーネル（ITRON系）統合仕様書（Release 3.6.0）」を参照すること．

カーネル仕様の中で，ターゲット定義事項については，ターゲット依存部ディ
レクトリにあるターゲット依存部のユーザーズマニュアルを参照すること．

1.3 マイグレーションガイド

従来のTOPPERSカーネルや他のμITRON4.0仕様準拠のカーネルから，ASP3カーネ
ルに移行するための方法（またはヒント）を説明した「TOPPERS/ASP3カーネル
へのマイグレーションガイド」を用意している．必要に応じて参照すること．

1.4 機能拡張・チューニングガイド

ASP3カーネルを改造して，機能拡張や性能改善を行う方法（またはヒント）を
説明した「機能拡張・チューニングガイド」（doc/extension.txt）を用意し
ている．拡張パッケージの使用方法は，「機能拡張・チューニングガイド」に
含まれている．例えば，サービスコールを非タスクコンテキストやCPUロック
状態から呼び出せるようにするための改造方法や，エラーチェックを省略する
ための改造方法が説明されている．必要に応じて参照すること．

また，TECSを用いずにASP3カーネルを利用するために，標準のシステムサービ
スと同等の機能をTECSを用いずに実装した非TECS版システムサービスを用意し
ている．非TECS版システムサービスの使用方法は，「非TECS版システムサービ
ス ユーザーズマニュアル」（extension/non_tecs/doc/non_tecs.txt）を参照
すること．

1.5 既知の問題

kernel_cfg.c（およびcfg1_out.c）は，カーネル，システムサービス，アプリ
ケーションのいずれのインクルードファイルもインクルードし，いずれのシン
ボルも参照する可能性がある．そのため，カーネル，システムサービス，アプ
リケーションでシンボル等が衝突している場合や，コンパイルオプションが食
い違っている場合に，kernel_cfg.c（およびcfg1_out.c）が正しくコンパイル
できなくなる場合が考えられる．カーネルのシンボルをリネームするなどの方
法で軽減されてはいるが，問題がなくなっているわけではない．

システムコンフィギュレーションファイルから，コンフィギュレータに対する
INCLUDEディレクティブにより他のコンフィギュレーションファイルをインクルー
ドしている場合に，その中に含まれるC言語プリプロセッサのインクルードディ
レクティブ（#include）で，コンフィギュレーションファイルの置かれている
ディレクトリが，ファイルを検索するパスに入らないという問題がある．

1.6 Cygwin環境における注意事項

Cygwin環境においては，ディレクトリの指定を相対パスで行うことを推奨する．
これは，Cygwin環境の絶対パスは，Windowsネイティブでビルドされたツールは
解釈できないためである．


２．ターゲット依存部

2.1 ターゲット依存部の概要

ASP3カーネルのターゲット非依存部と，各種のターゲットシステムに対応する
ためのターゲット依存部は，別々に開発されている．そのため，ASP3カーネル
が対応しているすべてのターゲット依存部を，バージョンを整合させてパッケー
ジ化することは困難である．そこで，主に初級のユーザを対象にした簡易パッ
ケージと，上級のユーザやカーネル開発者を対象にした個別パッケージを用意
している．

このユーザーズマニュアルは，ターゲットに依存しないことを中心に記載して
いる．ターゲット依存部に固有の事項については，使用するターゲット依存部
に含まれるターゲット依存部のユーザーズマニュアルを参照すること．

ASP3カーネルを未サポートのターゲットシステムへポーティングするために必
要な作業は，開発環境の構築と標準の開発環境との差異の吸収，カーネル自身
のポーティング，システムサービスのポーティングなどからなる．詳しくは，
「ターゲット依存部 ポーティングガイド」を参照すること．

2.2 簡易パッケージ

簡易パッケージは，ASP3カーネルが対応しているターゲットシステム毎に用意
され，そのターゲットシステム上でASP3カーネルを動作させるために必要なファ
イル一式をパッケージ化したものである．簡易パッケージに含まれるファイル
は，バージョンが整合していることが確認されている．

簡易パッケージのバージョン番号は，パッケージ化した日付とすることを原則
とするが，ターゲットシステム毎の事情によりこの原則に従わない場合がある．

簡易パッケージは，基本的には，次に説明する個別パッケージを複数まとめた
ものである．そのため，対象ターゲットシステムに必要のないファイルも含ま
れている．また，簡易パッケージに含まれている個別パッケージのバージョン
は，個別パッケージのMANIFESTファイルを参照することで知ることができる．

2.3 個別パッケージ

個別パッケージは，ASP3カーネルの開発単位毎に，その開発単位で開発を担当
しているファイル一式をパッケージ化したものである．ASP3カーネルのターゲッ
ト非依存部も，一つの個別パッケージとして配布される．ある個別パッケージ
を使用するためには，一般には，他の個別パッケージが必要となる．ターゲッ
ト依存部の個別パッケージを使用するために必要となる個別パッケージとその
バージョンについては，ターゲット依存部のユーザーズマニュアルを参照する
こと．使用する個別パッケージのバージョンを整合させることは，ユーザの責
任である．

個別パッケージのバージョン番号は，X.Y.Zの形で表現される．ターゲット非依
存部のバージョン番号を，ASP3カーネル全体のリリース番号とする．ターゲッ
ト依存部のバージョン番号は，XとYが，それが依存するターゲット非依存部と
一致している．それに対して，Zは一致しているとは限らない．例えば，ターゲッ
ト非依存部のバージョン3.5.0に対応するターゲット依存部は，バージョン
3.5.Zの形となる．ターゲット依存部のみがバージョンアップした場合には，Z
が変更される．

使用する個別パッケージは，次の例のように，ターゲット非依存部の個別パッ
ケージを展開したのと同じディレクトリで展開する．

	% tar xvfz asp3-3.5.0.tar.gz
	% tar xvfz asp3_arch_arm_gcc_3.5.Z.tar.gz

ターゲット非依存部の個別パッケージには，以下のターゲット依存部が含まれ
ているが，これは，ASP3カーネルを新しいターゲットシステムにポーティング
する際の出発点とするために用意したものである．

	target/dummy_gcc	ダミー（GNU開発環境）のターゲット依存部

まずはこれをターゲットシステム向けの開発環境でビルドし，その後，各ファ
イルの内容をターゲットシステム向けに修正していくことを想定している．


３．クイックスタートガイド

ここでは，ターゲット依存部が用意されているターゲットシステム上で，ASP3
カーネル上で動作するサンプルプログラムを構築・動作させるまでの手順を示
す．

3.1 開発環境の準備

ASP3カーネルを用いたシステム構築には，以下のツールが必要である．

	ホストシステム用のツール
		GNU Make	動作確認：3.81
		ruby		動作確認：2.6.8p205

	TOPPERS第3世代カーネル向け Ruby版コンフィギュレータ
		cfg			動作確認：1.7.0

	TOPPERS組込みコンポーネントシステム（TECS）ジェネレータ
		tecsgen		動作確認：1.8.0

	ターゲットシステム用のツール（クロス開発環境）
		標準規格に準拠したCコンパイラ
		アセンブラ，リンカ，ライブラリアン
		シンボルファイル出力ツール，ヘキサファイル出力ツール
		標準Cライブラリ（必須ではない）

ターゲットシステム用のツールにGNU開発環境を用いる場合には，以下のツール
が必要である．

	ターゲットシステム用のGNU開発環境ツール
		BINUTILS（as，ld，ar，nm，ranlib，objcopy，objdump）
		GCCまたはGCC-CORE（gccおよびそこから呼び出されるツール）
		NEWLIB（標準Cライブラリ，必須ではない）

動作確認されているターゲットシステム用のツールについては，ターゲット依
存部のユーザーズマニュアルを参照すること．

ターゲットシステム用の標準Cライブラリは，アプリケーションが標準Cライブ
ラリを使用しない場合には，必要ない．ただし，コンパイラが標準Cライブラリ
関数（memcpy，memsetなど）を呼び出すコードを生成する場合があり，その場
合には標準Cライブラリが必要である．標準Cライブラリを用意する代わりに，
生成したコードが呼び出す関数のみを自分で用意してもよい．

以下では，これらのツールが用意できていることを前提に，UNIXマシン上での
構築手順を説明する．また以下の説明では，makeコマンドがGNU Makeであるも
のとする（ASP3カーネルの標準のMakefileは，GNU Makeの拡張機能を用いてい
る）．

なお，TOPPERS第3世代カーネル向け Ruby版コンフィギュレータは，ASP3カーネ
ルのパッケージに含まれているため，特別な準備は必要ない．

3.2 TECSジェネレータの準備

まず，TOPPERS組込みコンポーネントシステム（TECS）のジェネレータを準備す
る必要がある．TECSジェネレータが，ASP3カーネルの簡易パッケージに含まれ
ていた場合には，このステップは省略することができる．

TECSジェネレータは，TECSジェネレータの個別パッケージに含まれている．
TECSジェネレータの個別パッケージを任意の場所に展開し，その下のtecsgenディ
レクトリを，ASP3カーネルのソースファイルを展開したディレクトリからシン
ボリックリンクをはる（コピーしてもよい）．つまり，ASP3カーネルのソース
ファイルのディレクトリからtecsgen.rbへの相対パスが，tecsgen/tecsgen.rb
となればよい．下の手順は，TECSジェネレータのパッケージを，asp3の親ディ
レクトリに展開する場合の例である．

	% tar xvfz tecsgen-1.7.0.tgz
	% cd asp3
	% ln -s ../tecsgen/tecsgen .
	% file tecsgen/tecsgen.rb
	tecsgen/tecsgen.rb: a ruby script text executable

TECSジェネレータを上記以外の場所に置いた場合や，Windows実行形式のTECSジェ
ネレータを用いる場合には，コンフィギュレーションスクリプトの-Gオプショ
ンで，TECSジェネレータのパス名を指定すればよい．

なお，TECSジェネレータのバージョンを確認したい場合には，tecsgenを
--versionオプションをつけて実行すればよい．

3.3 サンプルプログラムの構築と実行

次に，ASP3カーネル上で動作するサンプルプログラムを構築する方法を説明す
る．

まず，サンプルプログラムのオブジェクトファイルを置くディレクトリを作成
し，コンフィギュレーションスクリプトを実行する．例えば，オブジェクトファ
イルを置くディレクトリを，ASP3カーネルのソースファイルを展開したディレ
クトリの下のOBJという名称のディレクトリにする場合には，次のコマンドを実
行する（ディレクトリの場所と名称は任意に決めてよい．ただし，場所を変え
る場合には，configure.rbの相対パスも変更が必要である．以下同様）．

	% mkdir OBJ
	% cd OBJ
	% ruby ../configure.rb -T <ターゲット略称>

ここで，<ターゲット略称>は，targetディレクトリの下に置かれているターゲッ
ト依存部ディレクトリの名称である．コンフィギュレーションスクリプトのオ
プションについては，「５．コンフィギュレーションスクリプトの使い方」の
章で説明する．

コンフィギュレーションスクリプトの実行により，カレントディレクトリには，
サンプルプログラムを構築するためのMakefileが生成される．

コンフィギュレーションスクリプトの実行後，必要であればMakefileを修正す
る．Makefileの修正方法については，「６．標準のMakefileの修正方法」の章
で説明する．

その後，makeコマンドによりサンプルプログラムのロードモジュール（aspまた
はasp.exe）が生成できる．

	% make

ここで構築したサンプルプログラム（sampleディレクトリのsample1.h，
sample1.c，sample1.cfg，sample1.cdl）は，ASP3カーネルの基本的な動作を確
認するためのものである．このプログラムの概要説明は，sample1.cの先頭のコ
メントにある．

3.4 カーネルを関数単位でライブラリ化する方法

前節の手順では，カーネルをファイル単位でコンパイルし，ライブラリ化して
いたが，カーネルのコードサイズを縮小するためには，使用しないサービスコー
ルはリンクしない方が望ましい．そこでASP3カーネルでは，カーネルを関数単
位でコンパイルし，ライブラリ化する方法を用意している．

この方法でサンプルプログラムを構築するには，コンフィギュレーションスク
リプトに，それを指示するオプション（-f）を付加するだけでよい．例えば，
オブジェクトファイルを置くディレクトリを，ASP3カーネルのソースファイル
を展開したディレクトリの下のOBJという名称のディレクトリにする場合には，
次のコマンドを実行する．

	% mkdir OBJ
	% cd OBJ
	% ruby ../configure.rb -T <ターゲット略称> -f
	% make

3.5 アプリケーションとカーネルを別々に構築する方法

前節で説明した方法では，アプリケーションとカーネルを同時に生成するため，
オブジェクトファイルを置くディレクトリに非常に多くのファイルが作成され
て，扱いにくくなる．そこで，カーネルを修正する頻度が低い場合には，カー
ネルは事前に構築しておき，後でアプリケーションだけを構築する方法を用意
している．以下では，サンプルプログラムを構築を例に，その手順について説
明する．

まず，カーネルを構築するディレクトリを作成し，コンフィギュレーションス
クリプトを実行する．例えば，カーネルを構築するディレクトリを，ASP3カー
ネルのソースファイルを展開したディレクトリの下のKERNEL_LIBという名称の
ディレクトリにする場合には，次のコマンドを実行する．

	% mkdir KERNEL_LIB
	% cd KERNEL_LIB
	% ruby ../configure.rb -T <ターゲット略称> -f
	% make libkernel.a

これにより，カーネルを構築するディレクトリに，カーネルライブラリ
（libkernel.a）が生成される．

次に，アプリケーションを構築するディレクトリを作成し，コンフィギュレー
ションスクリプトを実行する．例えば，アプリケーションを構築するディレク
トリを，ASP3カーネルのソースファイルを展開したディレクトリの下のAPLとい
う名称のディレクトリにする場合には，次のコマンドを実行する．

	% cd ..
	% mkdir APL
	% cd APL
	% ruby ../configure.rb -T <ターゲット略称> -L ../KERNEL_LIB
	% make

ここで-Lオプションには，カーネルを構築したディレクトリのパスを指定する．

この手順では，アプリケーション構築時にはカーネルの再構築が必要かチェッ
クしないため，カーネルのソースコードを修正した場合には，カーネルを構築
したディレクトリでmake libkernel.aを再実行する必要がある．

以上では，カーネルとアプリケーションを別々のディレクトリで構築したが，
-Lオプションにカレントディレクトリ（ただし，"."という記述では不可）を指
定することで，カーネルとアプリケーションを同じディレクトリで別々に構築
することもできる．具体的には，次の手順となる．

	% mkdir OBJ
	% cd OBJ
	% ruby ../configure.rb -T <ターゲット略称> -L ../OBJ
	% make libkernel.a
	% make cleankernel
	% make

ここで，make cleankernelは，カーネルライブラリを生成するための中間ファ
イルを削除するものである．この手順では，カーネルライブラリに関する依存
関係をインクルードしないため，カーネルのソースコードを修正した場合には，
必ずmake cleankernel（または，make clean）してから，make libkernel.aす
る必要があるので注意すること．


４．ディレクトリ構成・ファイル構成

4.1 配布パッケージのディレクトリ構成

	doc/			ドキュメント
	include/		アプリケーション向けヘッダファイル
	kernel/			カーネルのソースファイル
	tecs_kernel/	TECSからカーネルを呼び出すためのソースファイル
	syssvc/			システムサービスのヘッダファイル，ソースファイル
	library/		サポートライブラリのソースファイル
	target/			ターゲット依存部
	arch/			ターゲット依存部の共通部分
		gcc/		GCC開発環境依存部
		tracelog/	トレースログ記録のサンプルコード
	cfg/			コンフィギュレータ
		doc/		コンフィギュレータのドキュメント
	utils/			ユーティリティプログラム
	sample/			サンプルプログラムとMakefile
	test/			テストプログラム
	test_cfg/		コンフィギュレータのテスト
	extension/		拡張パッケージ

4.2 ターゲット非依存部のファイル構成

ターゲット非依存部（テストプログラムと拡張パッケージは除く）の各ファイ
ルの概要は次の通り．

	README.txt			TOPPERS/ASP3カーネルの簡単な紹介
	configure.rb		コンフィギュレーションスクリプト（GNU開発環境用）
	MANIFEST			個別パッケージのファイルリスト

  doc/
	user.txt			ユーザーズマニュアル
	asp_spec.txt		TOPPERS/ASP3カーネルの仕様概要
	migration.txt		TOPPERS/ASP3カーネルへのマイグレーションガイド
	extension.txt		機能拡張・チューニングガイド
	porting.txt			ターゲット依存部 ポーティングガイド
	configurator.txt	コンフィギュレータ仕様
	design.txt			設計メモ
	mutex_design.txt	ミューテックス機能の設計
	inherit_design.txt	優先度継承ミューテックス機能の設計
	simtimer.txt		タイマドライバシミュレータを用いたカーネルのテ
						スト手法
	version.txt			変更履歴

  include/
	kernel.h		ASP3カーネルを使用するための定義
	sil.h			システムインタフェースレイヤを使用するための定義
	t_stddef.h		TOPPERS共通ヘッダファイル
	itron.h			ITRON仕様共通規定のデータ型・定数・マクロ
	t_syslog.h		システムログ出力を行うための定義
	t_stdlib.h		基本的なライブラリ関数を使用するための定義
	queue.h			キュー操作ライブラリを使用するための定義
	log_output.h	システムログのフォーマット出力を使用するための定義

  kernel/
	Makefile.kernel		カーネルのファイル構成の定義
	kernel_impl.h		カーネル実装用標準ヘッダファイル
	kernel_int.h		kernel_cfg.c用のヘッダファイル
	kernel_rename.def	カーネルの内部識別名のリネーム定義
	kernel_rename.h		カーネルの内部識別名のリネーム
	kernel_unrename.h	カーネルの内部識別名のリネーム解除	
	kernel_api.def		コンフィギュレータの静的APIテーブル
	kernel_sym.def		コンフィギュレータの値取得シンボルテーブル
	kernel.trb			コンフィギュレータのパス2の生成スクリプト
	kernel_check.trb	コンフィギュレータのパス3の生成スクリプト
	genoffset.trb		オフセットファイル生成用の生成スクリプトのター
						ゲット非依存部
	allfunc.h			すべての関数をコンパイルするための定義
	check.h				エラーチェック用マクロ
	startup.c			カーネルの初期化と終了処理
	task.h				タスク管理モジュール関連の定義
	task.c				タスク管理モジュール
	task.trb			タスク管理モジュールの生成スクリプト
	taskhook.h			タスク管理に関連するフックルーチン関連の定義
	taskhook.c			タスク管理に関連するフックルーチン
	wait.h				待ち状態管理モジュール関連の定義
	wait.c				待ち状態管理モジュール
	time_event.h		タイムイベント管理モジュール関連の定義
	time_event.c		タイムイベント管理モジュール
	task_manage.c		タスク管理機能
	task_refer.c		タスクの状態参照機能
	task_sync.c			タスク付属同期機能
	task_term.c			タスク終了機能
	semaphore.h			セマフォ機能関連の定義
	semaphore.c			セマフォ機能
	semaphore.trb		セマフォ機能の生成スクリプト
	eventflag.h			イベントフラグ機能関連の定義
	eventflag.c			イベントフラグ機能
	eventflag.trb		イベントフラグ機能の生成スクリプト
	dataqueue.h			データキュー機能関連の定義
	dataqueue.c			データキュー機能
	dataqueue.trb		データキュー機能の生成スクリプト
	pridataq.h			優先度データキュー機能関連の定義
	pridataq.c			優先度データキュー機能
	pridataq.trb		優先度データキュー機能の生成スクリプト
	mutex.h				ミューテックス機能関連の定義
	mutex.c				ミューテックス機能
	mutex.trb			ミューテックス機能の生成スクリプト
	mempfix.h			固定長メモリプール機能関連の定義
	mempfix.c			固定長メモリプール機能
	mempfix.trb			固定長メモリプール機能の生成スクリプト
	time_manage.c		システム時刻管理機能
	cyclic.h			周期通知機能関連の定義
	cyclic.c			周期通知機能
	cyclic.trb			周期通知機能の生成スクリプト
	alarm.h				アラーム通知機能関連の定義
	alarm.c				アラーム通知機能
	alarm.trb			アラーム通知機能の生成スクリプト
	sys_manage.c		システム状態管理機能
	interrupt.h			割込み管理機能関連の定義
	interrupt.c			割込み管理機能
	interrupt.trb		割込み管理機能の生成スクリプト
	exception.h			CPU例外管理機能関連の定義
	exception.c			CPU例外管理機能
	exception.trb		CPU例外管理機能の生成スクリプト

  tecs_kernel/
	kernel.cdl						カーネルオブジェクトのコンポーネント
									記述ファイル
	tecs_kernel.h					カーネルオブジェクトのコンポーネント
									化のためのヘッダファイル
	init_tecs.c						TECSの初期化処理
	tKernel_inline.h				カーネル操作のインライン関数
	tTask.c							タスク操作
	tTask_inline.h					タスク操作のインライン関数
	tSemaphore_inline.h				セマフォ操作のインライン関数
	tEventflag_inline.h				イベントフラグ操作のインライン関数
	tDataqueue_inline.h				データキュー操作のインライン関数
	tPriorityDataqueue_inline.h		優先度データキュー操作のインライン関数
	tMutex_inline.h					ミューテックス操作のインライン関数
	tFixedSizeMemoryPool_inline.h	固定長メモリプール操作のインライン関数
	tCyclicNotifier.c				周期通知操作
	tCyclicNotifier_inline.h		周期通知操作のインライン関数
	tAlarmNotifier.c				アラーム通知操作
	tAlarmNotifier_inline.h			アラーム通知操作のインライン関数
	tInterruptRequest_inline.h		割込み要求ライン操作のインライン関数
	tISR.c							割込みサービスルーチン操作
	tInitializeRoutine.c			初期化ルーチン操作
	tTerminateRoutine.c				終了処理ルーチン操作

  syssvc/
	syslog.h				システムログ機能を使用するための定義
	tSysLog.cdl				システムログ機能のコンポーネント記述ファイル
	tSysLog.c				システムログ機能
	tSysLogAdapter.cdl		システムログ機能のアダプタのコンポーネント記
							述ファイル
	tSysLogAdapter.c		システムログ機能のアダプタ
	serial.h				シリアルインタフェースドライバを使用するため
							の定義
	tSerialPort.cdl			シリアルインタフェースドライバのコンポーネン
							ト記述ファイル
	tSerialPortMain.c		シリアルインタフェースドライバの本体
	tSerialAdapter.cdl		シリアルインタフェースドライバのアダプタのコ
							ンポーネント記述ファイル
	tSerialAdapter.c		シリアルインタフェースドライバのアダプタ
	tLogTask.cdl			システムログタスクのコンポーネント記述ファイル
	tLogTaskMain.c			システムログタスクの本体
	test_svc.h				テストプログラム用サービスを使用するための定義
	tTestService.cdl		テストプログラム用サービスのコンポーネント記
							述ファイル
	tTestService.c			テストプログラム用サービス
	tTestServiceAdapter.cdl	テストプログラム用サービスのアダプタのコンポー
							ネント記述ファイル
	tTestServiceAdapter.c	テストプログラム用サービスのアダプタ
	histogram.h				実行時間分布集計サービスを使用するための定義
	tHistogram.cdl			実行時間分布集計サービスのコンポーネント記述
							ファイル
	tHistogram.h			実行時間分布集計サービスのヘッダファイル
	tHistogram.c			実行時間分布集計サービス
	tHistogramAdapter.cdl	実行時間分布集計サービスのアダプタのコンポー
							ネント記述ファイル
	tHistogramAdapter.c		実行時間分布集計サービスのアダプタ
	tPutLogSIOPort.cdl		簡易SIOドライバによるシステムログの低レベル
							出力のコンポーネント記述ファイル
	tPutLogSIOPort.c		簡易SIOドライバによるシステムログの低レベル
							出力
	tBanner.cdl				カーネル起動メッセージ出力のコンポーネント記
							述ファイル
	tBannerMain.c			カーネル起動メッセージ出力の本体

  library/
	log_output.c		システムログのフォーマット出力
	strerror.c			エラーメッセージ文字列を返す関数
	t_perror.c			エラーメッセージの出力
	vasyslog.c			可変数引数のシステムログライブラリ

  arch/gcc/
	tool_stddef.h		t_stddef.hの開発環境依存部（GCC用）

  arch/tracelog/
	trace_log.h			トレースログ機能のヘッダファイル
	tTraceLog.cdl		トレースログ機能のコンポーネント記述ファイル
	tTraceLog.c			トレースログ機能

  cfg/
	MANIFEST			個別パッケージのファイルリスト
	cfg.rb				コンフィギュレータ本体
	pass1.rb			コンフィギュレータのパス1の処理
	pass2.rb			コンフィギュレータのパス2の処理
	GenFile.rb			GenFileクラスの定義
	SRecord.rb			SRecordクラスの定義

  cfg/doc/
	cfg_user.txt		コンフィギュレータ ユーザーズマニュアル

  utils/
	applyrename.rb		ファイルにリネームを適用
	genrename.rb		リネームヘッダファイルの生成
	gentest.rb			テストプログラムの生成
	makerelease.rb		配布パッケージの生成

  sample/
	Makefile			標準のMakefile（GNU開発環境用）のテンプレート
	sample1.h			サンプルプログラム(1)に関する定義
	sample1.c			サンプルプログラム(1)
	sample1.cfg			サンプルプログラム(1)のコンフィギュレーションファイル
	sample1.cdl			サンプルプログラム(1)のコンポーネント記述ファイル
	tSample2.h			サンプルプログラム(2)に関する定義
	tSample2.c			サンプルプログラム(2)
	tSample2.cfg		サンプルプログラム(2)のコンフィギュレーションファイル
	tSample2.cdl		サンプルプログラム(2)のコンポーネント記述ファイル


５．コンフィギュレーションスクリプトの使い方

コンフィギュレーションスクリプト（configure.rb）は，ASP3カーネルおよび
アプリケーションプログラムを構築するために必要な基本的なコンフィギュレー
ションを行うためのプログラムである．

ASP3カーネルを用いてアプリケーションを作成する場合には，まずオブジェク
トファイルを置くディレクトリを作成し，そのディレクトリでコンフィギュレー
ションスクリプトを実行する．オブジェクトファイルを置くディレクトリの場
所と名称は，任意に決めてよい．

コンフィギュレーションスクリプトに対するオプションは次の通り．

	-T <ターゲット略称>
		ターゲットシステムの名称を，targetディレクトリの下に置かれてい
		るターゲット依存部ディレクトリの名称で指定する（必須）．

	-a <アプリケーションのディレクトリ名>
		アプリケーションプログラムのソースファイルを置いたディレクトリ
		名を指定する．省略した場合には，sampleディレクトリ（ASP3カーネ
		ルのソースファイルを置いたディレクトリの下の"sample"）となる．
		このオプションを複数記述するか，""で囲むことによって，複数のディ
		レクトリを指定することも可能である．

	-A <アプリケーションプログラム名>
		アプリケーションプログラムの名称を指定する．省略した場合には，
		サンプルプログラム（sample1）となる．

	-t
		アプリケーションプログラムのメインのオブジェクトファイル（アプ
		リケーションプログラム名に".o"を付加したもの）をリンク対象に含
		めない．アプリケーションプログラム全体をTECSを用いて開発する場
		合に使用する．

	-c <システムコンフィギュレーションファイル名>
		システムコンフィギュレーションファイル（.cfg）の名称を指定する．
		省略した場合には，アプリケーションプログラム名に".cfg"を付加し
		た名称とする．

	-C <コンポーネント記述ファイル名>
		コンポーネント記述ファイル（.cdl）の名称を指定する．省略した場
		合には，アプリケーションプログラム名に".cdl"を付加した名称とす
		る．

	-U <オブジェクトファイル名>
		アプリケーションプログラムのメインのオブジェクトファイル（アプ
		リケーションプログラム名に".o"を付加したもの）以外に，リンクす
		べきオブジェクトファイルの名称を，".o"を付加した形で指定する．
		このオプションを複数記述するか，""で囲むことによって，複数のファ
		イルを指定することも可能である．

	-S <オブジェクトファイル名>
		リンクすべきシステムサービスのオブジェクトファイルの名称を，
		".o"を付加した形で指定する．このオプションを複数記述するか，""
		で囲むことによって，複数のファイルを指定することも可能である．

	-B <バナー表示サービスのオブジェクトファイル名>
		バナー表示サービスのオブジェクトファイルの名称を，".o"を付加し
		た形で指定する．再コンパイルのための追加の依存性を定義するため
		のみに使用される．

	-L <カーネルライブラリのディレクトリ名>
		事前に構築したカーネルライブラリ（libkernel.a）を用いて，アプリ
		ケーションのみを構築する場合には，このオプションにカーネルライ
		ブラリの置かれたディレクトリ名を指定する．このオプションの使用
		例については，「3.5 アプリケーションとカーネルを別々に構築する
		方法」の節を参照すること．

	-f
		カーネルを関数単位でコンパイルしライブラリ化する場合に，このオ
		プションを指定する．このオプションの使用例については，「3.4 カー
		ネルを関数単位でライブラリ化する方法」の節を参照すること．

	-D <ASP3カーネルのソースディレクトリ名>
		ASP3カーネルのソースファイルを置いたディレクトリ名を指定する．
		省略した場合には，configure.rbの置かれているディレクトリとなる．

	-l <プログラミング言語>
		アプリケーションプログラムの記述に用いるプログラミング言語を指
		定する．現時点では，cとc++のみをサポートしている．

	-m <テンプレートMakefile名>
		Makefileのテンプレートとするファイル名を指定する．省略した場合
		には，sampleディレクトリのMakefileとなる．

	-d <中間オブジェクトファイルのディレクトリ名>
		中間オブジェクトファイルと依存関係ファイルを置くディレクトリ名
		を指定する．省略した場合には，"objs"となる．

	-w
		TECSを使用しない場合に，このオプションを指定する．

	-W <TECS関係ファイルのディレクトリ名>
		TECS関係ファイルが置かれているディレクトリ名を指定する．省略し
		た場合には，デフォルトはソースファイルのディレクトリの下の
		tecsgenとなる．

	-r
		トレースログ記録のサンプルコードを有効にする場合に，このオプショ
		ンを指定する．このオプションの使用例については，「11.6 トレース
		ログ記録のサンプルコードの使用方法」の節を参照すること．

	-V <開発ツールのディレクトリ名>
		開発ツールが置かれているディレクトリを指定する．開発ツール（コ
		ンパイラ等）を絶対パスで指定する場合に用いる．

	-R <rubyのパス名>
		rubyのパス名を指定する．省略した場合には，単に"ruby"となる．

	-g <コンフィギュレータのパス名>
		コンフィギュレータ（cfg）のパス名を指定する．省略した場合には，
		"ruby $(SRCDIR)/cfg/cfg.rb"となる．

	-G <TECSジェネレータのパス名>
		TECSジェネレータ（tecsgen）のパス名を指定する．省略した場合に
		は，"ruby $(SRCDIR)/tecsgen/tecsgen.rb"となる．

	-o <オプション文字列>
		コンパイラに与えるオプション文字列で，シンボル定義以外のもの．
		シンボル定義のオプションは，-Oオプションで指定する．オプション
		文字列にスペースが含まれる場合には，このオプションを複数記述す
		るか，"-O2 -Wall"のように，""で囲んで記述する必要がある．

	-O <オプション文字列>
		コンパイラに与えるシンボル定義のためのオプション文字列．オプショ
		ン文字列にスペースが含まれる場合には，このオプションを複数記述
		するか，"-DTEST -DPERF"のように，""で囲んで記述する必要がある．

	-k <オプション文字列>
		リンカに与えるオプション文字列．オプション文字列にスペースが含
		まれる場合には，このオプションを複数記述するか，""で囲んで記述
		する必要がある．

	-b <オプション文字列>
		ライブラリをリンクするためのオプション文字列．複数のライブラリ
		をリンクする場合には，このオプションを複数記述するか，複数のリ
		ンク記述を""で囲んで記述する必要がある．

コンフィギュレーションスクリプトに以下のパラメータを指定することで，追
加の設定を行うことができる（"=true"の記述は省いても良い）．

	OMIT_WARNING_ALL=true
		コンパイラに対するすべての警告を有効にするオプション（-Wall）
		を外す．

	OMIT_OPTIMIZATION=true
		コンパイラに対する最適化オプション（-O2）を外す．

	APPL_CFLAGS=<オプション文字列>
		アプリケーションをコンパイルする際に与えるオプション文字列．オ
		プション文字列にスペースが含まれる場合には，""で囲んで記述する
		必要がある．

コンフィギュレーションスクリプトが行う処理は次の通りである．

(1) ターゲット依存部ディレクトリのチェック

ターゲット依存部ディレクトリ（-Tオプションで指定）があるかチェックし，
ない場合にはエラーとする．

(2) Makefileの生成

Makefileのテンプレート（デフォルトでは，sampleディレクトリにある
Makefile）を元に，必要な箇所を書き換えて，Makefileを生成する．

(3) 中間オブジェクトファイルと依存関係ファイルのディレクトリの作成

中間オブジェクトファイルと依存関係ファイルを置くディレクトリ（デフォル
トでは，"objs"）を作成する．


６．標準のMakefileの修正方法

前の章で説明したように，コンフィギュレーションスクリプトに与えるオプショ
ン等からMakefileが生成されるが，コンフィギュレーションスクリプトで対応
できない場合には，Makefileを直接修正する必要がある．ここでは，Makefile
の中で，修正が必要となる可能性の高い箇所について説明する．

なお，Makefileを修正した後にコンフィギュレーションスクリプトを再実行す
ると，修正したMakefileが上書きされてしまうので注意すること（古いものが
Makefile.bakに保存される）．

6.1 Makefileの変数定義

(A) オブジェクトファイルの拡張子

ロードモジュールのファイル名に拡張子が付加される場合には，OBJEXTに拡張
子を定義する必要がある．コンフィギュレーションスクリプトは，Cygwin環境
であると判定した場合に，OBJEXTを"exe"に定義する．

(B) ロードモジュールのファイル名

標準のロードモジュールのファイル名をOBJNAMEに定義する．デフォルトはasp
である．

(C) 共通コンパイルオプション

すべてのプログラムに共通するコンパイルオプションの追加が必要な場合には，
下の変数の定義を変更する．そのコンパイルオプションが，特定のターゲット
で常に必要な場合には，ターゲット依存の定義を入れたMakefile.target等を修
正すべきである．

	CDEFS		コンパイラに対する-Dオプションを記述する．
	INCLUDES	コンパイラに対する-Iオプションを記述する．
	COPTS		コンパイラに対するその他のオプションを記述する．
	LDFLAGS		リンカに対するオプションを記述する．
	LIBS		ライブラリリンクのためのオプションを記述する．

この内，CDEFS，COPTS，LDFLAGSは，それぞれ，コンフィギュレーションスクリ
プトの-Oオプション，-oオプション，-kオプションで追加設定することができ
る．

追加の可能性のあるコンパイルオプションについては，「6.2 コンパイルオプ
ション」の節を参照のこと．

(D) アプリケーションのオブジェクトファイル名

アプリケーションを構成するオブジェクトファイル名を，記述言語に応じて，
APPL_ASMOBJS，APPL_COBJS，APPL_CXXOBJSに列挙する．この内，APPL_COBJSか
APPL_CXXOBJSは，コンフィギュレーションスクリプトの-Aオプションで設定し，
-Uオプションで追加設定することができる．

(E) アプリケーションのコンパイルオプション

アプリケーションのコンパイルに必要なコンパイルオプションがある場合には，
APPL_CFLAGSに定義する．なお，APPL_CFLAGSに定義したオプションは，コンフィ
ギュレータが生成したファイルをコンパイルする場合には適用されないため，
注意すること．

(F) システムサービスのディレクトリ

システムサービスのソースファイルを置いたディレクトリを，SYSSVC_DIRSに定
義する．

(G) システムサービスのオブジェクトファイル名

システムサービスを構成するオブジェクトファイル名を，記述言語に応じて，
SYSSVC_ASMOBJSとSYSSVC_COBJSに列挙する．この内，SYSSVC_COBJは，コンフィ
ギュレーションスクリプトの-Sオプションで追加設定することができる．

(H) システムサービスのコンパイルオプション

システムサービスのコンパイルに必要なコンパイルオプションがある場合には，
SYSSVC_CFLAGSに定義する．なお，SYSSVC_CFLAGSに定義したオプションは，コ
ンフィギュレータが生成したファイルをコンパイルする場合には適用されない
ため，注意すること．

(I) ターゲットファイルの定義

make allにより，ELF形式以外のロードモジュールを作りたい場合には，作りた
いロードモジュールの形式を，allに対する$(MAKE)コマンドのパラメータまた
は依存関係に追加指定する．具体的には，バイナリ形式の時は$(OBJNAME).bin，
モトローラ S形式の時は$(OBJNAME).srecを追加指定する．なお，$(OBJFILE)は，
OBJEXTを定義した場合には$(OBJNAME).$(OBJEXT)，そうでない場合には
$(OBJNAME)となる．

6.2 コンパイルオプション

ASP3カーネルのコード中には，assertマクロが使われている．assertマクロは，
NDEBUGをマクロ定義することで，オブジェクトコード中から消すことができる．
カーネルのデバッグが終了すれば，-DNDEBUGを指定してコンパイルした方が効
率がよくなる．

ASP3カーネルは，標準Cライブラリを使用せずに記述してあるが，アプリケーショ
ンで標準Cライブラリを使用する場合には，カーネルも標準Cライブラリを使っ
た方が効率が良い場合がある．カーネルが標準Cライブラリを使ってよい場合に
は，コンパイルオプションに-DTOPPERS_USE_STDLIBを指定する（効果があるか
どうかはターゲット依存）．

ターゲット依存部において，コンパイルオプションに-Werror（警告をエラー扱
いする）を指定している場合がある．そのようなターゲットにおいて，アプリ
ケーションで警告が避けられない場合には，ターゲット依存部を修正してコン
パイルオプションを削除する必要がある．

TOPPERS_OMIT_SYSLOGをマクロ定義してコンパイルすることで，システムログ
出力を抑止することができる．


７．コンフィギュレータの使い方

コンフィギュレータ（cfg）による処理は，「TOPPERS第3世代カーネル（ITRON
系）統合仕様書」の「2.12.5 コンフィギュレータの処理モデル」の節の記述の
通り，3つのパスで構成される．

コンフィギュレータの使い方について，標準のMakefileを使用している場合に
はほとんど知る必要がない．この章では，標準のMakefileを修正する場合や独
自のMakefileを用いる場合のために，ASP3カーネルを使用する上で必要となる
コンフィギュレータの使い方について説明する．

なお，コンフィギュレータの使用方法に関する詳細は，「TOPPERS第3世代カー
ネル向け Ruby版コンフィギュレータ ユーザーズマニュアル」を参照すること．

7.1 コンフィギュレータの起動

コンフィギュレータは，システムコンフィギュレーションファイル名（パス1
でのみ有効）をパラメータに取り，以下のオプションを持つ（ASP3カーネルで
使用するもの）．

	-k［--kernel］<カーネル名>
		カーネルの名称を指定する．ASP3カーネルでは，aspを指定する．

	-p［--pass］<パス番号>
		パス番号を指定する．1〜3のいずれか．

	-I［--include-directory］<インクルードディレクトリ名>
		INCLUDEディレクティブによりインクルードするコンフィギュレーショ
		ンファイルを探すディレクトリ名を指定する．生成スクリプト（trbファ
		イル）を探す場合にも用いる．

	-T［--trb-file］<生成スクリプト名>
		生成スクリプト（trbファイル）の名称を指定する．パス2とパス3で有
		効．

	--api-table <静的APIテーブルファイル名>
		静的APIテーブルのファイル名を指定する．パス1でのみ有効．

	--symval-table <値取得シンボルテーブルファイル名>
		値取得シンボルテーブルのファイル名を指定する．パス1でのみ有効．

	-r［--rom-image］<ロードモジュールのダンプファイル名>
		ロードモジュールのダンプファイルの名称を指定する．ファイルの拡
		張子がsrecの場合はSレコード形式，dumpの場合はobjdumpコマンドに
		よるダンプ形式として読み込む．パス2とパス3で有効．

	-s [--rom-symbol] <ロードモジュールのシンボルファイル名>
		ロードモジュール中の各シンボルとアドレスの対応表を含むシンボル
		ファイルの名称を指定する．パス2とパス3で有効．

	--id-output-file <ID番号出力ファイル名>
		オブジェクトのID番号の割付け結果を，指定した名前のファイルに書
		き出す．パス2でのみ有効．

	--id-input-file <ID番号入力ファイル名>
		オブジェクトのID番号の割付けを，指定した名前のファイルから取り
		込む．パス2でのみ有効．

	-M［--print-dependencies］<依存関係ファイル名>
		システムコンフィギュレーションファイルの依存関係を出力する．パ
		ス1でのみ有効．GCCの-Mオプションと異なり，-Mオプションを付けた
		場合も，コンフィギュレータは通常の処理を行う（依存関係を出力す
		るだけという使い方はできない）．依存関係ファイル名を指定しない
		場合，標準出力に出力する．

	-O [--omit-output-db]
		次のパスに情報を引き渡すためのデータファイルを作成しない．

7.2 タイマドライバの組込み

カーネルが内部的に使用する割込みハンドラ（高分解能タイマドライバの割込
みハンドラなど）を登録するために，コンフィギュレータのパス1に，カーネル
実装のコンフィギュレーションファイル（target_kernel.cfg）を読み込ませる
必要がある．


８．システムサービス

ASP3カーネルの配布パッケージには，以下のシステムサービスが含まれている．

  ・システムログ機能
  ・シリアルインタフェースドライバ
	  - ターゲット非依存部
	  - ターゲット依存部
  ・システムログタスク
  ・低レベル出力（ターゲット依存部のみ）
  ・テストプログラム用サービス
  ・実行時間分布集計サービス
  ・カーネル起動メッセージ出力

これらのシステムサービスは，TOPPERS組込みコンポーネントシステム（TECS）
を用いて実装している．

参考のために，システムログ機能，シリアルインタフェースドライバ（ターゲッ
ト非依存部およびターゲット依存部），システムログタスク，低レベル出力の
間の結合関係を下の図に示す．

    +----------------------+       +------------------------+
    | TECSアプリケーション |       | 非TECSアプリケーション |
    +----------------------+       +------------------------+
        |cSysLog    |cSerialPort              .
        |           |                         .           アプリケーション
  - - - | - - - - - | - - - - - - - - - - - - . - - - - - - - - - - - - -
        |           +----------------------+  .          システムサービス
        |                 . . . . . . . . .|. . . . . .
        |                 .                |          .
        |        +----------------+        |  +----------------+ 
        | cSysLog| tSysLogAdapter |        |  | tSerialAdapter |
        +--------|  SysLogAdapter |        |  |  SerialAdapter |
        |        +----------------+        |  +----------------+
        |                                  |          |cSerialPort
        |        +----------+ cSerialPort  |          | 
        |        |          |--------------+----------+
        | cSysLog| tLogTask |                         |
        +--------|  LogTask |-------------------+     |
        |        |          |cnSerialPortManage |     |
        |        +----------+                   |     |
        |              |cPutLog                 |     |
        |              |                        |     |
        |eSysLog       |      enSerialPortManage|     |eSerialPort
   +----v----+         |                    +---v-----v---+
   | tSysLog |         |                    | tSerialPort |
   |  SysLog |         |                    | SerialPort1 |
   +---------+         |                    +---------^---+
       |cPutLog        |                cSIOPort|     |eiSIOCBR
       |               |                        |     | 
       +-------+-------+                        |     | ターゲット非依存部
  - - - - - - -|- - - - - - - - - - - - - - - - | - - | - - - - - - - - -
               |                                |     |   ターゲット依存部
               |                                |     |
               |ePutLog                 eSIOPort|     |ciSIOCBR
     +---------v--------+           +-----------v----------------+
     |   低レベル出力   |           |   シリアルインタフェース   |
     |   PutLogTarget   |           | ドライバのターゲット依存部 |
     +------------------+           |        SIOPortTarget1      |
                                    +----------------------------+

以下では，これらのシステムサービスを，C言語で記述されたアプリケーション
から使用する方法について説明する．ただし，テストプログラム用サービスに
ついては，「10.1 テストプログラム用サービス」の節で述べる．

また，ターゲット依存の低レベル出力は，アプリケーションから直接呼び出す
ことを想定していないため，このマニュアルでは説明しない．低レベル出力は，
コンポーネント記述ファイルで，ターゲット依存部のtarget.cdlをインポート
することで，システムに組み込むことができる．

8.1 システムログ機能

システムログ機能は，システム内で発生した異常事象等を，ログ情報として記
録するための機能である．また，記録したログ情報を取り出す機能も持つ．

システムログ出力を行うソースファイルでは，t_syslog.hをインクルードする．
また，システムログ機能のその他のサービスコールを呼び出すソースファイル
では，syslog.hをインクルードする．

8.1.1 システムログ機能の位置付け

システムログ機能は，カーネル内からも呼び出すことができるため，カーネル
より下の階層のモジュールと位置付けることができる．この意味では，他のシ
ステムサービスとは位置付けが異なる．

一方，ログ情報をシステム外部に出力するためには，シリアルインタフェース
ドライバなど，カーネル上で動作するシステムサービスを用いる必要がある．
そこで，ログ情報をシステム外部に出力するためのサービス（これを，システ
ムログタスクと呼ぶ）は，システムログ機能とは分離して実装することとし，
システムログ機能はログ情報の記録・取出しのための機能に絞っている．

以上のように，システムログ機能はカーネルより下の階層のモジュールである
が，システムログ機能の中でログ時刻を取り出すために，標準（ターゲット依
存部で変更しない場合）では，カーネルの機能を用いている．そのため，カー
ネルの実行開始前や終了後は，ログ時刻は正しく記録されない．

8.1.2 ログバッファへの記録と低レベル出力

上述したように，ログ情報をシステムの外部に出力するためには，カーネル上
で動作するシステムサービスを用いる必要があるため，カーネルの動作を継続
できないような重大な異常事象が起こった場合には，ログ情報を出力できなく
なる．また，これらのシステムサービス自身をデバッグする場合にも，ログ情
報の出力ができない．

そこで，カーネル上で動作するシステムサービスが使えない場合にでもログ情
報を出力するために，低レベル出力機能を用意する．低レベル出力機能は，ター
ゲット依存に用意する低レベルの文字出力関数を用いてログ情報を出力する機
能である．最終製品に組み込む場合などで，文字を出力する方法がない場合の
対応方法については，「11.3 システムログ機能の扱い」の節を参照すること．

ログ情報を，ログバッファへ記録するか低レベル出力機能を用いて出力するか
は，システムログ機能のセルの組上げ記述で設定し，システムログ機能のサー
ビスコール（syslog_msk_log）でシステム動作中に変更することができる．こ
れらの方法については後述する．

低レベル出力機能を用いると，ログメッセージの作成処理（printf相当の処理）
と低レベルの文字出力処理を全割込み禁止状態で行うために，割込み応答性が
悪くなることに注意しなければならない．特に，低レベルの文字出力処理はデ
バイスをポーリングする形で実装するのが通常で，その場合には，割込み応答
性は実用的と言えない程に悪くなる．

8.1.3 ログ情報の種別

システムログ機能は，ログ情報に以下の種別を設けている．

		LOG_TYPE_COMMENT	コメント
		LOG_TYPE_ASSERT		アサーションの失敗
		LOG_TYPE_INH		割込みハンドラ
		LOG_TYPE_ISR		割込みサービスルーチン
		LOG_TYPE_CYC		周期ハンドラ
		LOG_TYPE_ALM		アラームハンドラ
		LOG_TYPE_OVR		オーバランハンドラ
		LOG_TYPE_EXC		CPU例外ハンドラ
		LOG_TYPE_TSKSTAT	タスク状態変化
		LOG_TYPE_DSP		ディスパッチャ
		LOG_TYPE_SVC		サービスコール

ログ情報の種別の中で，LOG_TYPE_COMMENTとLOG_TYPE_ASSERT以外は，カーネル
のトレースログに用いるためのもので，システムログ機能では用いていない．

8.1.4 ログ情報の重要度

システムログ機能は，ログ情報を出力する際に指定する重要度に基づいて，実
際に出力するログ情報を動的に設定することができる．これは，UNIXのシステ
ムログ機能をまねたもので，ログの重要度の種類や指定方法もUNIXのAPIを参考
にしている．また，低レベル出力機能を用いて出力するログ情報も，重要度に
基づいて動的に設定することができる．

具体的には，ログの重要度として次の8段階を用意している．

		LOG_EMERG		カーネルの動作を継続できないエラー
		LOG_ALERT
		LOG_CRIT
		LOG_ERROR		重要性の低いシステムエラー
		LOG_WARNING		警告メッセージ．システムは安全に継続動作できる
		LOG_NOTICE
		LOG_INFO
		LOG_DEBUG		デバッグのためのメッセージ

どの重要度のログ情報をログバッファに記録するかと，どの重要度のログ情報
を低レベル出力機能を用いて出力するかは，システムログ機能のセルの組上げ
記述で設定し，システムログ機能のサービスコール（syslog_msk_log）でシス
テム動作中に変更することができる．

8.1.5 ログ情報のデータ構造

ログ情報を格納するためのデータ型として，SYSLOG構造体を用意している．
SYSLOG構造体には，ログ情報の種別（logtypeフィールド），ログ時刻
（logtimフィールド）と6つのログパラメータ（logparフィールド）が含まれる．

ログ時刻のデータ型（LOGTIM）とログパラメータのデータ型（LOGPAR）は，標
準ではそれぞれHRTCNT（高分解能タイマのカウント値のデータ型）とintptr_t
に定義されているが，ターゲット依存部（target_stddef.hまたはそこからイン
クルードされるファイル）により変更することができる．また，ログパラメー
タの数は，TNUM_LOGPARに定義されている．

SYSLOG構造体に格納されたログ情報を出力する場合，ログ時刻（logtimフィー
ルド）は出力関数（syslog_wri_log）によって書き込まれるため，出力関数を
呼ぶ側で書き込む必要はない．

8.1.6 システムログ機能のサービスコールとマクロ

システムログ機能の提供するサービスコールとマクロは次の通りである．これ
らを呼び出すソースファイルでは，syslog.hをインクルードする．

(1) ER syslog_wri_log(uint_t prio, const SYSLOG *p_syslog)

システムログ機能に，p_syslogで指定されるログ情報を，prioで指定される重
要度で出力する（ログバッファへ記録するか低レベル出力機能を用いて出力す
る）．

(2) ER_UINT syslog_rea_log(SYSLOG *p_syslog)

ログバッファからログ情報を1つ取り出す．ログバッファが空の時はE_OBJ，そ
うでない場合は，ログバッファのオーバフローにより失われたログ情報の数
（ログ情報が失われていない場合は0）を返す．システムログタスクが用いるこ
とを想定している．

(3) ER syslog_msk_log(uint_t logmask, uint_t lowmask)

ログバッファに記録すべきログ情報の重要度の示すビットマップ（logmask）と，
低レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマップ
（lowmask）を設定する．ビットマップを作るためのマクロとして，LOG_MASKと
LOG_UPTOを用意している．

(4) ER syslog_ref_log(T_SYSLOG_RLOG *pk_rlog)

システムログ機能の状態を参照する．具体的には，ログバッファに記録されて
いるログ情報の数（T_SYSLOG_RLOG構造体のcountフィールド），ログバッファ
のオーバフローにより失われたログ情報の数（lostフィールド），ログバッファ
に記録すべきログ情報の重要度の示すビットマップ（logmaskフィールド），低
レベル出力機能を用いて出力すべきログ情報の重要度を示すビットマップ
（lowmaskフィールド）を参照することができる．

(5) ER syslog_fls_log(void)

ログバッファに記録されているログ情報をすべて取り出し，低レベル出力機能
を用いて出力する．

(6) UINT LOG_MASK(UINT prio)

重要度prioのみセットされたビットマップを作るマクロ．syslog_msk_logに渡
す引数を作るために用いる．

(7) UINT LOG_UPTO(UINT prio)

重要度prio以上の重要度がすべてセットされたビットマップを作るマクロ．
syslog_msk_logに渡す引数を作るために用いる．

8.1.7 システムログ出力のためのライブラリ関数

システムログ出力のためのライブラリ関数は次の通りである．これらを呼び出
すソースファイルでは，t_syslog.hをインクルードする．

(1) void syslog_n(uint_t prio, const char *format, arg1, ..., argn)
    ※ nは0〜5のいずれか．

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するためのマクロ．

formatはメッセージのフォーマット記述（printfのフォーマット記述と類似），
arg1〜argnはフォーマット記述中で参照される値である．arg1〜argnは，この
マクロ中でLOGPAR型にキャストされるため，LOGPAR型に型変換できる任意の型
を渡すことができ，型チェックはされない．formatおよびarg1〜argnには，次
の制限がある．

・formatのフォーマット記述は，定数文字列を渡すことを想定しており，この
マクロ処理を終えた後も変化してはならない．

・format中に使えるフォーマット指定は次の通り．

	%d		引数をint_t型とみなし，10進数で表示
	%u		引数をuint_t型とみなし，10進数で表示
	%x		引数をuint_t型とみなし，16進数（英文字は小文字）で表示
	%X		引数をuint_t型とみなし，16進数（英文字は大文字）で表示
	%p		引数をポインタとみなし，16進数（英文字は小文字）で表示
	%c		引数を文字コードとみなし，文字を表示
	%s		引数を文字列を示すポインタとみなし，文字列を表示
	%%		'%'を表示（引数は取らない）

%d, %u, %x, %Xにおいては，'%'の直後に表示桁数を指定する10進数値を記述す
ることができる．その場合，表示すべき文字列が指定した桁数に満たない場合
には，指定した桁数内に右詰めで表示する．10進数値が'0'で始まる場合には，
その間に'0'を埋める．

また，サイズ指定を付与した次のフォーマット指定も使うことができる．

	%ld		引数をlong_t型とみなし，10進数で表示
	%lu		引数をulong_t型とみなし，10進数で表示
	%lx		引数をulong_t型とみなし，16進数（英文字は小文字）で表示
	%lX		引数をulong_t型とみなし，16進数（英文字は大文字）で表示

	%td		引数をint32_t型とみなし，10進数で表示
	%tu		引数をuint32_t型とみなし，10進数で表示
	%tx		引数をuint32_t型とみなし，16進数（英文字は小文字）で表示
	%tX		引数をuint32_t型とみなし，16進数（英文字は大文字）で表示

	%Tu		引数をSYSTIM型とみなし，10進数で表示
	%Tx		引数をSYSTIM型とみなし，16進数（英文字は小文字）で表示
	%TX		引数をSYSTIM型とみなし，16進数（英文字は大文字）で表示

ただし，引数をログ情報に出力する際には，LOGPAR型にキャストされる．その
ため，LOGPAR型（標準ではintptr_tに定義）より大きいサイズのデータは，正
しく表示されない．正しく表示したい場合には，ターゲット依存部でLOGPAR型
の定義を変更すれば良い．

%tu，%tx，%tXは，RELTIM型やTMO型の変数を表示するために使うことを想定し
た機能である．

・arg1〜argnにポインタを渡す場合（%sに対応する引数の場合），ポインタの
の指すデータは，このマクロ処理を終えた後も変化してはならない．定数文字
列を渡すことを想定している．

(2) void syslog(uint_t prio, const char *format, ...)

format文字列およびそれに続く引数から作成されるメッセージを，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力するための関数で，引
数の数を可変にしたもの．formatに続く引数は最大5個まで．formatおよびそれ
に続く引数には，syslog_nと同様の制限がある．

このライブラリ関数は，可変数引数を処理するために内部で文字列をスキャン
する．そのため，実行時間が長くなる可能性があり，割込み禁止状態で呼び出
すべきではない．主にアプリケーションプログラムが用いることを想定してい
る．

このライブラリ関数を用いる場合には，vasyslog.cをコンパイル・リンクする．

(3) void t_perror(uint_t prio, const char *file, int_t line,
										const char *expr, ER ercd);

サービスコールがエラーを返した場合に用いることを想定した関数で，ファイ
ル名，行番号，メインエラーコード，サブエラーコード等を，ログ種別が
LOG_TYPE_COMMENTのログ情報として，重要度prioで出力する．

このライブラリ関数を用いる場合には，t_perror.cをコンパイル・リンクする．

8.1.8 システムログ機能の組込みと取外し

システムログ機能は，システムログ機能の本体と，システムログ機能をC言語で
記述されたアプリケーションから呼び出すためのアダプタで構成される．

システムログ機能の本体は，コンポーネント記述ファイルでtSysLog.cdlをイン
ポートし，以下のようなセルの組上げ記述を含めることで，システムに組み込
むことができる（sample1.cdlには，この記述が含まれている）．

----------------------------------------
cell tSysLog SysLog {
	logBufferSize = 32;					/* ログバッファのサイズ */
	initLogMask = C_EXP("LOG_UPTO(LOG_NOTICE)");
										/* ログバッファに記録すべき重要度 */
	initLowMask = C_EXP("LOG_UPTO(LOG_EMERG)");
									   	/* 低レベル出力すべき重要度 */
	/* 低レベル出力との結合 */
	cPutLog = PutLogTarget.ePutLog;
};
----------------------------------------

この記述を変更することで，システムログ機能のログバッファのサイズ，ログ
バッファに記録すべき重要度の初期値，低レベル出力すべき重要度の初期値を
変更することができる．

システムログ機能のアダプタは，コンポーネント記述ファイルで
tSysLogAdapter.cdlをインポートし，以下のセルの組上げ記述を含めることで，
システムに組み込むことができる（sample1.cdlには，この記述が含まれてい
る）．

----------------------------------------
cell tSysLogAdapter SysLogAdapter {
	cSysLog = SysLog.eSysLog;
};
----------------------------------------

システムログ機能を取り外す場合には，上の2つのセルの組上げ記述を削除し，
コンパイルオプションに-DTOPPERS_OMIT_SYSLOGを追加すればよい．ただし，シ
ステムログタスクはシステムログ機能を使用するため，それも外すことが必要
である．

8.2 シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルポートを扱うためのドライバで
ある．

8.2.1 シリアルインタフェースドライバのサービスコール

シリアルインタフェースドライバを呼び出すサービスコールの仕様は次の通り
である．この中で，シリアルポートのID番号（portid）の解釈はターゲット依
存となる．これらのサービスコールを呼び出すソースファイルでは，serial.h
をインクルードする．

シリアルインタフェースドライバのサービスコールは，非タスクコンテキスト
から呼び出すことはできない．また，serial_rea_datとserial_wri_datは，ディ
スパッチ保留状態で呼び出すことはできない．いずれも，呼び出した場合には
E_CTXエラーとなる．

(1) ER serial_opn_por(ID portid)

portidで指定されたシリアルポートをオープンし，受信／送信が可能な状態に
する．

(2) ER serial_cls_por(ID portid)

portidで指定されたシリアルポートをクローズする．

(3) ER_UINT serial_rea_dat(ID portid, char *buf, uint_t len)

portidで指定されたシリアルポートから，lenバイトの文字列を受信し，bufか
らの領域に入れる．lenバイト受信するまで，待ち状態となる．受信した文字数
またはエラーコードを返す．

複数のタスクからserial_rea_datを呼び出した場合，シリアルポートから受信
した文字列が，文字単位に別のタスクに振り分けられる可能性がある．これを
避けたい場合には，serial_rea_datを呼び出す側でセマフォなどを用いて排他
制御する必要がある．

(4) ER_UINT serial_wri_dat(ID portid, const char *buf, uint_t len)

portidで指定されたシリアルポートに，bufからのlenバイトの文字列を送信す
る．lenバイト送信バッファに入れるまで，待ち状態となる．送信した文字数ま
たはエラーコードを返す．

複数のタスクからserial_wri_datを呼び出した場合，それらが送信しようとし
た文字列が，文字単位で混ざってシリアルポートに送信される可能性がある．
これを避けたい場合には，serial_wri_datを呼び出す側でセマフォなどを用い
て排他制御する必要がある．

(5) ER serial_ctl_por(ID portid, uint_t ioctl)

portidで指定されたシリアルポートの制御情報を，ioctlで示される値に設定す
る．

ioctlには，以下の制御情報を表す定数を，ビット毎に論理和をとったものを
指定する．

	IOCTL_ECHO（エコーバックモード）
		このビットを設定すると，シリアルインタフェースドライバがエコー
		バックを行う．具体的には，バッファから文字を取り出す度に，その
		文字を書き出す．

	IOCTL_CRLF（改行モード）
		LF（line feed）を書き出すと，CR（carriage return）＋LFに変換し
		て書き出す．

	IOCTL_FCSND（送信フロー制御）
		文字を送信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，STOP（コントロール-S）を受信すると送信を停止し，
		START（コントロール-Q）を受信すると送信を再開する．

	IOCTL_FCANY（送信フロー制御で任意の文字で送信再開）
		IOCTL_FCSNDを指定している時に，送信停止中に受信した任意の文字
		で送信を再開する．

	IOCTL_FCRCV（受信フロー制御）
		文字を受信する処理に対して，XON/XOFFによるフロー制御を行う．
		すなわち，受信バッファの残り領域が少なくなるとSTOP（コントロー
		ル-S）を送出し，残り領域が増えればSTART（コントロール-Q）を送
		出する．

なお，オープン直後のデフォルトの設定値は(IOCTL_ECHO | IOCTL_CRLF |
IOCTL_FCSND | IOCTL_FCRCV)である．

(6) ER serial_ref_por(ID portid, T_SERIAL_RPOR *pk_rpor)

portidで指定されたシリアルポートの状態を参照し，pk_rporで指定されるパケッ
トに返す．パケット中のreacntには受信バッファ中の文字数を，wricntには送
信バッファ中の文字数を返す．

8.2.2 シリアルインタフェースドライバのその他のサービス

シリアルインタフェースドライバは，前節のサービスコールに加えて，システ
ムの終了時に未送信の文字を取り出すための機能（終了処理ルーチンから呼び
出すことを想定）を持つが，C言語で記述されたアプリケーションから呼び出す
ことは想定していない．

8.2.3 シリアルインタフェースドライバの組込みと取外し

シリアルインタフェースドライバは，シリアルインタフェースドライバのター
ゲット非依存部，シリアルインタフェースドライバのターゲット依存部と，シ
リアルインタフェースドライバをC言語で記述されたアプリケーションから呼び
出すためのアダプタで構成される．

シリアルインタフェースドライバのターゲット依存部は，コンポーネント記述
ファイルで，ターゲット依存部のtarget.cdlをインポートすることで，システ
ムに組み込むことができる．

シリアルインタフェースドライバのターゲット非依存部は，コンポーネント記
述ファイルでtSerialPort.cdlをインポートし，以下のようなセルの組上げ記述
を含めることで，システムに組み込むことができる（SIOPortTarget1の組上げ
記述が，ターゲット依存部に含まれていることを想定．シリアルポート毎に，
セルの組上げ記述が必要．sample1.cdlには，この記述が含まれている）．

----------------------------------------
cell tSerialPort SerialPort1 {
	receiveBufferSize = 256;			/* 受信バッファのサイズ */
	sendBufferSize    = 256;			/* 送信バッファのサイズ */

	/* ターゲット依存部との結合 */
	cSIOPort = SIOPortTarget1.eSIOPort;
	eiSIOCBR <= SIOPortTarget1.ciSIOCBR;	/* コールバック */
};
----------------------------------------

この記述を変更することで，シリアルインタフェースドライバの受信バッファ
のサイズと送信バッファのサイズを変更することができる（シリアルポート毎
に別々に設定することもできる）．

シリアルインタフェースドライバのアダプタは，コンポーネント記述ファイル
でtSerialAdapter.cdlをインポートし，以下のようなセルの組上げ記述を含め
ることで，システムに組み込むことができる（シリアルインタフェースを1ポー
トのみサポートする場合．sample1.cdlには，この記述が含まれている）．

----------------------------------------
cell tSerialAdapter SerialAdapter {
	cSerialPort[0] = SerialPort1.eSerialPort;
};
----------------------------------------

シリアルインタフェースドライバを取り外す場合には，上の2つのセルの組上げ
記述を削除すればよい．ただし，システムログタスクはシリアルインタフェー
スドライバを使用するため，それも外すことが必要である．

8.3 システムログタスク

システムログタスクは，システムログ機能からログ情報を取り出し，それをシ
ステムの外部に出力するためのサービスである．

ASP3カーネルの配布パッケージに含まれるシステムログタスクは，シリアルイ
ンタフェースドライバを用いてログ情報を文字列の形で出力するもので，シス
テムログタスクの一例という位置付けで提供している．

8.3.1 システムログタスクの機能

システムログタスクは，実行開始されると，まず，結合されたシリアルインタ
フェースドライバのシリアルポートをオープンする．

その後，システムログ機能を用いてログバッファからログ情報を取り出し，そ
れを文字列に変換して，シリアルポートに出力する．ログバッファが空の場合
には，一定時間（デフォルトでは10ミリ秒．セルの組上げ記述で変更可能）待
つ．これらの処理を，カーネルの終了まで繰り返す．

カーネルの終了処理では，シリアルインタフェースドライバの送信バッファに
蓄積されたデータと，ログバッファに記録されたログ情報を，低レベル出力機
能を用いて出力する．出力すべきログ情報がある場合には，それを出力する前
に，"-- buffered messages --"という文字列を出力する．

これにより，カーネル終了時点で未出力のログ情報のほとんどを出力すること
ができる．ただし，カーネル終了時点で，システムログタスクがログバッファ
から取り出したが，まだシリアルポートに送っていないログ情報は，出力され
ない．

8.3.2 システムログタスクのその他のサービス

システムログタスクは，前節の機能に加えて，システムログ機能のログバッファ
中のログ情報が指定した数以下になるまで待つ（指定した数が0の場合には，シ
リアルインタフェースドライバの送信バッファが空になるのも待つ）機能を持
つが，C言語で記述されたアプリケーションから呼び出すことは想定していない．

8.3.3 システムログタスクの組込みと取外し

システムログタスクは，コンポーネント記述ファイルでtLogTask.cdlをインポー
トし，以下のようなセルの組上げ記述を含めることで，システムに組み込むこ
とができる（sample1.cdlには，このような記述が含まれている）．

----------------------------------------
cell tLogTask LogTask {
	priority  = 3;					/* システムログタスクの優先度 */
	stackSize = LogTaskStackSize;	/* システムログタスクのスタックサイズ */
	interval = 10000;				/* システムログタスクの動作間隔 */
	flushWait = 1000;				/* フラッシュ待ちの単位時間 */

	/* シリアルインタフェースドライバとの結合 */
	cSerialPort        = SerialPort1.eSerialPort;
	cnSerialPortManage = SerialPort1.enSerialPortManage;

	/* システムログ機能との結合 */
	cSysLog = SysLog.eSysLog;

	/* 低レベル出力との結合 */
	cPutLog = PutLogTarget.ePutLog;
};
----------------------------------------

この記述を変更することで，システムログタスクの優先度，スタックサイズ，
動作間隔（ログバッファが空の場合に待つ時間），フラッシュ待ちの単位時間
を変更することができる．

システムログタスクを取り外す場合には，上のセルの組上げ記述を削除すれば
よい．

8.4 実行時間分布集計サービス

実行時間分布集計サービスは，システムのリアルタイム性能を評価するために，
プログラム区間の実行時間を計測し，その分布を集計・表示するためのシステ
ムサービスである．

8.4.1 実行時間分布集計サービスの概要

実行時間分布集計サービスは，複数のプログラム区間の実行時間を計測・集計・
表示することができる．プログラム区間毎に，実行時間分布を記録するための
データ構造を持つ．どのデータ構造を用いるかを，ID番号（histid）で指定す
る．

ターゲット依存部で設定を変更していない場合，実行時間分布集計サービスは，
カーネルの高分解能タイマを参照する機能（fch_hrt）を用いて実行時間を計測
する．そのため，実行時間はマイクロ秒単位で記録される（精度はターゲット
依存）．また，記録される時間には，計測のためのオーバヘッド（fch_hrtの実
行時間＋α）が含まれる．

ターゲット依存部で設定を変更している場合の仕様については，ターゲット依
存部のユーザーズマニュアルを参照すること．

8.4.2 実行時間分布集計サービスのサービスコール

実行時間分布集計サービスを呼び出すサービスコールの仕様は次の通りである．
これらのサービスコールを呼び出すソースファイルでは，histogram.hをインク
ルードする．

(1) ER init_hist(ID histid)

histidで指定されたデータ構造を初期化する．

(2) ER begin_measure(ID histid)

実行時間を計測するプログラム区間の直前に呼び出す関数．histidで指定され
たデータ構造に，現在のシステム時刻を記録する．

(3) ER end_measure(ID histid)

実行時間を計測するプログラム区間の直後に呼び出す関数．現在のシステム時
刻と，histidで指定されたデータ構造に記録された開始時刻から，プログラム
区間の実行時間を求め，その結果を記録する．

(4) ER print_hist(ID histid)

システムログ機能を用いて，実行時間分布の計測結果を出力する．

8.4.3 実行時間分布集計サービスの組込みと取外し

実行時間分布集計サービスは，実行時間分布集計サービスの本体と，実行時間
分布集計サービスをC言語で記述されたアプリケーションから呼び出すためのア
ダプタで構成される．

実行時間分布集計サービスの本体は，コンポーネント記述ファイルで
tHistogram.cdlをインポートし，以下のようなセルの組上げ記述を含めること
で，システムに組み込むことができる（perf_pf.cdlには，このような記述が含
まれている）．セルの組上げ記述は，実行時間分布を記録するためのデータ構
造毎に必要である．

----------------------------------------
cell tHistogram Histogram1 { };
cell tHistogram Histogram2 { maxTime = 2000 };
----------------------------------------

ここで，maxTimeは，集計できる最大実行時間である．上の例のHistogram1のよ
うにmaxTimeの指定を省略した場合，デフォルト値として1000が使われる．

実行時間分布集計サービスのアダプタは，コンポーネント記述ファイルで
tHistogramAdapter.cdlをインポートし，以下のようなセルの組上げ記述を含め
ることで，システムに組み込むことができる（実行時間分布を記録するための
データ構造を2つサポートする場合．perf_pf.cdlには，このような記述が含ま
れている）．

----------------------------------------
cell tHistogramAdapter HistogramAdapter {
	cHistogram[0] = Histogram1.eHistogram;
	cHistogram[1] = Histogram2.eHistogram;
};
----------------------------------------

8.5 カーネル起動メッセージ出力

カーネル起動メッセージ出力は，カーネルの起動時に，カーネルの名称やバー
ジョン番号，著作権表示などを出力するための機能である．

カーネル起動メッセージ出力は，コンポーネント記述ファイルでtBanner.cdlを
インポートし，以下のようなセルの組上げ記述を含めることで，システムに組
み込むことができる（BannerTargetNameとBannerCopyrightNoticeの定義が，ター
ゲット依存部に含まれていることを想定．sample1.cdlには，この記述が含まれ
ている）．

----------------------------------------
cell tBanner Banner {
	targetName      = BannerTargetName;
	copyrightNotice = BannerCopyrightNotice;
};
----------------------------------------


９．サポートライブラリ

サポートライブラリは，アプリケーションやシステムサービスを作成するため
に利用できるライブラリ関数群である．

9.1 基本的なライブラリ関数

基本的なライブラリ関数を用いる場合には，t_stdlib.hをインクルードする．

(1) const char *itron_strerror(ER ercd)

ercdで示されるエラーコードに対応するメインエラーコードの文字列を返す．

このライブラリ関数を用いる場合には，strerror.cをコンパイル・リンクする．

9.2 キュー操作ライブラリ関数

キュー操作ライブラリは，キューヘッダを含むリング構造のダブルリンクキュー
を扱うライブラリである．キューヘッダの次エントリはキューの先頭のエント
リ，前エントリはキューの末尾のエントリとする．また，キューの先頭のエン
トリの前エントリと，キューの末尾のエントリの次エントリは，キューヘッダ
とする．空のキューは，次エントリ，前エントリとも自分自身を指すキューヘッ
ダであらわす．

キュー操作ライブラリ関数を用いる場合には，queue.hをインクルードする．

キューヘッダとエントリのためのデータ構造として，QUEUE構造体を用いる．
QUEUE構造体の定義は次の通り．

	typedef struct queue {
		struct queue *p_next;		/* 次エントリへのポインタ */
		struct queue *p_prev;		/* 前エントリへのポインタ */
	} QUEUE;

キュー操作のために用意している関数は次の通り．

(1) void queue_initialize(QUEUE *p_queue);

キューを初期化する．p_queueにはキューヘッダを指定する．

(2) void queue_insert_prev(QUEUE *p_queue, QUEUE *p_entry);

p_queueで指定するエントリの前に，p_entryで指定するエントリを挿入する．
p_queueにキューヘッダを指定した場合には，キューの末尾にp_entryで指定す
るエントリを挿入することになる．

(3) void queue_insert_next(QUEUE *p_queue, QUEUE *p_entry);

p_queueで指定するエントリの次に，p_entryで指定するエントリを挿入する．
p_queueにキューヘッダを指定した場合には，キューの先頭にp_entryで指定す
るエントリを挿入することになる．

(4) void queue_delete(QUEUE *p_entry);

p_entryで指定するエントリを，キューから削除する．

(5) QUEUE *queue_delete_next(QUEUE *p_queue);

p_queueで指定するエントリの次のエントリをキューから削除し，削除したエン
トリを返す．p_queueにキューヘッダを指定した場合には，キューの先頭のエン
トリを取り出すことになる．p_queueに空のキューを指定して呼び出してはなら
ない．

(6) bool_t queue_empty(QUEUE *p_queue);

キューが空の場合にはtrue，そうでない場合にはfalseを返す．p_queueには
キューヘッダを指定する．

9.3 システムログ出力用ライブラリ関数

システムログ出力用ライブラリ関数は，ログ情報をフォーマット出力するため
に，システムログタスクおよびシステムログ機能で用いるための関数群である．

システムログ出力用ライブラリ関数を用いる場合には，log_output.hをインク
ルードし，log_output.cをコンパイル・リンクする．

(1) void syslog_printf(const char *format, const LOGPAR args[],
												void (*putc)(char))

formatで指定されるフォーマット記述とargsで指定されるパラメータ列から作
成したメッセージを，1文字出力関数putcを用いて出力する．なお，パラメー
タは最大5つまでしか渡すことができない．

(2) void syslog_print(const SYSLOG *p_syslog, void (*putc)(char))

p_syslogで指定されるログ情報を文字列に直し，1文字出力関数putcを用いて出
力する．

(3) void syslog_lostmsg(uint_t lost, void (*putc)(char))

lost個のログ情報が失われた旨のメッセージを，1文字出力関数putcを用いて出
力する．


１０．テストプログラム

テストプログラムは，カーネルの機能テストおよび性能評価を行うためのプロ
グラム群である．

10.1 テストプログラム用サービス

テストプログラム用サービスは，プログラム中のチェックポイントが正しい順
序で実行されたことなど，プログラムが正しく動作していることをチェックす
るためのシステムサービスである．プログラムが正しく動作していないことを
検出した場合には，プログラムを終了させる．

10.1.1 テストプログラム用サービスのサービスコール

テストプログラム用サービスを呼び出すサービスコールの仕様は次の通りであ
る．これらのサービスコールを呼び出すソースファイルでは，test_svc.hをイ
ンクルードする．

(1) void test_start(const char *progname)

テストプログラムの開始時に呼び出す関数．prognameには，テストプログラム
名を渡す．

(2) void check_point(uint_t count)

チェックポイントを通過する際に呼び出す関数．countには，何番目のチェック
ポイントであるかを指定する（最初のチェックポイントでは1を指定する）．
countの値が，最初のチェックポイントにおいては1でない場合に，それ以降の
チェックポイントにおいては，前のチェックポイント通過時にcountに指定した
値に1を加えた値でない場合に，プログラムが正しく動作していないと見なし，
プログラムを終了させる．

(3) void check_finish(uint_t count)

最後のチェックポイントに到達した際に呼び出す関数．countには，何番目の
チェックポイントであるかを指定する．countの値が，前のチェックポイント
通過時にcountに指定した値に1を加えた値でない場合に，プログラムが正しく
動作していないと見なす．この関数は，プログラムが正しく動作している／い
ないに関わらず，プログラムを終了させる．

チェックポイントを使用しないテストプログラムの場合には，countに0を指定
してこの関数を呼び出し，プログラムを終了させる．

(4) void check_assert(bool_t exp)

expが真であることをチェックしたい場合に呼び出す関数．expが偽である場合
に，プログラムが正しく動作していないと見なし，プログラムを終了させる．

(5) void check_ercd(ER ercd, ER expected_ercd)

ercdがexpected_ercdに一致していることをチェックしたい場合に呼び出す関数．
ercdがexpected_ercdに一致していない場合に，プログラムが正しく動作してい
ないと見なし，プログラムを終了させる．

(6) void check_state(bool_t ctx, bool_t loc,
						bool_t dsp, bool_t dpn, bool_t ter)

システム状態が期待したものになっているかチェックしたい時に呼び出す関数．
ctx，loc，dsp，dpn，terには，それぞれsns_ctx()，sns_loc()，sns_dsp()，
sns_dpn()，sns_ter()の返値として期待される値を指定する．この内のいずれ
かが期待される値と一致していない場合に，プログラムが正しく動作していな
いと見なし，プログラムを終了させる．

(7) void check_ipm(PRI ipm)

割込み優先度マスクが期待した値になっているかチェックしたい時に呼び出す
関数．ipmには，get_ipm()で参照できる割込み優先度マスクとして期待される
値を指定する．期待される値と一致していない場合に，プログラムが正しく動
作していないと見なし，プログラムを終了させる．

10.1.2 テストプログラム用サービスの組込みと取外し

テストプログラム用サービスは，コンポーネント記述ファイルで
tTestService.cdlをインポートし，以下のセルの組上げ記述を含めることで，
システムに組み込むことができる（test_pf.cdlには，この記述が含まれてい
る）．

----------------------------------------
cell tTestService TestService {
	cSysLog = SysLog.eSysLog;
};
----------------------------------------

テストプログラム用サービスのアダプタは，コンポーネント記述ファイルで
tTestServiceAdapter.cdlをインポートし，以下のセルの組上げ記述を含める
ことで，システムに組み込むことができる（test_pf.cdlには，この記述が含
まれている）．

----------------------------------------
cell tTestServiceAdapter TestServiceAdapter {
	cTestService = TestService.eTestService;
};
----------------------------------------

テストプログラム用サービスを取り外す場合には，上の2つのセルの組上げ記
述を削除すればよい．

10.2 カーネルの自己診断機能

テストプログラム用サービスのオプション機能として，チェックポイントを通
過する度に，カーネル内の各データ構造の一貫性を検査する自己診断機能を用
意している（現時点では，すべてのデータ構造をカバーできていない）．

カーネルの自己診断機能を用いるためには，コンポーネント記述ファイルに，
以下の記述を含める．

----------------------------------------
[singleton]
celltype tBitKernel {
	entry	sBuiltInTest	eBuiltInTest;
};

cell tBitKernel BitKernel {
	eBuiltInTest <= TestService.cBuiltInTest;	/* テストサービスに接続 */
};
----------------------------------------

test_pf.cdlを用いている場合には，それをtest_pf_bitkernel.cdlに代えるこ
とで，カーネルの自己診断機能を用いることができる．

なお，カーネル内の各データ構造の一貫性を検査するプログラムは，
test/tBitKernel.cに含まれている．

10.3 機能テストプログラム

testディレクトリに置かれた"test"で始まるプログラムは，カーネルの機能テ
ストを行うためのプログラムである．

機能テストプログラムはテストプログラム用サービスを使用しているため，構
築する場合には，コンポーネント記述ファイルにtest_pf.cdlを使用する必要が
ある．コンフィギュレーションスクリプトを使用する場合には，-Cオプション
でtest_pf.cdlを指定する．具体的には，次のコマンドを実行すればよい（構築
用のディレクトリが，ASP3カーネルのソースファイルを展開したディレクトリ
の直下にあると仮定している）．

	% ruby ../configure.rb -T <ターゲット略称> -a ../test \
						-A <テストプログラム名> -C test_pf.cdl

ただし，CPU例外処理のテスト(1)〜(13)は，同一のシステムコンフィギュレー
ションファイル（test_cpuexc.cfg）を共用しているため，-cオプションで
test_cpuexc.cfgを指定する必要がある．

	% ruby ../configure.rb -T <ターゲット略称> -a ../test \
						-A <テストプログラム名> -C test_pf.cdl \
						-c test_cpuexc.cfg

現バージョンで用意している機能テストプログラムは次の通り．

(1) test_cpuexc1			CPU例外処理のテスト(1)
(2) test_cpuexc2			CPU例外処理のテスト(2)
(3) test_cpuexc3			CPU例外処理のテスト(3)
(4) test_cpuexc4			CPU例外処理のテスト(4)
(5) test_cpuexc5			CPU例外処理のテスト(5)
(6) test_cpuexc6			CPU例外処理のテスト(6)
(7) test_cpuexc7			CPU例外処理のテスト(7)
(8) test_cpuexc8			CPU例外処理のテスト(8)
(9) test_cpuexc9			CPU例外処理のテスト(9)
(10) test_cpuexc10			CPU例外処理のテスト(10)
(11) test_dlynse			sil_dly_nseに関するテスト
(12) test_exttsk			自タスクの終了に関するテスト
(13) test_flg1				イベントフラグ機能のテスト(1)
(14) test_dtq1				データキュー機能のテスト(1)
(15) test_hrt1.c			fch_hrtに関するテスト(1)
(16) test_int1.c			割込み管理機能のテスト(1)
(17) test_mutex1			ミューテックス機能のテスト(1)
(18) test_mutex2			ミューテックス機能のテスト(2)
(19) test_mutex3			ミューテックス機能のテスト(3)
(20) test_mutex4			ミューテックス機能のテスト(4)
(21) test_mutex5			ミューテックス機能のテスト(5)
(22) test_mutex6			ミューテックス機能のテスト(6)
(23) test_mutex7			ミューテックス機能のテスト(7)
(24) test_mutex8			ミューテックス機能のテスト(8)
(25) test_pdq1				優先度データキュー機能のテスト(1)
(26) test_notify1			通知処理のテスト(1)
(27) test_raster1			タスク終了要求機能に関するテスト(1)
(28) test_raster2			タスク終了要求機能に関するテスト(2)
(29) test_sem1				セマフォ機能のテスト(1)
(30) test_sem2				セマフォ機能のテスト(2)
(31) test_suspend1			強制待ち状態に関するテスト(1)
(32) test_sysman1			システム状態管理機能のテスト(1)
(33) test_sysstat1			システム状態に関するテスト(1)
(34) test_task1				タスク管理モジュールのテスト(1)
(35) test_tmevt1.c			タイムイベント管理モジュールのテスト(1)

CPU例外処理のテストプログラムの一部は，CPU例外ハンドラからリターンした
場合に，CPU例外を発生させた命令の次から実行が継続されることを前提に作成
されている．この前提が成り立たない場合には，テストプログラムのターゲッ
ト依存定義において，PREPARE_RETURN_CPUEXCの定義で対応することが必要であ
る．詳しくは，「ターゲット依存部 ポーティングガイド」を参照すること．

10.4 タイマドライバシミュレータを用いたテストプログラム

testディレクトリに置かれた"simt"で始まるプログラムは，タイマドライバシ
ミュレータを用いたテストプログラムで，主に，高分解能タイマを用いて実現
したシステム時刻管理機能に関するテストを行う．

タイマドライバシミュレータを用いたテストプログラムは，テストプログラム
から時刻の進み方を制御できるタイマドライバシミュレータを必要とする．そ
のため，タイマドライバシミュレータを組み込んだターゲット依存部を用いて
テストを行わなければならない．

タイマドライバシミュレータを組み込んだカーネルをコンパイルする際には，
高分解能タイマモジュールの性質を切り換えるためのマクロ定義が必要である．
具体的には，-DHRT_CONFIG1，-DHRT_CONFIG2，-DHRT_CONFIG3のいずれかのコ
ンパイルオプションをつける必要がある．どのコンパイルオプションを付ける
べきかは，テストプログラム毎に決まっている．また，カーネル内部の振舞い
をチェックするために，-DHOOK_HRT_EVENTもつける必要がある．

システム時刻管理機能テストプログラムは，機能テストプログラムと同様に，
テストプログラム用サービスを使用している．

以上より，システム時刻管理機能テストプログラムをコンフィギュレーション
スクリプトを使用して構築する場合には，次のコマンドを実行すればよい（構
築用のディレクトリが，ASP3カーネルのソースファイルを展開したディレクト
リの直下にあると仮定している）．

	% ruby ../configure.rb -T <テスト用のターゲット略称> -a ../test \
				-A <テストプログラム名> -C test_pf.cdl \
				-O -DHRT_CONFIG<1または2または3> -DHOOK_HRT_EVENT

現バージョンで用意しているシステム時刻管理機能テストプログラムは次の通
り．

(1) simt_systim1			システム時刻管理機能のテスト(1)
(2) simt_systim2			システム時刻管理機能のテスト(2)
(3) simt_systim3			システム時刻管理機能のテスト(3)
(4) simt_systim4			システム時刻管理機能のテスト(4)
(5) simt_systim1_64hrt		システム時刻管理機能のテスト(1)（USE_64BIT_HRTCNT）
(6) simt_systim2_64hrt		システム時刻管理機能のテスト(2)（USE_64BIT_HRTCNT）
(7) simt_systim3_64hrt		システム時刻管理機能のテスト(3)（USE_64BIT_HRTCNT）

この内，simt_systim1〜simt_systim3は-DHRT_CONFIG1をつけて，
simt_systim4は-DHRT_CONFIG2をつけて，simt_systim1_64hrt〜
simt_systim3_64hrtは-DHRT_CONFIG3をつけて，コンパイルすること．

なお，タイマドライバシミュレータを用いたカーネルのテスト手法の詳細につ
いては，「タイマドライバシミュレータを用いたカーネルのテスト手法」
（simtimer.txt）を参照すること．

10.5 性能評価プログラム

testディレクトリに置かれた"perf"で始まるプログラムは，カーネルの性能評
価を行うためのプログラムである．

性能評価プログラムは，計測対象となる処理を繰り返し実行し，その実行時間
を計測して，実行時間分布を表示する．

計測した実行時間には，時間計測のオーバヘッド（時間計測処理の実行にかか
る時間）が含まれる．計測対象の処理の正味の実行時間を求めるためには，計
測された時間から，時間計測のオーバヘッドを計測するためのプログラム
（perf0）で計測された時間を減算する必要がある．

また，実行時間の計測は，別に記述がない限り割込みを許可したまま行うため，
割込みハンドラ（少なくとも，タイマ割込みハンドラ）の処理時間が含まれた
実行結果が計測される．

カーネルの性能評価にあたっては，ハードウェア（特にキャッシュ）の設定に
留意する必要がある．

性能評価プログラムはテストプログラム用サービスと実行時間分布集計サービ
スを使用しているため，構築する場合には，コンポーネント記述ファイルに
perf_pf.cdlを使用する必要がある．コンフィギュレーションスクリプトを使用
する場合には，-Cオプションでperf_pf.cdlを指定する．具体的には，次のコマ
ンドを実行すればよい（構築用のディレクトリが，ASP3カーネルのソースファ
イルを展開したディレクトリの直下にあると仮定している）．

	% ruby ../configure.rb -T <ターゲット略称> -a ../test \
						-A <性能評価プログラム名> -C perf_pf.cdl

現バージョンで用意している性能評価プログラムは次の通り．

(1) perf0		時間計測のオーバヘッドの評価

時間計測のオーバヘッドを計測するためのプログラム．具体的には，空のプロ
グラム（begin_mearsureとend_measureを続けて呼び出すプログラム）の実行時
間を計測する．

他の性能評価プログラムで計測された時間から，このプログラムで計測された
時間を減算した時間が，計測対象の処理の正味の実行時間である．

(2) perf1		slp_tsk，wup_tskによるタスク切換え時間の評価

slp_tsk，wup_tskによるタスク切換え時間を計測するためのプログラム．具体
的には，高い優先度のタスクが起床待ち状態である時に，低い優先度のタスク
がwup_tskにより高い優先度のタスクを起床し，高い優先度のタスクに切り換わ
るまでの時間と，高い優先度のタスクがslp_tskにより起床待ち状態となり，低
い優先度のタスクに切り換わるまでの時間を計測する．

(3) perf2		snd_pdqの処理時間の評価

優先度データキューに蓄積されているデータの数により，snd_pdqの処理時間が
どのように変化するかを計測するためのプログラム．具体的には，優先度デー
タキュー中に高い優先度のデータがn個蓄積されている時に，snd_dtqにより低
い優先度のデータを入れるのにかかる時間を計測する．nを0，10，20，30，40，
50，100，200，300と変化させて計測する．

(4) perf3		set_flgの処理時間の評価

待ち解除するタスクの数により，set_flgの処理時間がどのように変化するかを
計測するためのプログラム．具体的には，TA_WMUL属性のイベントフラグに対し
て，n個のタスクが待っている時に，set_flgによりそのすべてを待ち解除する
のにかかる時間を計測する．nを0，1，2，3，4，5，10，20と変化させて計測す
る．

(5) perf4		act_tskの処理時間とタスク切換え時間の評価

act_tskの処理時間とタスク切換え時間を計測するためのプログラム．具体的に
は，(1) タスクコンテキストから呼び出し，タスク切換えを起こさない
act_tskの処理時間，(2) タスクコンテキストから呼び出し，タスク切換えを起
こすact_tskの処理時間（タスク切換え時間を含む），(3) 非タスクコンテキス
トから呼び出し，タスク切換えを起こすact_tskの処理時間（タスク切換え時間
とタイマ割込み中で実行されるシステム時刻の更新処理時間を含む）の3つの時
間を計測する．

(6) perf5		タイムイベント処理時間の評価

タイムイベントヒープ操作のオーバヘッドにより，sta_alm，stp_almの処理時
間がどのように変化するかを計測するためのプログラム．具体的には，タイム
イベントヒープ中でのノードの交換回数が，ない場合，少ない場合，多い場合
で，sta_almとstp_almの処理時間を計測する．

10.6 コンフィギュレータのテスト

test_cfgディレクトリに置かれたファイルは，コンフィギュレータのテストを
行うためのものである．

コンフィギュレータのテストは，ダミー（GNU開発環境）のターゲット依存部
を用い，TECSとシステムログ機能は使用しないことを想定して作成されている．
コンフィギュレータのテストを行う環境を作成するためには，まず次のコマン
ドを実行する（構築用のディレクトリが，ASP3カーネルのソースファイルを展
開したディレクトリの直下にあると仮定している）．

	% ruby ../configure.rb -T dummy_gcc -w -O "-DTOPPERS_OMIT_SYSLOG" \
					-a ../test_cfg -A <テストプログラム名>

この後に，ダミーターゲット依存部のビルドに用いる開発環境に対応するため
に，生成されたMakefileを変更する必要がある．例えば，ARM向けのGNU開発環
境を用いる場合には，Makefileに「GCC_TARGET = arm-none-eabi」の行を追加
し，CDEFSの定義に「-Dmain=_start」を追加する必要がある．

コンフィギュレータのテストは，4種類のものがある．以下では，そのそれぞ
れについて説明する．

10.6.1 ビルドに成功するテスト

テストプログラムをビルドすると，ビルドに成功し，実行形式のファイルが作
られるもの．ビルドにより作成されると期待されるカーネル構成・初期化ファ
イル（kernel_cfg.c）とカーネル構成・初期化ヘッダファイル（kernel_cfg.h）
がtest_cfgディレクトリにあるため，生成されたファイルがこれらのファイル
と一致することで，コンフィギュレータのテストに成功したとみなす．

現バージョンで用意しているこの種類のテストは次の通り．

(1) cfg_all1		全静的APIのテスト(1)

10.6.2 コンフィギュレータのパス3でエラーになるテスト

テストプログラムをビルドしようとすると，実行形式のファイルは作られるが，
コンフィギュレータのパス3がエラーを報告するもの．コンフィギュレータが
出力すると期待されるエラーメッセージを格納したファイルがtest_cfgディレ
クトリにあるため，出力されたエラーメッセージがこのファイルと一致するこ
とで，コンフィギュレータのテストに成功したとみなす．

現バージョンで用意しているこの種類のテストは次の通り．

(1) pass3_all1		全静的APIのパス3でのエラー検出のテスト(1)

10.6.3 コンフィギュレータのパス2でエラーになるテスト

テストプログラムをビルドしようとすると，コンフィギュレータのパス2がエ
ラーを報告し，実行形式のファイルが作られないもの．コンフィギュレータが
出力すると期待されるエラーメッセージを格納したファイルがtest_cfgディレ
クトリにあるため，出力されたエラーメッセージがこのファイルと一致するこ
とで，コンフィギュレータのテストに成功したとみなす．

現バージョンで用意しているこの種類のテストは次の通り．

(1) pass2_cfg1		コンフィギュレータ本体によるパス2でのエラー検出の
					テスト(1)
(2) pass2_int1		割込み関連の静的APIのパス2でのエラー検出のテスト(1)
(3) pass2_obj1		カーネルオブジェクト関連の静的APIのパス2でのエラー
					検出のテスト(1)
(4) pass2_obj2		カーネルオブジェクト関連の静的APIのパス2でのエラー
					検出のテスト(2)
(5) pass2_task1		タスク関連の静的APIのパス2でのエラー検出のテスト(1)

10.6.4 コンフィギュレータのパス1でエラーになるテスト

テストプログラムをビルドしようとすると，コンフィギュレータのパス1がエ
ラーを報告し，実行形式のファイルが作られないもの．コンフィギュレータが
出力すると期待されるエラーメッセージを格納したファイルがtest_cfgディレ
クトリにあるため，出力されたエラーメッセージがこのファイルと一致するこ
とで，コンフィギュレータのテストに成功したとみなす．

現バージョンで用意しているこの種類のテストは次の通り．

(1) pass1_cfg1		コンフィギュレータ本体によるパス1でのエラー検出の
					テスト(1)

10.7 テスト実行スクリプト

testディレクトリに置かれたランタイムテストの実行を自動化するために，ラ
ンタイムテストの実行スクリプト（testexec.rb）を用意している．また，コ
ンフィギュレータのテストの実行を自動化するために，コンフィギュレータテ
ストの実行スクリプト（testcfg.rb）を用意している．

10.7.1 ランタイムテストの実行スクリプトの基本的な使い方

ランタイムテストの実行スクリプトを用いてテストを行う場合には，テスト環
境を構築するためのテスト実行ディレクトリを用意する．テスト実行ディレク
トリの場所と名称は任意に決めてよい．

テスト実行スクリプトを実行する前に，テスト実行ディレクトリに，次の2つ
のファイルを置く必要がある．

	TARGET_RUN			ターゲット上でテストプログラム（実行ファイルの
						名称はasp）を実行するための記述

	TARGET_OPTIONS		テストプログラムをビルドする際に必要なコンフィ
						ギュレーションスクリプト（configure.rb）のオプ
						ションを記述する．必要なオプションが異なるテス
						トプログラムがあることから，このファイルの各行
						に1組のビルドオプションを記述する．各行のビルド
						オプションの意味については，後述する

テスト名を指定してテスト実行スクリプトを実行すると，テスト実行ディレク
トリの下に，テストプログラムをビルドするためのディレクトリが作成され，
テストプログラムのビルドと実行が行われる．テスト名を指定せずにテスト実
行スクリプトを実行すると，ディレクトリが作られているすべてのテストプロ
グラムに対して，再ビルドと実行が行われる．これにより，ディレクトリがな
い状態から開始して，徐々にビルド・実行するテストプログラムを増やしてい
くことができる．

テストプログラム毎にカーネルをビルドするのは無駄であるため，コンパイル
オプションが共通のテストプログラムは，同一のカーネルライブラリを使うこ
とができるようにしている．同一のカーネルライブラリを使うためには，あら
かじめカーネルライブラリをビルドしておく．具体的には，カーネル名を指定
してテスト実行スクリプトを実行すると，テスト実行ディレクトリの下に，カー
ネルライブラリをビルドするためのディレクトリが作成され，カーネルライブ
ラリがビルドされる．ここでカーネル名とは，TARGET_OPTIONSの最初の行に記
述されたビルドオプションでビルドしたカーネルはkernel0，2行目に記述され
たビルドオプションでビルドしたカーネルはkernel1，…のようになる．

なお，この方法でカーネルライブラリをビルドする場合，コンフィギュレーショ
ンスクリプトに-fオプションを与え，カーネルを関数単位でコンパイルしライ
ブラリ化する．

10.7.2 ランタイムテストの実行スクリプトの使用例

ここでは，ランタイムテストの実行スクリプトの使用例を紹介する．テスト実
行ディレクトリは，ASP3カーネルのソースファイルを展開したディレクトリの
直下に作ることを想定する．

	% mkdir TEST-EXEC
	% cd TEST-EXEC

ASP3カーネルを，CT11MPCore依存部を用いてコンパイルし，Qemuを用いて実行
する場合のTARGET_RUNとTARGET_OPTIONSは，以下のようになる．

TARGET_RUNの内容：
----------------------------------------
qemu-system-arm -M realview-eb-mpcore -semihosting -m 128M -nographic -kernel asp
----------------------------------------

TARGET_OPTIONSの内容：
----------------------------------------
-T ct11mpcore_gcc -O "-DTOPPERS_USE_QEMU"
-T ct11mpcore_gcc -O "-DNDEBUG -DTOPPERS_USE_QEMU"
-T simtimer_ct11mpcore_gcc -O "-DTOPPERS_USE_QEMU"
-T ct11mpcore_gcc -O "-DTOPPERS_USE_QEMU -DUSE_ARM_FPU_SELECTIVE" -o "-mfloat-abi=softfp" -b "-lm" APPL_CFLAGS="-mfpu=vfpv2"
----------------------------------------

まずは，kernel0（TARGET_OPTIONSの最初の行に記述されたビルドオプション
でビルドしたカーネル）をビルドする．

	% ../test/testexec.rb kernel0

これにより，KERNELLIB0ディレクトリが作られ，その下にカーネルライブラリ
（libkernel.a）が作られる．

次に，タスク管理モジュールのテスト(1)（task1）とセマフォ機能のテスト
(1)（sem1）をビルドし，実行する．

	% ../test/testexec.rb task1 sem1

これにより，OBJ-TASK1ディレクトリとOBJ-SEM1ディレクトリが作られ，それ
らの下にテストプログラムがビルドされ，実行される．

この後は，testexec.rbをパラメータ無しで実行することで，kernel0，task1，
sem1が再ビルドされ，task1とsem1が実行される．

10.7.3 ランタイムテストの実行スクリプトの進んだ使い方

テスト実行スクリプトには，パラメータとして，処理内容と処理対象を指定す
ることができる．

処理内容には，以下のいずれかを指定する．

	build		テストプログラムをビルドする
	exec		テストプログラムを実行する
	clean		テストプログラムのクリーン処理を行う

処理内容の記述を省略した場合には，テストプログラムのビルドと実行が行わ
れる．

処理対象には，以下のリストを指定する．

	kernel			ディレクトリが作られているすべてのカーネル
	kernel<数字>	指定したカーネル
	all				ディレクトリが作られているすべてのテストプログラム
	<テスト名>		指定したテストプログラム

処理対象の記述を省略した場合には，"kernel"と"all"を指定したものと見な
される．

ASP3カーネルのランタイムテストの実行スクリプトを使用する場合，
TARGET_OPTIONSの各行には，次のビルドオプションを記述する．

	1行目	kernel0		機能テストプログラム
	2行目	kernel1		性能評価プログラム
	3行目	kernel2		タイマドライバシミュレータを用いたテストプログラム
	4行目	kernel3		FPUを使用するテストプログラム（ARM向け）

10.7.4 コンフィギュレータテストの実行スクリプトの使い方

コンフィギュレータテストの実行スクリプトの使い方は，ランタイムテストの
実行スクリプトとほぼ同様であるが，以下の点が異なる．

コンフィギュレータテストは実行しないため，TARGET_RUNファイルは必要ない．
実行スクリプトの処理内容にexecを指定した場合（処理内容の記述を省略した
場合も含む），テストプログラムを実行することに代えて，コンフィギュレー
ション結果を用意してある期待値と比較する．具体的には，ビルドに成功する
テストについては，生成されたファイル（kernel_cfg.h，kernel_cfg.c）を期
待値と比較し，コンフィギュレータでエラーになるテストについては，出力さ
れるエラーメッセージを期待値と比較する．

コンフィギュレーション結果が期待値と一致しない場合，テスト実行スクリプ
トは，期待値をコンフィギュレーション結果に一致させるためのコピーコマン
ドを出力する（出力するだけで，実行はしない）．テスト実行スクリプトに-c
オプションを与えると，コピーコマンドが実行され，期待値をコンフィギュレー
ション結果に一致させる．

ASP3カーネルのコンフィギュレータテストの実行スクリプトを使用する場合，
TARGET_OPTIONSの各行には，次のビルドオプションを記述する．

	1行目	kernel0		一般的なテストプログラム


１１．使用上の注意とヒント

11.1 実行時間と割込み禁止時間に関する注意事項

ASP3カーネルの各サービスコールは，可能な限り，最大実行時間が一定値とな
るように実装しているが，そのように実装できない状況があり，最大実行時間
が何らかのパラメータに依存する場合がある．またASP3カーネルでは，カーネ
ルの処理のほぼ全体をカーネル管理の割込みを禁止した状態（CPUロック状態と
同等）で実行するため，そのような場合には，最大割込み禁止時間も何らかの
パラメータに依存することになる．

以下では，サービスコールの実行時間および割込み禁止時間が，何らかのパラ
メータに依存する場合について説明する．

(1) set_flgにより複数のタスクが待ち解除される場合

TA_WMUL属性であり，TA_CLR属性でないイベントフラグに対するset_flgにより，
複数のタスクが待ち解除される場合がある．この場合，サービスコールの実行
時間およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数の数
のオーダで長くなる．この実行時間の伸びを計測するために，性能評価プログ
ラムperf3を用意している．

また，TA_WMUL属性のイベントフラグに対するset_flgの実行時間およびカーネ
ル内での割込み禁止時間は，対象イベントフラグ待ち状態のタスク（待ち解除
されないタスクも含む）の数のオーダでも長くなるが，これによる実行時間お
よび割込み禁止時間の変化はわずかであり，実際の影響は小さい．

(2) ini_yyyにより複数のタスクが待ち解除される場合

対象オブジェクト待ち状態のタスクが複数あると，ini_yyyにより，複数のタス
クが待ち解除される．この場合，サービスコールの実行時間およびカーネル内
での割込み禁止時間が，待ち解除されるタスクの数のオーダで長くなる．

(3) タスク優先度順の待ち行列にタスクが挿入される場合

待ち行列がタスクの優先度順になっている同期・通信オブジェクトに対して，
タスクが待ち状態になる場合，サービスコールの実行時間およびカーネル内で
の割込み禁止時間が，すでに待っているタスク（の中で新たに待ち状態になる
タスクより優先度が高いか同じもの）の数のオーダで長くなる．ただし，これ
による実行時間および割込み禁止時間の変化はわずかであり，実際の影響は小
さい．

(4) 優先度データキューにデータを送信する場合

優先度データキューに対してデータを送信する場合，サービスコールの実行時
間およびカーネル内での割込み禁止時間が，すでに優先度データキュー管理領
域に格納されているデータ（の中で新たに送信されたデータより優先度が高い
か同じもの）の数のオーダで長くなる．ただし，これによる実行時間および割
込み禁止時間の変化はわずかであり，実際の影響は小さい．この実行時間の伸
びを計測するために，性能評価プログラムperf2を用意している．

(5) タイムイベント処理時間

タイムイベントを登録または登録解除する場合，サービスコールの実行時間お
よびカーネル内での割込み禁止時間が，すでに登録されているタイムイベント
の対数オーダで長くなる．また，高分解能タイマ割込みの実行時間およびその
中での割込み禁止時間も，同様に長くなる．ただし，時間の伸びが対数オーダ
であることから，実際の影響は限られている．この実行時間の伸びを計測する
ために，性能評価プログラムperf5を用意している．

11.2 assertマクロの処理

ASP3カーネルのコード中には，assertマクロが使われている．assertマクロの
定義はt_stddef.hに含まれ，assertが失敗した場合の最後の処理（通常は，プ
ログラムを停止させる処理）は，ターゲット依存部のTOPPERS_assert_abortで
決定される．

assertが失敗した場合，システム開発中はデバッガに落とすのが望ましいが，
システム稼働時の対処法は，システムに対する要件に依存する．そこで，ター
ゲット依存部のTOPPERS_assert_abortを，システム要件に合致した適切な処理
に置き換える必要がある．システム要件によっては，NDEBUGをマクロ定義して
assertマクロの処理をオブジェクトコード中から消す（「6.2 コンパイルオプ
ション」の節を参照）方法も考えられる．

11.3 システムログ機能の扱い

ASP3カーネルでは，システム開発時の利便性を考慮し，システムログ機能を組
み込む設定をデフォルトとしている．

それに対して，ASP3カーネルを用いたシステムを機器に組み込む場合は，シス
テムログ機能が意味がない場合も多い．機器への組込みに際してのシステムロ
グ機能の設定方法には，以下の方法が考えられる．

(1) システムログ機能を用いない

システムログ機能を一切使用しない場合には，システムログ機能をシステムに
組み込まず，システムログ機能のサービスコールを呼び出すソースファイルを
TOPPERS_OMIT_SYSLOGを定義してコンパイルすればよい．詳しくは，「8.1.8 シ
ステムログ機能の組込みと取外し」の節を参照すること．

(2) ログ情報の蓄積のみを行う

機器に組み込んだ状態で，シリアルポート等を介してシステムを外部と接続す
ることができる場合には，システム稼働時にはログ情報の蓄積のみを行い，シ
ステムに障害が起きた時などにログ情報を取り出すことで，障害の原因分析の
助けとすることができる．

具体的な設定方法として，次の2つの方法が考えられる．

(2-1) 低レベル出力をメモリに蓄積する

必要なログ情報を低レベル出力機能を用いて出力するように設定し，低レベル
の文字出力関数に送られた文字をメモリ（典型的にはリングバッファ）に蓄積
するようにする．システムの障害時には，そのメモリ領域を読み出す．ターゲッ
ト依存部の低レベル出力の変更が必要である．

(2-2) システムログ機能のログバッファに蓄積する

必要なログ情報をシステムログ機能のログバッファに記録するように設定する．
システムログタスクを動作させないと，ログ情報はログバッファに蓄積されて
いく．システムの障害時には，ログバッファの領域を読み出すか，システムロ
グタスクを動作させてログ情報を出力させる．

(3) 開発時の設定のままとする

システムログ機能の設定を，システム開発時のまま変更せず，シリアルポート
等にログ情報を垂れ流す方法も考えられる．

11.4 オブジェクトIDの管理

ASP3カーネルでは，オブジェクトのID番号を，コンフィギュレータが割り付け
る方法が基本となっている．

アプリケーションプログラム中でオブジェクトのID番号を参照する場合には，
次の2つの方法が考えられる．

(1) オブジェクト識別名を用いる

オブジェクト生成のための静的API（CRE_YYY）の第1パラメータに記述したオブ
ジェクト識別名を，アプリケーションプログラム中でも用いる方法．

コンフィギュレータは，オブジェクト識別名を，割り付けたID番号にマクロ定
義するC言語プリプロセッサのディレクティブ（#define）をkernel_cfg.hに生
成するため，アプリケーションプログラムからkernel_cfg.hをインクルードす
る必要がある．

この方法は，オブジェクトコード中にID番号が直接埋め込まれるために実行効
率が良い一方で，システムコンフィギュレーションファイルが変更されて
kernel_cfg.hが書き換わる度に，アプリケーションプログラムの再コンパイル
が必要になるという欠点がある．そのため，アプリケーションプログラムを構
成するファイルの中で，一部のファイルのみでオブジェクト識別名を参照する
構成にするといった工夫をすることが望ましい．

(2) オブジェクトのID番号を保持する変数を用いる

オブジェクトのID番号を保持するconst属性を付加した変数を用意し，アプリケー
ションプログラム中では，その変数を用いる方法．

例えば，TASK1というオブジェクト識別名のタスクに対して，次のような変数を
用意する．

const ID TASK1_id = TASK1;

アプリケーションプログラム中では，この変数（TASK1_id）を用いることで，
システムコンフィギュレーションファイルが変更されてkernel_cfg.hが書き換
わった時にも，上記の変数定義を含んだファイルのみを再コンパイルすればよ
いことになる．

この方法は，アプリケーションプログラムの再コンパイルを最小限にできる利
点がある一方で，変数のためのメモリ領域が必要になることに加えて，（プロ
セッサによっては）変数アクセスのためのオーバヘッドが生じるという欠点が
ある．また，定数ではなく変数であることから，他の変数の初期化には使えな
いという制限がある．

なお，ASP3カーネルのコンフィギュレータは，コンパイルオプションに
-DUSE_EXTERNAL_IDを指定することにより，上記の変数定義をkernel_cfg.c中に
生成する機能を持っているので，すべてのオブジェクトIDをこの方法で参照す
る場合には，この機能を用いることを推奨する．

コンフィギュレータによるID番号割付けのもう1つの課題として，システムコン
フィギュレーションファイルの修正により，オブジェクトIDの割付けが変わっ
てしまうことが挙げられる．これは，アプリケーションソフトウェアの設計仕
様書にID番号が記載されている場合や，デバッグ作業においてID番号を直接扱っ
ている場合に，作業効率を低下させる可能性が考えられる．

この問題に対応するために，ASP3カーネルのコンフィギュレータに，ID番号の
割付け結果をファイルに書き出す機能（--id-output-fileオプション）と，ID
番号の割付けをファイルから取り込む機能（--id-input-fileオプション）を用
意している．これらの機能を用いて，コンフィギュレータを実行する度に，前
回に実行した時にファイルに書き出したID番号の割付けを取り込むことで，前
回実行時と同じ割付けを行うことができる．ただし，ASP3カーネルでは，ID番
号に抜けがあるのは許されないため，オブジェクトの数が減った場合には（ID
番号が大きい方のオブジェクトが減った場合を除いて）エラーとなる．この場
合には，ダミーのオブジェクトを生成する方法で回避するしかない．

11.5 カーネルの内部シンボルのリネーム

ASP3カーネルでは，モジュール内部の名称が他のモジュール内部の名称と衝突
することを避けるために，カーネルの内部シンボルは，C言語レベルで，先頭が
"_kernel_"または"_KERNEL_"である名称としている．

これをソースコードの可読性と両立させるために，ASP3カーネルでは，ソース
コードは自然な名前を用いて記述し，C言語プリプロセッサのマクロ定義
（#define）を用いて，それを"_kernel_"または"_KERNEL_"で始まる名前（自然
な名前がyyyの場合には，_kernel_yyy）にリネームする仕組みを用いている．

具体的には，関連するディレクトリにxxx_rename.defを置き，そこからリネー
ムのためのヘッダファイル（xxx_rename.hおよびxxx_unrename.h）を生成する
ツール（utils/genrename.rb）を用意している．

この仕組みは，ソースコードの可読性向上に役立つ一方で，弊害もある．例え
ば，多くのデバッガで，ソースコード中の名称とオブジェクトコード中の名称
が異なるために，ソースコード中の変数名を指定して値を読んだり，関数名を
指定してブレークポイントを置くといったことができない．

この状況に対応するために，ASP3カーネルでは，ソースコード中の該当する名
称をリネームするためのユーティリティ（utils/applyrename.rb）を用意して
いる．このユーティリティに，リネーム定義ファイル（xxx_rename.def）のプ
リフィックス（xxxの部分）と，リネームしたいファイルリストを与えると，リ
ネーム処理を行なう．例えば，kernelディレクトリのすべてのファイルに対し
て，カーネルの内部シンボルをリネームするには，次のコマンドを実行すれば
よい．

	% cd kernel
	% ruby ../utils/applyrename.rb kernel *

また，ターゲット依存部のディレクトリのすべてのファイルに対して，カーネ
ルの内部シンボルをリネームするには，次のようなコマンドを実行すればよい．

	% cd target/ct11mpcore_gcc/
	% ruby ../../utils/applyrename.rb target *
	% ruby ../../utils/applyrename.rb ../../kernel/kernel *

11.6 トレースログ記録のサンプルコードの使用方法

ターゲット依存部が，トレースログ記録に対応している場合には，コンフィギュ
レーションスクリプトにトレースログ記録のサンプルコードを使用することを
指示するオプション（-r）を付加し，コンポーネント記述ファイルに以下の記
述を含めることで，メモリ上にトレースログを記録する機能が有効になる．

----------------------------------------
/*
 *  トレースログ機能の組上げ記述
 */
import("arch/tracelog/tTraceLog.cdl");

cell tTraceLog TraceLog {
	logBufferSize = 1024;				/* ログバッファのサイズ */
	initialMode = C_EXP("TRACE_RINGBUF");

	/* トレースログのダンプ先を低レベル出力に結合 */
	cPutLog = PutLogTarget.ePutLog;
};
----------------------------------------

この記述中のlogBufferSizeの値を変更することで，トレースログ機能のログ
バッファのサイズを変更することができる．

initialModeには，以下のいずれかの動作モードを指定することができる．

	TRACE_STOP			トレース停止
	TRACE_RINGBUF		リングバッファモード（ログバッファをリングバッ
						ファとして使用する）
	TRACE_AUTOSTOP		自動停止モード（ログバッファがフルになれば，ト
						レースを停止する）

また，システム終了時に，記録したトレースログをダンプするためには，コン
ポーネント記述ファイル次の記述を追加する（トレースログを別の方法で取り
出す場合には，この記述は不要）．

----------------------------------------
cell tTerminateRoutine TraceLogTerminate {
	cTerminateRoutineBody = TraceLog.eDump;
};
----------------------------------------

この方法では，トレースログのダンプを終了処理ルーチンで行っているため，
終了処理ルーチンを呼び出した後のトレースログは出力されない．これ以外の
タイミングでトレースログのダンプを行いたい場合には，trace_dump関数を明
示的に呼び出す必要がある。

11.7 システムの起動時の初期化処理

システムの起動時にアプリケーションで必要となる初期化処理を行うための機
能として初期化ルーチンが用意されているが，初期化ルーチンが実行されるよ
りも早いタイミングで実行することが必要な初期化処理がある場合がある．

このような場合に用いるために，標準的なスタートアップモジュールから，ター
ゲットシステム依存の初期化フック（hardware_init_hook）を呼び出すことと
している．hardware_init_hookは，カーネルのターゲット依存部で用意されて
いるのが標準であるが，これをアプリケーションで用意したものに置き換え，
その中でアプリケーションで必要となる初期化処理を行うことができる．

ただし，hardware_init_hookの作成する場合には，bssセクションとdataセクショ
ンが初期化されていないことや，ライブラリが初期化されていないこと，C言語
で記述できるとは限らないことなどに注意が必要である．作成にあたっては，
「ターゲット依存部 ポーティングガイド」を参照すること．

カーネルのスタートアップモジュールがhardware_init_hookを呼び出すように
実装されていない場合には，スタートアップモジュールをアプリケーションで
用意したものに置き換える方法を推奨する．

11.8 rodataセクションをRAMに置く場合

何らかの理由でrodataセクションをRAMに置く場合，dataセクションと同様に，
その初期値はROMに置き，スタートアップモジュールでRAMにコピーするのが素
直である．これを実現するには，dataセクションの取扱いを参考に，リンカス
クリプトとスタートアップモジュールを修正する必要があるが，それに加えて，
以下の措置が必要である．

コンフィギュレータは，パス1とパス3において，ロードモジュールのシンボル
ファイルを用いて，ロードモジュール内のrodataセクションを読み込むことで，
各種の定数値を取得する．そのため，rodataセクションをdataセクションと同
様に扱うと，そのアクセスアドレス（RAM内のアドレス，VMAと呼ぶ）と配置ア
ドレス（ROM内のアドレス，LMAと呼ぶ）が一致しなくなるために，定数値を取
得することができず，エラーとなる．

パス1でのエラーを回避するためには，パス1のリンク時（cfg1_outをリンクす
る時）には，rodataセクションのアクセスアドレスと配置アドレスを一致させ
るリンカスクリプト（標準のリンカスクリプトはこのようになっている）を用
いる．標準のMakefileでは，LDSCRIPTによりリンカスクリプトを指定するので
はなく，LDFLAGSとCFG1_OUT_LDFLAGSに異なるリンカスクリプトを用いるオプショ
ンを設定すればよい．

パス3でのエラーを回避するためには，コンフィギュレータのパス3の生成スク
リプトにおいて，rodataセクションの内容を，配置アドレスからアクセスアド
レスにコピーする．そのためには，パス3の生成スクリプトのターゲット依存部
で，$lmaListを設定すればよい．具体的な方法は，「ターゲット依存部 ポーティ
ングガイド」を参照すること．

11.9 カーネルからのシステムログ出力

カーネルからシステムログに出力されるメッセージと，出力される状況は以下
の通りである．

(1) no time event is processed in hrt interrupt.

高分解能タイマ割込みが発生したが，処理すべきタイムイベントがなかった場
合に，このメッセージが出力される．このメッセージが出力される状況は，以
下の場合に起こる．

　・タイムイベントが1つも設定されていない状態が長時間続き，システム時
	刻を更新するだけのために高分解能タイマ割込みが発生した場合

　・高分解能タイマ割込みが要求され，それが受け付けられる前に，処理すべ
	きタイムイベントがキャンセルされた場合（より具体的には，タイムアウ
	ト待ち状態のタスクが待ち解除された場合や，周期通知が動作停止された
	場合など）

このような場合が起こるよりも高い頻度でこのメッセージが出力される場合に
は，高分解能タイマドライバの不具合の可能性が疑われる．


１２．参考情報

12.1 利用条件と利用報告

ASP3カーネルの利用条件は，各ファイルの先頭に表示されている．著作権は，
各ファイルの先頭に表示されている著作権者が保有している．

利用条件の(3)の(b)において，利用の形態をTOPPERSプロジェクトに報告する方
法としては，ASP3カーネルを利用した製品の名称と応用分野，製品化した会社
名と業種等の情報を，以下のURLのページから報告するものとする．

	http://www.toppers.jp/report.html

またその際に，ASP3カーネルを使用してのコメントやご意見もいただけると幸
いである．

12.2 保証・適用性・サポート

ASP3カーネルは無保証で提供されているものである．開発者およびTOPPERSプロ
ジェクトは，ASP3カーネルに関して，特定の使用目的に対する適合性も含めて，
いかなる保証も行わない．また，ASP3カーネルの利用により直接的または間接
的に生じたいかなる損害に関しても，その責任を負わない．

開発者およびTOPPERSプロジェクトは，ASP3カーネルに関するサポートの約束は
していない．ASP3カーネルに関して質問がある場合は，後述のTOPPERSユーザー
ズメーリングリストを利用していただけると幸いである．確実なサポートが必
要な場合には，有償でサポートサービスを提供している会社に相談されたい．

12.3 バグレポート

ASP3カーネルにバグや問題点を発見された場合には，後述のTOPPERSユーザーズ
メーリングリストに報告して欲しい．

メーリングリストにバグや問題点などを報告する場合には，必要に応じて次の
情報を知らせて欲しい．

	使用しているカーネルに関する情報
		・ターゲット非依存部のバージョン
		・使用しているターゲット依存部とそのバージョン
		・TOPPERSプロジェクトからのリリースに対する改造箇所（あれば）

	ターゲットシステムに関する情報
		・ターゲットプロセッサの種類
		・ターゲットボード等の種類

	ホストに関する情報
		・OSのバージョン（サービスパックの適用状況も）
		・コンパイラなどの開発環境のバージョン（Cygwinのバージョンも）

12.4 ウェブサイト

TOPPERSプロジェクトのウェブサイトは，以下のURLにある．

	http://www.toppers.jp/

TOPPERSプロジェクトやASP3カーネルに関する最新情報は，このウェブサイトか
ら得ることができる．また，ASP3カーネルの最新版は，このウェブサイトから
ダウンロードすることができる．

12.5 TOPPERSユーザーズメーリングリスト

ASP3カーネルを含むTOPPERSプロジェクトの開発成果物のユーザに対する情報提
供およびユーザ相互間の情報交換を容易にするために，TOPPERSユーザーズメー
リングリスト（users@toppers.jp）を用意している．

このメーリングリストには，誰でも自由に登録し，メールを送付することがで
きる（登録者以外はメールを送付できない）．また，送付されたメールは，誰
でも自由にウェブサイトで読むことができる．そのため，公開すべきでない情
報（個人情報など）をメール中に含めないように注意すること．

メーリングリストへの登録方法については，以下のURLのページに説明がある．

	http://www.toppers.jp/community.html

12.6 TOPPERSプロジェクトのメンバ向けのサービス

TOPPERSプロジェクトのメンバに対しては，上記に加えて，ASP3カーネルに関連
して次のサービスを用意している．

(1) TOPPERS開発者メーリングリスト

TOPPERSプロジェクトのメンバは，ASP3カーネルに関する質問，バグや問題点な
どの報告に，TOPPERS開発者メーリングリスト（dev@toppers.jp）を利用するこ
とができる．

(2) ASP3カーネルの開発支援サイト

ASP3カーネルの開発支援のためのTRAC（バグトラッキングシステム）が，以下
のURLにある（TRACへのアクセスには，会員パスワードが必要である）．

	http://dev.toppers.jp/trac/asp3/

TOPPERSプロジェクトのメンバは，このサイトから，ウェブインタフェースおよ
びsubversionサーバにより，ASP3カーネルの開発中のバージョンを得ることが
できる．また，バグトラッキングデータベースにアクセスすることができ，過
去のバグ履歴へのアクセスや，バグの登録をすることができる．

12.7 TOPPERSプロジェクトへの参加

TOPPERSプロジェクトでは，何からの形でプロジェクトに貢献していただける方，
プロジェクトで開発したソフトウェアをお使いの方，プロジェクトに興味をお
持ちの方の参加を求めている．TOPPERSプロジェクトへの参加方法については，
以下のページに説明がある．

	http://www.toppers.jp/joinus.html


１３．リファレンス

13.1 サービスコール一覧

(1) タスク管理機能

	ER ercd = act_tsk(ID tskid)
	ER_UINT	actcnt = can_act(ID tskid)
	ER ercd = get_tst(ID tskid, STAT *p_tskstat)
	ER ercd = chg_pri(ID tskid, PRI tskpri)
	ER ercd = get_pri(ID tskid, PRI *p_tskpri)
	ER ercd = get_inf(EXINF *p_exinf)
	ER ercd = ref_tsk(ID tskid, T_RTSK *pk_rtsk)

(2) タスク付属同期機能

	ER ercd = slp_tsk(void)
	ER ercd = tslp_tsk(TMO tmout)
	ER ercd = wup_tsk(ID tskid)
	ER_UINT wupcnt = can_wup(ID tskid)
	ER ercd = rel_wai(ID tskid)
	ER ercd = sus_tsk(ID tskid)
	ER ercd = rsm_tsk(ID tskid)
	ER ercd = dly_tsk(RELTIM dlytim)

(3) タスク終了機能

	ER ercd = ext_tsk(void)
	ER ercd = ras_ter(ID tskid)
	ER ercd = dis_ter(void)
	ER ercd = ena_ter(void)
	bool_t state = sns_ter(void)
	ER ercd = ter_tsk(ID tskid)

(4) 同期・通信機能

	ER ercd = sig_sem(ID semid)
	ER ercd = wai_sem(ID semid)
	ER ercd = pol_sem(ID semid)
	ER ercd = twai_sem(ID semid, TMO tmout)
	ER ercd = ini_sem(ID semid)
	ER ercd = ref_sem(ID semid, T_RSEM *pk_rsem)

	ER ercd = set_flg(ID flgid, FLGPTN setptn)
	ER ercd = clr_flg(ID flgid, FLGPTN clrptn)
	ER ercd = wai_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = pol_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = twai_flg(ID flgid, FLGPTN waiptn,
						MODE wfmode, FLGPTN *p_flgptn, TMO tmout)
	ER ercd = ini_flg(ID flgid)
	ER ercd = ref_flg(ID flgid, T_RFLG *pk_rflg)

	ER ercd = snd_dtq(ID dtqid, intptr_t data)
	ER ercd = psnd_dtq(ID dtqid, intptr_t data)
	ER ercd = tsnd_dtq(ID dtqid, intptr_t data, TMO tmout)
	ER ercd = fsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = rcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = prcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = trcv_dtq(ID dtqid, intptr_t *p_data, TMO tmout)
	ER ercd = ini_dtq(ID dtqid)
	ER ercd = ref_dtq(ID dtqid, T_RDTQ *pk_rdtq)

	ER ercd = snd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = psnd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = tsnd_pdq(ID pdqid, intptr_t data, PRI datapri, TMO tmout)
	ER ercd = rcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = prcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = trcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri, TMO tmout)
	ER ercd = ini_pdq(ID pdqid)
	ER ercd = ref_pdq(ID pdqid, T_RPDQ *pk_rpdq)

	ER ercd = loc_mtx(ID mtxid)
	ER ercd = ploc_mtx(ID mtxid)
	ER ercd = tloc_mtx(ID mtxid, TMO tmout) 
	ER ercd = unl_mtx(ID mtxid)
	ER ercd = ini_mtx(ID mtxid)
	ER ercd = ref_mtx(ID mtxid, T_RMTX *pk_rmtx)

(5) メモリプール管理機能

	ER ercd = get_mpf(ID mpfid, void **p_blk)
	ER ercd = pget_mpf(ID mpfid, void **p_blk)
	ER ercd = tget_mpf(ID mpfid, void **p_blk, TMO tmout)
	ER ercd = rel_mpf(ID mpfid, void *blk)
	ER ercd = ini_mpf(ID mpfid)
	ER ercd = ref_mpf(ID mpfid, T_RMPF *pk_rmpf)

(6) 時間管理機能

	ER ercd = set_tim(SYSTIM systim)
	ER ercd = get_tim(SYSTIM *p_systim)
	ER ercd = adj_tim(int32_t adjtim)
	HRTCNT hrtcnt = fch_hrt(void)

	ER ercd = sta_cyc(ID cycid)
	ER ercd = stp_cyc(ID cycid)
	ER ercd = ref_cyc(ID cycid, T_RCYC *pk_rcyc)

	ER ercd = sta_alm(ID almid, RELTIM almtim)
	ER ercd = stp_alm(ID almid)
	ER ercd = ref_alm(ID almid, T_RALM *pk_ralm)

(7) システム状態管理機能

	ER ercd = rot_rdq(PRI tskpri)
	ER ercd = get_tid(ID *p_tskid)
	ER ercd = get_lod(PRI tskpri, uint_t *p_load)
	ER ercd = get_nth(PRI tskpri, uint_t nth, ID *p_tskid)
	ER ercd = loc_cpu(void)
	ER ercd = unl_cpu(void)
	ER ercd = dis_dsp(void)
	ER ercd = ena_dsp(void)
	bool_t state = sns_ctx(void)
	bool_t state = sns_loc(void)
	bool_t state = sns_dsp(void)
	bool_t state = sns_dpn(void)
	bool_t state = sns_ker(void)
	ER ercd = ext_ker(void)

(8) 割込み管理機能

	ER ercd = dis_int(INTNO intno)
	ER ercd = ena_int(INTNO intno)
	ER ercd = clr_int(INTNO intno)
	ER ercd = ras_int(INTNO intno)
	ER_BOOL state = prb_int(INTNO intno)
	ER ercd = chg_ipm(PRI intpri)
	ER ercd = get_ipm(PRI *p_intpri)

(9) CPU例外管理機能

	bool_t stat = xsns_dpn(void *p_excinf)

13.2 静的API一覧

(1) タスク管理機能

	CRE_TSK(ID tskid, { ATR tskatr, EXINF exinf, TASK task,
								PRI itskpri, size_t stksz, STK_T *stk })

(4) 同期・通信機能

	CRE_SEM(ID semid, { ATR sematr, uint_t isemcnt, uint_t maxsem })
	CRE_FLG(ID flgid, { ATR flgatr, FLGPTN iflgptn })
	CRE_DTQ(ID dtqid, { ATR dtqatr, uint_t dtqcnt, void *dtqmb })
	CRE_PDQ(ID pdqid, { ATR pdqatr, uint_t pdqcnt, PRI maxdpri, void *pdqmb })
	CRE_MTX(ID mtxid, { ATR mtxatr, PRI ceilpri })

(5) メモリプール管理機能

	CRE_MPF(ID mpfid, { ATR mpfatr, uint_t blkcnt, uint_t blksz,
										MPF_T *mpf, void *mpfmb })

(6) 時間管理機能

	CRE_CYC(ID cycid, { ATR cycatr, ＜通知方法の指定＞,
										RELTIM cyctim, RELTIM cycphs })
	CRE_ALM(ID almid, { ATR almatr, ＜通知方法の指定＞ })

(8) 割込み管理機能

	CFG_INT(INTNO intno, { ATR intatr, PRI intpri })
	CRE_ISR(ID isrid, { ATR isratr, EXINF exinf,
								INTNO intno, ISR isr, PRI isrpri })
	DEF_INH(INHNO inhno, { ATR inhatr, INTHDR inthdr })

(9) CPU例外管理機能

	DEF_EXC(EXCNO excno, { ATR excatr, EXCHDR exchdr })

(10) システム構成管理機能

	DEF_ICS({ size_t istksz, STK_T *istk })
	ATT_INI({ ATR iniatr, EXINF exinf, INIRTN inirtn })
	ATT_TER({ ATR teratr, EXINF exinf, TERRTN terrtn })

13.3 バージョン履歴

	2014年11月24日	Release 3.A.0		最初の早期リリース（α版）
	2015年8月5日	Release	3.B.0
	2016年2月8日	Release	3.0.0		最初の一般公開
	2016年2月14日	Release	3.0.1
	2016年5月15日	Release	3.1.0
	2017年7月21日	Release	3.2.0
	2018年4月19日	Release	3.3.0
	2018年5月2日	Release	3.3.1
	2019年3月20日	Release	3.4.0
	2019年10月6日	Release	3.5.0
	2020年12月23日	Release	3.6.0
	2023年3月14日	Release	3.7.0

以上
