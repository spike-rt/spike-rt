
		TOPPERS/ASP3カーネル
		ターゲット依存部 ポーティングガイド

		対応バージョン: Release 3.7.0
		最終更新: 2022年12月17日

このドキュメントは，TOPPERS/ASP3カーネルを，未サポートのターゲットシス
テムにポーティングするために必要となるターゲット依存部の実装方法を説明
するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2022 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．

 $Id: porting.txt 1752 2022-12-17 03:47:55Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．共通事項
	1.1 ターゲット依存部の構成
		1.1.1 ターゲット略称とターゲット依存部ディレクトリ
		1.1.2 開発環境依存部ディレクトリ
		1.1.3 プロセッサコア依存部ディレクトリ
		1.1.4 チップ依存部ディレクトリ
	1.2 名前の衝突の防止
	1.3 ヘッダファイルの記述ルール
		1.3.1 ヘッダファイルの自己完結
		1.3.2 多重インクルードへの対応
		1.3.3 アセンブリ言語とのヘッダファイルの共用
	1.4 インクルード記述の方法
	1.5 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境のターゲット依存部
	2.1 システム略称・開発環境略称等の設定
	2.2 依存部ディレクトリの設定
	2.3 コマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 オフセットファイルの生成方法
	2.6 リンク方法の設定
	2.7 依存関係の定義（オプション）
	2.8 その他の設定
３．TOPPERS共通定義のターゲット依存部
	3.1 ターゲット識別マクロ
	3.2 整数型の最大値・最小値・ビット数
	3.3 サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ
	3.4 サイズの指定された浮動小数点型，その最大値・最小値のマクロ
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
	3.7 アサーションのための定義
	3.8 その他の定義
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 全割込みロック状態の管理
	4.2 微少時間待ち
	4.3 プロセッサのエンディアン
	4.4 メモリ空間アクセス関数
	4.5 I/O空間アクセス関数
５．カーネルAPIのターゲット依存部
	5.1 ターゲット定義でサポートする機能
	5.2 割込み優先度の範囲
	5.3 高分解能タイマのタイマ周期とカウント値の進み幅
	5.4 メモリ領域確保のための型定義
	5.5 ビットパターンのビット数
	5.6 メモリ領域確保のためのマクロ
	5.7 オーバランハンドラ機能拡張のための定義（オプション）
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
	6.2 トレースログ機能への対応
	6.3 システム状態の管理
		6.3.1 全割込みロック状態の管理
		6.3.2 コンテキストの管理
		6.3.3 CPUロック状態の管理
	6.4 割込みに関連するシステム状態の管理
		6.4.1 割込み優先度マスクの管理
		6.4.2 割込み要求禁止フラグの管理
		6.4.3 割込み要求のクリア
		6.4.4 割込み要求のプローブ
	6.5 タスクディスパッチャ
		6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		6.5.2 ディスパッチャ本体
		6.5.3 自発的なディスパッチ
		6.5.4 ディスパッチャの動作開始
		6.5.5 現在のコンテキストを捨ててディスパッチ
		6.5.6 タスクの起動準備
	6.6 割込みハンドラ
		6.6.1 割込みハンドラの出入口処理
		6.6.2 割込みハンドラ毎の出入口処理の生成
		6.6.3 割込みハンドラの設定
		6.6.4 割込み要求ラインの属性の設定
		6.6.5 割込み管理機能の初期化処理の変更
		6.6.6 デフォルトの割込みハンドラ
		6.6.7 カーネル管理外の割込み
		6.6.8 割込みサービスルーチンの生成
	6.7 CPU例外ハンドラとCPU例外発生時のシステム状態の参照
		6.7.1 CPU例外ハンドラの出入口処理
		6.7.2 CPU例外ハンドラの出入口処理の生成
		6.7.3 CPU例外ハンドラの設定
		6.7.4 CPU例外管理機能の初期化処理の変更
		6.7.5 デフォルトのCPU例外ハンドラ
		6.7.6 CPU例外発生時のシステム状態の参照
	6.8 カーネルの起動・終了
	6.9 カーネル内部のチューニング
		6.9.1 ビットマップサーチ
		6.9.2 ビットフィールド
	6.10 カーネル実装に関するその他の定義
		6.10.1 オブジェクト属性の拡張
		6.10.2 エラーチェック方法の指定
		6.10.3 非タスクコンテキスト用のスタック領域
		6.10.4 空ラベルの定義
	6.11 トレースログ機能に関する設定
		6.11.1 取得できるトレースログの種類とマクロ
		6.11.2 トレースログ記録のサンプルコード
	6.12 カーネル実装のターゲット依存部のためのリネーム記述
	6.13 高分解能タイマドライバ
		6.13.1 高分解能タイマドライバのファイル構成
		6.13.2 高分解能タイマの操作と割込み処理
		6.13.3 2つのタイマを用いた高分解能タイマドライバの実装
		6.13.4 高分解能タイマの現在値とタイマ周期
		6.13.5 タイムティックを用いたタイマドライバの実装
	6.14 オーバランタイマドライバ（オプション）
		6.14.1 オーバランタイマドライバのファイル構成
		6.14.2 オーバランタイマの操作と割込み処理
	6.15 動的メモリ管理（オプション）
		6.15.1 TLSFを用いたメモリプール管理機能の例
	6.16 カーネル実装のコンフィギュレーションファイル
７．コンフィギュレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2の生成スクリプトのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数
		7.2.2 ターゲット非依存部で定義される変数
	7.3 パス3の生成スクリプトのターゲット依存部
		7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数
		7.3.2 ターゲット依存部で行うべきエラーチェック
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムサービス等のターゲット依存部
	8.1 システムサービスの構成とターゲット依存部
	8.2 シリアルインタフェースドライバのターゲット依存部
		8.2.1 ターゲット依存部の実現形態
		8.2.2 ターゲット依存部の受け口（提供するサービス）
		8.2.3 ターゲット依存部の呼び口（コールバック）
	8.3 低レベル出力
		8.3.1 低レベル出力の実現形態
		8.3.2 低レベル出力の受け口（提供するサービス）
		8.3.3 SIOポートからの低レベル出力
	8.4 ターゲット依存部のコンポーネント記述ファイル
	8.5 システムサービスのターゲット依存定義
		8.5.1 システムログ機能の設定変更
		8.5.2 実行時間分布集計サービスの設定変更
		8.5.3 トレースログ記録のサンプルコードの設定変更
	8.6 サンプルプログラムとテストプログラムのターゲット依存定義
９．その他
	9.1 ドキュメント
	9.2 パッケージ記述ファイル
１０．リファレンス
	10.1 ターゲット依存部のファイル一覧


１．共通事項

1.1 ターゲット依存部の構成

ターゲット依存部は，targetディレクトリの下に，ターゲットハードウェアと
開発環境の組み合わせ毎に用意する．ただし，ターゲット依存部の再利用性を
考慮し，開発環境／プロセッサコア／チップのみに依存する部分を，開発環境
依存部／プロセッサコア依存部／チップ依存部という形で切り分けてもよい．
切り分け方は，ターゲット依存部の実装に任されている．開発環境依存部／プ
ロセッサコア依存部／チップ依存部は，archディレクトリの下に置く．

ASP3カーネルのターゲット依存部は，システム構築環境のターゲット依存部，
TOPPERS共通定義のターゲット依存部，システムインタフェースレイヤ（SIL）
のターゲット依存部，カーネルAPIのターゲット依存部，カーネル実装のターゲッ
ト依存部（コンフィギュレータ設定ファイルのターゲット依存部を含む），シ
ステムサービス等のターゲット依存部，ターゲット依存部に関するドキュメン
トで構成される．

1.1.1 ターゲット略称とターゲット依存部ディレクトリ

新しいターゲット依存部を作成する時は，まず，ターゲット略称を定める．ター
ゲット略称は，システム略称と開発環境略称を"_"で連結したものとする．シス
テム略称に用いる文字は英小文字と数字と"_"に，開発環境略称に用いる文字は
英小文字と数字に限定する．GNU開発環境の開発環境略称は，"gcc"とする．例
えば，システム略称が"ct11mpcore"で，GNU開発環境を用いる場合には，ターゲッ
ト略称は"ct11mpcore_gcc"となる．

ターゲット依存部のファイルを置くために，targetディレクトリの下に，ター
ゲット略称を名称とするディレクトリを作成する．これをターゲット依存部ディ
レクトリと呼ぶ．

1.1.2 開発環境依存部ディレクトリ

ターゲット依存部から開発環境依存部を切り分ける場合には，archディレクト
リの下に，開発環境略称を名称とするディレクトリを作成する．これを開発環
境依存部ディレクトリと呼ぶ．

1.1.3 プロセッサコア依存部ディレクトリ

ターゲット依存部からプロセッサコア依存部を切り分ける場合には，まず，プ
ロセッサコア略称を定める．プロセッサコア略称に用いる文字は，英小文字と
数字と"_"に限定する．

プロセッサコア依存部のファイルを置くために，archディレクトリの下に，プ
ロセッサコア略称と開発環境略称を"_"で連結したものを名称とするディレクト
リを作成する．例えば，プロセッサコア略称が"arm"で，GNU開発環境を用いる
場合には，ディレクトリの名称は"arm_gcc"となる．

チップ依存部ディレクトリをプロセッサコア依存部ディレクトリの下に置く場
合（「1.1.4 チップ依存部ディレクトリ」の節の(1)の場合）を除いては，これ
をプロセッサコア依存部ディレクトリと呼ぶ．

1.1.4 チップ依存部ディレクトリ

ターゲット依存部からチップ依存部を切り分ける場合には，まず，チップ略称
を定める．チップ略称に用いる文字は，英小文字と数字と"_"に限定する．

チップ依存部のファイルを置くディレクトリ（これをチップ依存部ディレクト
リと呼ぶ）は，その置き場所によって，次の2つ方法がある．

(1) プロセッサコア依存部ディレクトリの下に置く

チップ依存部ディレクトリを，プロセッサコア依存部ディレクトリの下に置く
場合には，チップ略称をディレクトリの名称とする．

この方法を取る場合，プロセッサコアのみに依存するファイルは，プロセッサ
コア依存部ディレクトリの直下には置かず，プロセッサコア依存部ディレクト
リの下に"common"という名称のディレクトリを作成し，その下に置く．この場
合には，プロセッサコアのみに依存するファイルを置くディレクトリを，プロ
セッサコア依存部ディレクトリと呼ぶ．

例えば，プロセッサコア略称が"arm"，チップ略称が"rza1"で，GNU開発環境を
用いる場合には，プロセッサコア依存部ディレクトリはarch/arm_gcc/common，
チップ依存部ディレクトリはarch/arm_gcc/rza1となる．

(2) archディレクトリの直下に置く

チップ依存部ディレクトリを，archディレクトリの直下に置く場合には，チッ
プ略称と開発環境略称を"_"で連結したものを，ディレクトリの名称とする．

1.2 名前の衝突の防止

TOPPERSプロジェクトが提供するソフトウェアのために，TOPPERS_で始まるシン
ボルを予約している．ヘッダファイル中に記述され，アプリケーションから参
照できる内部シンボルは，TOPPERS_で始まる名前とする．

また，_kernel_で始まるシンボルは，カーネル内部の変数や関数のために予約
している．カーネル内部の変数や関数の名前で，リンク時にアプリケーション
の名前と衝突する可能性があるものは，リネーム記述にリストアップすること
で，コンパイル時に_kernel_で始まる名前に置き換えることとしている．

1.3 ヘッダファイルの記述ルール

ヘッダファイルは，この節のルールに従って記述しなければならない．なお，
この節の記述内容は，本来はコーディングルールに含めるべき内容である．

1.3.1 ヘッダファイルの自己完結

ヘッダファイルは，自己完結するように，必要な他のヘッダファイルをインク
ルードするのを原則とする．言い換えると，ヘッダファイルをインクルードす
る前に，他のヘッダファイルをインクルードしてあることを仮定してはならな
い．

1.3.2 多重インクルードへの対応

ヘッダファイルには，多重にインクルードされても問題ないようにするための
条件コンパイル記述を含めるものとする．例えば，target_kernel_impl.hであ
れば，ファイルの先頭に

#ifndef TOPPERS_TARGET_KERNEL_IMPL_H
#define TOPPERS_TARGET_KERNEL_IMPL_H

を，ファイルの末尾に

#endif /* TOPPERS_TARGET_KERNEL_IMPL_H */

を記述する．

1.3.3 アセンブリ言語とのヘッダファイルの共用

ヘッダファイルの中で，アセンブリ言語のソースファイルからもインクルード
される可能性のあるものは，次のルールに従って記述するものとする．

・TOPPERS_MACRO_ONLYがマクロ定義されている場合には，アセンブリ言語では
　解釈できない記述（マクロ定義以外の記述）を除くように記述する．

・符号無し整数型の定数値は，UINT_CやULONG_Cなどの整数定数を作るためのマ
　クロを用いて記述する．ただし，アセンブリ言語のソースファイルからもイ
　ンクルードされるファイル中であっても，C言語のみで用いる定数は，これら
　のマクロを使って記述する必要はない．

・アセンブリ言語からも用いる定数の定義中に型キャストを用いる場合には，
　CASTマクロを用いて記述する．

アセンブリ言語からヘッダファイルをインクルードする際には，必要に応じて，
TOPPERS_MACRO_ONLY，UINT_C，ULONG_C，CASTをマクロ定義してから，インクルー
ドしなければならない．

1.4 インクルード記述の方法

開発環境で用意されている標準ヘッダファイルおよびincludeディレクトリ下の
標準ヘッダファイルは，「#include <...>」によりインクルードする．

その他のヘッダファイルは，「#include "..."」によりインクルードする．ヘッ
ダファイルが，カレントディレクトリやインクルードするファイルと同じディ
レクトリ以外のディレクトリに置かれている場合には，次のようにパス指定を
行う．

・ターゲット依存部ディレクトリ，開発環境依存部ディレクトリ，プロセッサ
　コア依存部ディレクトリ，チップ依存部ディレクトリに置かれている場合は，
　パス指定を行わず，ファイル名のみを記述する．
		例）#include "target_kernel_impl.h"
		例）#include "core_kernel_impl.h"
		例）#include "tool_stddef.h"

　これは，コンパイラに与える-Iオプションにより，インクルードするファイ
　ルを制御できるようにするためである．

・その他のディレクトリに置かれている場合には，ソースプログラムのルート
　ディレクトリ（configure.rbが置かれているディレクトリ）からの相対パス
　で記述する．
		例）#include "arch/tracelog/trace_log.h"

・カーネルを構成するファイルから，kernelディレクトリ下のヘッダファイル
　をインクルードする場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "kernel_impl.h"

1.5 クリティカルセクションの出入処理の実現に関する制約

カーネル内で用いるクリティカルセクションの出入処理を実現する場合には，
次の2つの条件を満たすように実装しなければならない．

(1-5-1) クリティカルセクションの入処理から抜けた時点では，割込みの禁止
が完了していなければならない．例えば，割込みを禁止するための命令を実行
してから実際に割込みが禁止されるまでに遅延があるプロセッサの場合には，
入処理の中に同期命令やNOP命令を入れるなどの方法で，入処理を抜けた時点
では，割込みが禁止された状態になっていることを保証しなければならない．

(1-5-2) メモリ上のデータ構造が書き変わる可能性があることを，何らかの方
法でコンパイラに知らせなければならない．GNU開発環境では，次のいずれかの
方法でこの制約を満たすことができる．

(a) クリティカルセクションの出入処理の全体または出入処理の本質的な部分
	（具体的には，割込み禁止／許可する処理）を（インラインでない）通常
	の関数により実現する．

(b) クリティカルセクションの出入処理の本質的な部分をインラインアセンブ
	ラによって実現している場合には，そのインラインアセンブラのclobber変
	数リストに"memory"を追加する．

(c) クリティカルセクションの出入処理の本質的な部分が，マクロやインライ
	ン関数呼出しで実現している場合には，クリティカルセクションに入る処
	理の最後と出る処理の先頭に，Asm("":::"memory")という記述を入れる．

このような制約を設ける理由については，「TOPPERS/ASP3カーネル 設計メモ」
の「カーネルのデータ構造に対するvolatile宣言について」の節を参照するこ
と．


２．システム構築環境のターゲット依存部

この章の説明は，GNU開発環境（GCC，GAS，BINUTILS，GNU Make）を用いること
を想定して記述してある．それ以外の開発環境を用いる場合には，開発環境に
あわせて修正する必要がある．

GNU開発環境用のシステム構築環境は，サンプルのMakefile（sample/Makefile），
コンフィギュレーションスクリプト（configure.rb）で構成される．

GNU開発環境以外の開発環境を用いる場合には，これらのファイルを，その開発
環境用に用意する必要がある場合がある．その場合には，これらのファイルを，
ターゲット依存部ディレクトリか開発環境依存部ディレクトリに置くものとす
る．また，開発環境用のプロジェクトファイルが必要な場合には，ターゲット
依存部ディレクトリに置くものとする．

サンプルのMakefileは，ターゲット依存部ディレクトリのMakefile.targetをイ
ンクルードする．Makefileのターゲット依存部は，ターゲット依存部ディレク
トリのMakefile.targetまたはそこからインクルードされるファイル（開発環境
依存部／プロセッサコア依存部／チップ依存部で用意されるファイルなど）に
含める．以下では，Makefileのターゲット依存部に記述すべき内容について説
明する．

2.1 システム略称・開発環境略称等の設定

システム略称，開発環境略称，プロセッサコア略称，チップ略称を設定するた
めに，Makefileのターゲット依存部で次の変数を定義する．なお，ターゲット
略称は，Makefile.targetをインクルードする前に，変数TARGETに定義してあ
るものとする（Makefile.targetをインクルードするために，変数TARGETを使
用するため）．

(2-1-1) SYS						システム略称

システム略称に定義する．

(2-1-2) TOOL					開発環境略称

開発環境依存部を用いる場合には，開発環境略称に定義する．GNU開発環境を用
いる場合には，gccに定義する．

(2-1-3) CORE					プロセッサコア略称
(2-1-4) CHIP					チップ略称

プロセッサコア依存部／チップ依存部を用いる場合には，それぞれ，プロセッ
サコア略称／チップ略称に定義する．

2.2 依存部ディレクトリの設定

開発環境依存部ディレクトリ，プロセッサコア依存部ディレクトリ，チップ依
存部ディレクトリを設定するために，Makefileのターゲット依存部で次の変数
を定義する．

なお，ターゲット依存部ディレクトリは，Makefile.targetをインクルードす
る前に，変数TARGETDIRに定義してあるものとする．また，ソースプログラム
のルートディレクトリ（configure.rbが置かれているディレクトリ）は，変数
SRCDIRに定義してあるものとする．

(2-2-1) TOOLDIR					開発環境依存部ディレクトリ
(2-2-2) COREDIR					プロセッサコア依存部ディレクトリ
(2-2-3) CHIPDIR					チップ依存部ディレクトリ

開発環境依存部／プロセッサコア依存部／チップ依存部を用いる場合には，そ
れぞれ，開発環境依存部ディレクトリ／プロセッサコア依存部ディレクトリ／
チップ依存部ディレクトリに定義する．

2.3 コマンド名の設定

(2-3-1) GCC_TARGET				GNU開発環境のターゲット名

GNU開発環境を用いる場合に，GNU開発環境をconfigureする場合に指定するター
ゲット名に定義する．ここで指定したターゲット名は，開発環境のコマンド名
の先頭に付与される文字列となる．例えば，GCC_TARGETをarm-none-eabiに定義
した場合には，コンパイラとしてarm-none-eabi-gccが使われる．この変数が定
義されない場合には，単なるgccが使われる．

(2-3-2) CC						Cコンパイラドライバの名称
(2-3-3) CXX						C++コンパイラドライバの名称
(2-3-4) AS						アセンブラの名称
(2-3-5) LD						リンカの名称
(2-3-6) AR						アーカイバの名称
(2-3-7) NM						nmコマンドの名称
(2-3-8) RANLIB					ranlibコマンドの名称
(2-3-9) OBJCOPY					objcopyコマンドの名称（オプション）
(2-3-10) OBJDUMP				objdumpコマンドの名称

GNU開発環境以外の開発環境を用いる場合に，それぞれのコマンドの名称に定義
する．対応するコマンドがない場合や，コマンドパラメータが異なる場合には，
Makefile中でそのコマンドを呼び出している部分を変更する必要がある．

GNU開発環境では，これらはGCC_TARGETを用いて定義されるので，定義する必要
はない．

2.4 コンパイルオプションとオブジェクトファイルの設定

Makefileのターゲット依存部で以下で説明する変数を定義する時には，":="を
用いて，それまでの定義に追加する形で行う．例えば，コンパイラに対するそ
の他のオプションとして「-Wall -g -O2」を追加したい場合には，「COPTS :=
$(COPTS) -Wall -g -O2」という記述をMakefileのターゲット依存部に含める．

(2-4-1) COPTS				コンパイラに対するその他のオプション
(2-4-2) CDEFS				マクロ定義オプション（-Dオプション）
(2-4-3) INCLUDES			ヘッダファイルの置かれたディレクトリ指定オ
							プション（-Iオプション）
(2-4-4) LDFLAGS				リンカに対するその他のオプション
(2-4-5) LIBS				ライブラリリンク指定のためのオプション

ターゲットに依存して，すべてのソースファイルに共通するコンパイルオプショ
ンの追加が必要な場合には，オプションの種類毎に上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
INCLUDES := $(INCLUDES) -I$(TARGETDIR) -I$(TOOLDIR)
----------------------------------------

コンパイラの問題等で，警告メッセージが出ることを防げない状況以外では，
COPTSに-Werrorを追加することを推奨する．

----------------------------------------
COPTS := $(COPTS) -Werror
----------------------------------------

カーネルのコンパイル時に，dereferencing type-punned pointer will break
strict-aliasing rulesという警告が出る場合には，以下を追加するとよい．こ
の警告メッセージに関する詳細は，「TOPPERS/ASP3カーネル 設計メモ」の「型
キャストに伴う警告メッセージ」の節を参照すること．

----------------------------------------
KERNEL_CFLAGS := $(KERNEL_CFLAGS) -fno-strict-aliasing
----------------------------------------

(2-4-6) SYSSVC_DIRS			システムサービスのソースが置かれたディレクトリ
(2-4-7) SYSSVC_ASMOBJS		アセンブリ言語で記述されたシステムサービスの
							オブジェクト
(2-4-8) SYSSVC_COBJS		C言語で記述されたシステムサービスのオブジェクト
(2-4-9) SYSSVC_CFLAGS		システムサービスに対するコンパイルオプション

ターゲットに依存して，システムサービス（システムログタスクやデバイスド
ライバなど）のソースが置かれたディレクトリ，システムサービスを構成する
オブジェクトファイルのリスト，それらをコンパイルする際に適用するコンパ
イルオプションを追加する場合には，上に示した変数に定義する．なお，
SYSSVC_CFLAGSに定義したオプションは，コンフィギュレータが生成したファイ
ルをコンパイルする場合には適用されないため，注意すること．

(2-4-10) KERNEL_DIRS		カーネルのソースが置かれたディレクトリ
(2-4-11) KERNEL_ASMOBJS		アセンブリ言語で記述されたカーネルのオブジェクト
(2-4-12) KERNEL_COBJS		C言語で記述されたカーネルのオブジェクト
(2-4-13) KERNEL_CFLAGS		カーネルに対するコンパイルオプション

ターゲットに依存して，カーネルのソースが置かれたディレクトリ，カーネル
を構成するオブジェクトファイルのリスト，それらをコンパイルする際に適用
するコンパイルオプションを追加する場合には，上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
KERNEL_DIRS := $(KERNEL_DIRS) $(TARGETDIR)
KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
KERNEL_COBJS := $(KERNEL_COBJS) target_kernel_impl.o target_timer.o
----------------------------------------

(2-4-14) OBJ_LDFLAGS		カーネルに対するリンクオプション

ターゲットに依存して，カーネルをリンクする際に適用するオプションを追加
する場合には，上に示した変数に定義する．LDFLAGSと異なり，この変数に追加
したオプションは，cfg1_out.cをリンクする際には適用されない．

(2-4-15) CFG_TABS			コンフィギュレータに対するオプション

ターゲットに依存して，コンフィギュレータに対するオプションを追加する場
合には，上に示した変数に定義する．具体的には，ターゲット依存部の値取得
シンボルテーブル（標準的には，target_sym.def）がある場合には，それを指
定するオプションを追加する必要がある．

コンフィギュレータに，target_sym.defを値取得シンボルテーブルと扱わせる
ためには，ターゲット依存部ディレクトリのMakefile.targetに，以下の記述
を含める必要がある．

----------------------------------------
CFG_TABS := $(CFG_TABS) --symval-table $(TARGETDIR)/target_sym.def
----------------------------------------

(2-4-16) CFG1_OUT_LDFLAGS	cfg1_out.cに対するリンクオプション

ターゲットに依存して，cfg1_out.cをリンクする際に適用するオプションを追
加する場合には，上に示した変数に定義する．LDFLAGSと異なり，この変数に追
加したオプションは，カーネルをリンクする際には適用されない．

(2-4-17) CFG_ASMOBJS		アセンブリ言語で記述されたシステムコンフィ
							ギュレーションのためのオブジェクト
(2-4-18) CFG_COBJS			C言語で記述されたシステムコンフィギュレー
							ションのためのオブジェクト

ターゲットに依存して，システムコンフィギュレーションのためのオブジェク
トファイルを（kernel_cfg.o以外に）追加する場合には，上に示した変数に定
義する．この場合，追加したオブジェクトファイルの作成ルール（コンパイル／
アセンブルルールと依存関係作成ルール）を，Makefileのターゲット依存部に
記述する必要がある．

(2-4-19) CFG2_OUT_SRCS

ターゲットに依存して，コンフィギュレータのパス2でkernel_cfg.cと
kernel_cfg.h以外のファイルを生成する場合には，上に示した変数に定義する．

(2-4-20) OMIT_WARNING_ALL
(2-4-21) OMIT_OPTIMIZATION

サンプルのMakefileでは，コンパイラに対するオプションに「-Wall -g -O2」
を追加する．-Wallを追加したくない場合には，Makefileのターゲット依存部で
OMIT_WARNING_ALLを"true"に定義する．-O2を追加したくない場合には，
Makefileのターゲット依存部でOMIT_OPTIMIZATIONを"true"に定義する．

2.5 オフセットファイルの生成方法

アセンブリ言語で記述されるプログラムから，C言語の構造体にアクセスする場
合には，構造体の各フィールドのオフセット値を参照することが必要である．
ASP3カーネルでは，コンフィギュレータを用いて必要なオフセット値を求め，
オフセットファイル（offset.h）に生成するための仕組みを用意している．

この仕組みを用いることで，例えば，TCB中のp_tinibフィールドのオフセット
値をTCB_p_tinibにマクロ定義することや，TCB中のタスクコンテキストブロッ
ク（tskctxb）に含まれるpcフィールドのオフセット値をTCB_pcにマクロ定義す
ることができる．また，TCB中のenaterフィールドのオフセット値，ビット位置，
ビットマスクを，それぞれTCB_enater，TCB_enater_bit，TCB_enater_maskにマ
クロ定義することができる．

用意している仕組みによりオフセットファイルを生成できない時には，オフセッ
トファイルをターゲット依存部で用意する必要がある．

拡張パッケージの中には，TCBにフィールドを追加するものがあるため，TCB中
のフィールドのオフセット値は変化する．offset.hを生成する場合でも，ター
ゲット依存部で用意する場合でも，拡張パッケージに対応するためには，この
ことを考慮する必要がある．

以下では，コンフィギュレータを用いてoffset.hを生成する方法について説明
する．この方法では，コンフィギュレータのパス1で生成するcfg1_out.cをコ
ンパイルして生成したロードモジュールから，コンフィギュレータによって
offset.hを生成する．

この方法を用いるためには，ターゲット依存部でオフセットファイル生成用の
生成スクリプト（標準的には，target_offset.trb）を用意し，そのパス名を，
Makefileのターゲット依存部でTARGET_OFFSET_TRBに定義する．また，
target_cfg1_out.h（または，そこからインクルードされるファイル）と
target_sym.def（または，同等の役割を持つファイル）に記述を追加する必要
がある．

オフセットファイル生成用の生成スクリプトには，以下の内容を記述する．

(1) 生成スクリプトのターゲット非依存部のインクルード

オフセットファイル生成用の生成スクリプトのターゲット非依存部
（kernel/genoffset.trb）をインクルードする．生成スクリプトのターゲット
非依存部には，オフセットファイルを生成する処理や，以下で用いる
BitOffsetPosition関数の定義などが含まれている．

----------------------------------------
# ターゲット非依存部のインクルード
IncludeTrb("kernel/genoffset.trb")
----------------------------------------

(2) オフセット値のマクロ定義の生成

構造体中のフィールドのオフセット値のマクロ定義を生成する．例えば，TCB
中のタスクコンテキストブロック（tskctxb）に含まれるpcフィールドのオフ
セット値を，TCB_pcにマクロ定義する場合には，次のように記述する．

----------------------------------------
# オフセット値のマクロ定義の生成
$offsetH.append(<<EOS)
#define TCB_pc			#{$offsetof_TCB_pc}
EOS
----------------------------------------

また，コンフィギュレータが，オフセット値を保持する変数（上の例では
$offsetof_TCB_pc）に値を設定するために，target_sym.def（または，同等の
役割を持つファイル）に次のような行を追加する．

----------------------------------------
offsetof_TCB_pc,"offsetof(TCB,tskctxb.pc)"
----------------------------------------

ただし，各オブジェクトの初期化ブロックのターゲット非依存のフィールドの
オフセット値を取得するための記述は，kernel/kernel_sym.defに含まれている．
kernel/kernel_sym.defに含まれている記述は，target_sym.def（または，同等
の役割を持つファイル）に追加する必要はない．

(3) ビットオフセット値等のマクロ定義の生成

構造体中のビットフィールドのオフセット値，ビット位置，ビットマスクのマ
クロ定義を生成する．例えば，TCB中のenaterフィールドのオフセット値，ビッ
ト位置，ビットマスクを，それぞれTCB_enater，TCB_enater_bit，
TCB_enater_maskにマクロ定義する場合には，次のように記述する．

----------------------------------------
offset, position = BitOffsetPosition("TCB_enater", $sizeof_TCB, "B")
$offsetH.append(<<EOS)
#define TCB_enater		#{offset}
#define TCB_enter_bit	#{position}
#define TCB_enter_mask	0x#{(1 << position).to_s(16)}
EOS
----------------------------------------

ここで，BitOffsetPosition関数は，構造体中のビットフィールドのオフセッ
ト値とビット位置を求める関数である．第1パラメータには，次に述べるビッ
トオフセット値等を求めるための構造体の変数名を，第2パラメータには，構
造体のサイズを渡す．第3パラメータには，ビットのオフセット，ビット位置，
ビットマスクを，8ビット単位（バイト単位）で求める場合には"B"を，16ビッ
ト単位で求める場合には"H"を，32ビット単位で求める場合には"W"を指定する．
なお，ビット位置は，LSBを0とした値（ビットリトルエンディアンを想定）を
求める．

また，target_cfg1_out.h（または，そこからインクルードされるファイル）
に，ビットオフセット値等を求めるための構造体の変数定義を追加する．この
構造体の変数は，オフセット値とビット位置を求める対象のビットのみが1で，
他のすべてのビットが0になるように初期化する．また，const修飾子を付加す
る．例えば，TCB中のenaterフィールドのビットオフセット値等を求める場合
には，次のような定義を追加する（tskctxbの初期値は，ターゲット依存なの
で注意すること）．

----------------------------------------
const TCB TCB_enater = {
	{ NULL, NULL },			/* task_queue */
	NULL,					/* p_tinib */
	0U,						/* tstat */
	0U,						/* bpriority */
	0U,						/* priority */
	false,					/* actque */
	false,					/* wupque */
	false,					/* raster */
	true,					/* enater */
#ifdef TOPPERS_SUPPORT_OVRHDR
	false,					/* staovr */
#endif /* TOPPERS_SUPPORT_OVRHDR */
#ifdef TOPPERS_SUPPORT_SUBPRIO
	0U,						/* subpri */
#endif /* TOPPERS_SUPPORT_SUBPRIO */
	NULL,					/* p_winifo */
	NULL,					/* p_lastmtx */
#ifdef TOPPERS_SUPPORT_OVRHDR
	0U,						/* leftotm */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	{ NULL, NULL }			/* tskctxb */
};
----------------------------------------

さらに，コンフィギュレータが，構造体のサイズ（上の例では$sizeof_TCB）に
値を設定するために，target_sym.def（または，同等の役割を持つファイル）
に次の例のような行を追加する．

----------------------------------------
sizeof_TCB,sizeof(TCB)
----------------------------------------

ただし，前述した通り，kernel/kernel_sym.defに含まれている記述は，
target_sym.def（または，同等の役割を持つファイル）に追加する必要はない．

なお，以上の方法でオフセットファイルを生成した場合には，offset.hに妥当
な定義が生成されていることを確認すべきである．

2.6 リンク方法の設定

(2-6-1) LDSCRIPT				リンカスクリプトのファイル名

開発環境に標準のリンカスクリプトが使用できない場合には，ターゲット依存
部でリンカスクリプトを用意し，そのファイル名をこの変数に定義する．

(2-6-2) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-6-3) DATA_START_ADDRESS		データセクションの先頭番地

各セクションの先頭番地の指定が必要な場合には，これらの変数に先頭番地を
定義する．

(2-6-4) START_OBJS				先頭にリンクすべきモジュール名
(2-6-5) END_OBJS				最後にリンクすべきモジュール名

ターゲットによっては，ロードモジュールの先頭と最後にリンクすべきモジュー
ルを，ターゲット依存部で用意する必要がある．多くの場合，スタートアップ
モジュールをロードモジュールの先頭にリンクする必要がある．

ロードモジュールの先頭にリンクすべきプログラムがある場合には，Makefile
のターゲット依存部において，そのオブジェクトファイル名をSTART_OBJSに定
義し，それに対するコンパイルルールと依存関係作成ルールを定義する．ロー
ドモジュールの最後にリンクすべきモジュールがある場合には，そのオブジェ
クトファイル名をEND_OBJSに定義し，それに対するコンパイルルールと依存関
係作成ルールを定義する．また，標準のスタートアップモジュール（crt0.o）
をリンクしないように，LDFLAGSとCFG1_OUT_LDFLAGSに-nostdlibを追加する必
要がある．さらに，-nostdlibをつけることで標準ライブラリがリンクされなく
なるため，LIBSに-lgccを追加しなければならない．

例えば，スタートアップモジュールのソースファイルがstart.Sの場合には，
Makefileのターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
START_OBJS := start.o
START_OBJS := $(addprefix $(OBJDIR)/, $(START_OBJS))

# スタートアップモジュールのコンパイルルール
$(START_OBJS): $(OBJDIR)/%.o: %.S
	$(CC) -c -o $@ -MD -MP -MF $(DEPDIR)/$*.d $(CFLAGS) $(KERNEL_CFLAGS) $<

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
CFG1_OUT_LDFLAGS := -nostdlib $(CFG1_OUT_LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

また，GNU開発環境で，コンパイラに標準のcrtbegin.oとcrtend.oを用いる場合
には，Makefile のターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# オブジェクトファイル名
START_OBJS := $(shell $(CC) -print-file-name=crtbegin.o)
END_OBJS := $(shell $(CC) -print-file-name=crtend.o)

START_OBJS := $(addprefix $(OBJDIR)/, $(START_OBJS))
END_OBJS := $(addprefix $(OBJDIR)/, $(END_OBJS))

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
CFG1_OUT_LDFLAGS := -nostdlib $(CFG1_OUT_LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

この場合，これらのファイルをコンパイルすることはないため，コンパイルルー
ルは不要である．

(2-6-6) HIDDEN_OBJS				指定しなくてもリンクされるモジュール名

ロードモジュールにリンクすべきモジュールを，リンカに対するパラメータで
はなく，リンカスクリプト中に（例えば，GNU開発環境のリンカスクリプトの
STARTUPを使って）記述する場合には，そのオブジェクトファイル名を，
（START_OBJSまたはEND_OBJSではなく）HIDDEN_OBJSに定義し，それに対するコ
ンパイルルールと依存関係作成ルールを定義する．HIDDEN_OBJSに定義したモ
ジュールは，リンカに対するパラメータからは除外される．LDFLAGSと
CFG1_OUT_LDFLAGS，LIBSについては，START_OBJSまたはEND_OBJSを用いる場合
と同様である．

例えば，スタートアップモジュールのソースファイルがstart.Sで，start.oを
リンクすることをリンカスクリプト中に記述する場合には，Makefileのターゲッ
ト依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
HIDDEN_OBJS := start.o
HIDDEN_OBJS := $(addprefix $(OBJDIR)/, $(HIDDEN_OBJS))

# スタートアップモジュールのコンパイルルール
$(HIDDEN_OBJS): %.o: %.S
	$(CC) -c -o $@ -MD -MP -MF $(DEPDIR)/$*.d $(CFLAGS) $(KERNEL_CFLAGS) $<

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
CFG1_OUT_LDFLAGS := -nostdlib $(CFG1_OUT_LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

2.7 依存関係の定義（オプション）

ターゲット依存部の開発中は，コンフィギュレータの各パスに対して，生成ス
クリプトのターゲット依存部への依存関係を定義すると便利である．具体的に
は，パス1，オフセットファイル生成，パス2，パス3が依存するファイルを，そ
れぞれcfg1_out.timestamp，offset.timestamp，kernel_cfg.timestamp，
check.timestampに対する依存関係の形で記述する．

典型的には，ターゲット依存部ディレクトリのMakefile.targetに含める記述
は，以下のようになる（開発環境依存部／プロセッサコア依存部／チップ依存
部にファイルを分割している場合には，これに追加する必要がある）．

----------------------------------------
cfg1_out.timestamp: $(TARGETDIR)/target_sym.def
offset.timestamp: $(TARGETDIR)/target_offset.trb
kernel_cfg.timestamp: $(TARGETDIR)/target_kernel.trb
check.timestamp: $(TARGETDIR)/target_check.trb
----------------------------------------

2.8 その他の設定

(2-8-1) TARGET_OFFSET_TRB		オフセットファイル生成用の生成スクリプ
								トのパス名

オフセットファイルを生成する場合には，オフセットファイル生成用の生成ス
クリプト（標準的には，target_offset.trb）のパス名をこの変数に定義する．

(2-8-2) TARGET_KERNEL_TRB		target_kernel.trbのパス名
(2-8-3) TARGET_CHECK_TRB		target_check.trbのパス名
(2-8-4) TARGET_KERNEL_CFG		target_kernel.cfgのパス名

ターゲット依存部の各ファイルのパス名を，標準から変更したい場合には，パ
ス名をこれらの変数に定義する．

(2-8-5) CLEAN_FILES				cleanにより削除するファイル名

cleanにより削除するファイルをターゲット依存部で追加したい場合には，ファ
イル名をこの変数に追加定義する．

(2-8-6) REALCLEAN_FILES			realcleanにより削除するファイル名

realcleanにより削除するファイルをターゲット依存部で追加したい場合には，
ファイル名をこの変数に追加定義する．

(2-8-7) DUMP					ダンプファイルの拡張子

objcopyコマンドによりモトローラSレコード形式のファイルを作成することが
できず，objdumpコマンドによるダンプ形式のファイルで代える場合には，こ
の変数をダンプファイルの拡張子（"dump"）に定義する．

Sレコードフォーマットは64ビットアドレスに対応していないため，アドレス
が64ビットのターゲットでは，objdumpコマンドによるダンプ形式のファイル
を用いる必要がある．


３．TOPPERS共通定義のターゲット依存部

TOPPERS共通定義（t_stddef.h）のターゲット依存部は，target_stddef.hまた
はそこからインクルードされるファイル（開発環境依存部／プロセッサコア依
存部／チップ依存部で用意されるヘッダファイルなど）に含める．

3.1 ターゲット識別マクロ

アプリケーションやシステムサービスでターゲットを識別するために，
"TOPPERS_"にシステム略称を大文字にした文字列を連結したもの（例えば，
"TOPPERS_CT11MPCORE"）をマクロ定義する．

また，ターゲット依存部からプロセッサコア依存部／チップ依存部を切り分け
た場合には，"TOPPERS_"にプロセッサコア略称／チップ略称を大文字にした文
字列を連結したもの（例えば，"TOPPERS_ARM"）をマクロ定義する．

3.2 整数型の最大値・最小値・ビット数

(3-2-1) INT_MAX				intに格納できる最大値（C90準拠）
(3-2-2) INT_MIN				intに格納できる最小値（C90準拠）
(3-2-3) UINT_MAX			unsigned intに格納できる最大値（C90準拠）
(3-2-4) LONG_MAX			longに格納できる最大値（C90準拠）
(3-2-5) LONG_MIN			longに格納できる最小値（C90準拠）
(3-2-6) ULONG_MAX			unsigned longに格納できる最大値（C90準拠）
(3-2-7) CHAR_BIT			char型のビット数（C90準拠）

整数型の最大値・最小値・ビット数を，これらのシンボルにマクロに定義する．

これらのマクロは，C90に準拠したものである．開発環境にC90に準拠した
limits.hが用意されている場合には，これらのマクロを定義することに代えて，
limits.hをインクルードすればよい．

3.3 サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ

(3-3-1) int8_t				符号付き8ビット整数（オプション，C99準拠）
(3-3-2) uint8_t				符号無し8ビット整数（オプション，C99準拠）
(3-3-3) int16_t				符号付き16ビット整数（C99準拠）
(3-3-4) uint16_t			符号無し16ビット整数（C99準拠）
(3-3-5) int32_t				符号付き32ビット整数（C99準拠）
(3-3-6) uint32_t			符号無し32ビット整数（C99準拠）
(3-3-7) int64_t				符号付き64ビット整数（オプション，C99準拠）
(3-3-8) uint64_t			符号無し64ビット整数（オプション，C99準拠）
(3-3-9) int128_t			符号付き128ビット整数（オプション，C99準拠）
(3-3-10) uint128_t			符号無し128ビット整数（オプション，C99準拠）
(3-3-11) int_least8_t		8ビット以上の符号付き整数（C99準拠）
(3-3-12) uint_least8_t		8ビット以上の符号無し整数（C99準拠）
(3-3-13) size_t				メモリ領域のサイズを表す符号無し整数（C90準拠）
(3-3-14) intptr_t			ポインタを格納できるサイズの符号付き整数（C99準拠）
(3-3-15) uintptr_t			ポインタを格納できるサイズの符号無し整数（C99準拠）
(3-3-16) INT8_MAX			int8_tに格納できる最大値（オプション，C99準拠）
(3-3-17) INT8_MIN			int8_tに格納できる最小値（オプション，C99準拠）
(3-3-18) UINT8_MAX			uint8_tに格納できる最大値（オプション，C99準拠）
(3-3-19) INT16_MAX			int16_tに格納できる最大値（C99準拠）
(3-3-20) INT16_MIN			int16_tに格納できる最小値（C99準拠）
(3-3-21) UINT16_MAX			uint16_tに格納できる最大値（C99準拠）
(3-3-22) INT32_MAX			int32_tに格納できる最大値（C99準拠）
(3-3-23) INT32_MIN			int32_tに格納できる最小値（C99準拠）
(3-3-24) UINT32_MAX			uint32_tに格納できる最大値（C99準拠）
(3-3-25) INT64_MAX			int64_tに格納できる最大値（オプション，C99準拠）
(3-3-26) INT64_MIN			int64_tに格納できる最小値（オプション，C99準拠）
(3-3-27) UINT64_MAX			uint64_tに格納できる最大値（オプション，C99準拠）
(3-3-28) INT128_MAX			int128_tに格納できる最大値（オプション，C99準拠）
(3-3-29) INT128_MIN			int128_tに格納できる最小値（オプション，C99準拠）
(3-3-30) UINT128_MAX		uint128_tに格納できる最大値（オプション，C99準拠）
(3-3-31) INT_LEAST8_MAX		int_least8_tに格納できる最大値（C99準拠）
(3-3-32) INT_LEAST8_MIN		int_least8_tに格納できる最小値（C99準拠）
(3-3-33) UINT_LEAST8_MAX	uint_least8_tに格納できる最大値（C99準拠）
(3-3-34) SIZE_MAX			size_tに格納できる最大値（C99準拠）
(3-3-35) INT8_C(val)		int_least8_t型の定数を作るマクロ（C99準拠）
(3-3-36) UINT8_C(val)		uint_least8_t型の定数を作るマクロ（C99準拠）
(3-3-37) INT16_C(val)		int16_t型の定数を作るマクロ（C99準拠）
(3-3-38) UINT16_C(val)		uint16_t型の定数を作るマクロ（C99準拠）
(3-3-39) INT32_C(val)		int32_t型の定数を作るマクロ（C99準拠）
(3-3-40) UINT32_C(val)		uint32_t型の定数を作るマクロ（C99準拠）
(3-3-41) INT64_C(val)		int64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-42) UINT64_C(val)		uint64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-43) INT128_C(val)		int128_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-44) UINT128_C(val)		uint128_t型の定数を作るマクロ（オプション，C99準拠）

指定されたサイズの整数型を，これらのシンボルに型定義する．また，データ
型に格納できる最大値・最小値と，整数定数を作るマクロを，これらのシンボ
ルにマクロ定義する．

size_t型は，C90に準拠したものである．C90準拠のC言語環境では，size_tの定
義はstddef.h等に含まれているため，これをインクルードしてもよい．

その他のデータ型およびマクロは，C99に準拠したものである．開発環境にC99
に準拠したstdint.hが用意されている場合には，これらのデータ型およびマク
ロを定義することに代えて，stdint.hをインクルードすればよい．

上でオプションと記述したものは，該当するデータ型がコンパイラでサポート
されている場合にのみ定義することを示す．

3.4 サイズの指定された浮動小数点型，その最大値・最小値のマクロ

(3-4-1) float32_t			IEEE754準拠の32ビット単精度浮動小数点数（オプ
							ション）
(3-4-2) double64_t			IEEE754準拠の64ビット倍精度浮動小数点数（オプ
							ション）
(3-4-3) FLOAT32_MIN			float32_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-4) FLOAT32_MAX			float32_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）
(3-4-5) DOUBLE64_MIN		double64_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-6) DOUBLE64_MAX		double64_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）

指定されたサイズ・表現形式の浮動小数点型を，これらのシンボルに型定義す
る．また，データ型に格納できる最大値・最小値を，これらのシンボルにマク
ロ定義する．

いずれも，該当するデータ型がコンパイラでサポートされている場合にのみ定
義する．

3.5 コンパイラの拡張機能のためのマクロ定義

コンパイラの拡張機能を用いるためのマクロとして，必要に応じて，以下のマ
クロの定義を含める．

(3-5-1) inline（オプション，デフォルトは未定義）
(3-5-2) Inline（オプション，デフォルトはstatic inline）

インライン関数であることを示す指定．Inlineは，コンパイル単位にローカル
なインライン関数であることを示す．

(3-5-3) asm（オプション，デフォルトは未定義）
(3-5-4) Asm（オプション，デフォルトは未定義）

インラインアセンブラを記述するための指定．Asmは，最適化により削除しては
ならないことを示す．これらは，ターゲット依存部でのみ使うマクロであるた
め，ターゲット依存部で使わないなら定義する必要はない．

(3-5-5) offsetof(structure, field)（オプション，デフォルトの定義あり）

構造体structureの中での，フィールドfieldのオフセットを求めるマクロ．
C90準拠のC言語環境では，offsetofの定義はstddef.hに含まれているため，こ
れをインクルードしてもよい．

(3-5-6) alignof(type)（オプション，デフォルトの定義あり）

データ型typeのアラインメント単位を求めるマクロ．

(3-5-7) NoReturn（オプション，デフォルトは未定義）

リターンすることのない関数であることを示す指定．これは，ターゲット依存
部のみ使うマクロであるため，ターゲット依存部で使わないなら定義する必要
はない．

3.6 標準的な定義の上書き

t_stddef.hに含まれるTOPPERS共通定義の標準的な定義を上書きする場合には，
以下のマクロを定義する．

(3-6-1) TOPPERS_bool（オプション，デフォルトはint）
(3-6-2) TOPPERS_fp（オプション，デフォルトは他と互換性のない関数ポインタ）

それぞれ，bool_t，FPに型定義すべきデータ型．

(3-6-3) UINT_C(val)（オプション，デフォルトはUを付加）
(3-6-4) ULONG_C(val)（オプション，デフォルトはULを付加）

それぞれ，unsigned uint型，unsigned long型の定数を作るためのマクロ．

(3-6-5) NULL（オプション，デフォルトは0）

C90準拠のC言語環境では，NULLの定義はstddef.hに含まれているため，これを
インクルードしてもよい．

(3-6-6) ERCD(mercd, sercd)（オプション）
(3-6-7) MERCD(ercd)（オプション）
(3-6-8) SERCD(ercd)（オプション）

ERCD，MERCD，SERCDの標準の定義は，符号付き整数が2の補数で表現されており，
右シフト演算子（>>）が算術シフトされることを仮定している．多くのコンパ
イラでこの仮定が成り立つが，そうでない場合には，ターゲット依存部でこれ
らの定義を上書きする必要がある．

(3-6-9) ALIGN_TYPE(addr, type)（オプション）

アドレスaddrが，データ型typeのアラインメント単位にアラインしているか
チェックするマクロ．

3.7 アサーションのための定義

t_stddef.hには，assertの定義が含まれる．assertが失敗した場合（assertの
パラメータがfalseになった場合）の処理を，ターゲット依存に用意する必要が
ある．これらの定義は，assertマクロを使用する前であれば，t_stddef.h以降
にインクルードされるファイルに含まれていてもよい．なお，assertを無効に
する（NDEBUGをマクロ定義してコンパイルする）場合には，これらを用意する
必要はない．

(3-7-1) TOPPERS_assert_abort(void)

assertが失敗した場合に，プログラムを停止させる関数．システム開発中はデ
バッガに落とすのが理想的である．システム稼働時には例外処理を行わせるこ
とになる．

(3-7-2) TOPPERS_assert_fail(exp, file, line)

assertが失敗した時の情報を表示/記録するためのマクロ．システムログ機能を
用いる場合には，t_syslog.hにシステムログ機能に記録するための定義が含ま
れているので，ターゲット依存部で用意する必要はない．

3.8 その他の定義

(3-8-1) USE_64BIT_HRTCNT（オプション）

高分解能タイマのカウント値が64ビットで，タイマが0に戻ることを考える必
要がない場合には，このマクロを定義する．これにより，HRTCNT型が符号無し
64ビット整数型に定義される．また，タイムイベントヒープが空の場合には，
高分解能タイマ割込みがかからないように設定されるため，不要な割込みの発
生がなくなる．

HRTCNT型を32ビットとするか64ビットとするかをユーザに委ねる場合には，こ
のマクロをt_stddef.hのターゲット依存部で定義せず，MakefileのCDEFSを用
いてユーザに定義させる．この場合，ターゲット依存部（高分解能タイマドラ
イバ）は，USE_64BIT_HRTCNTが定義されている場合といない場合の両方に対応
できるように実装する必要がある．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL，sil.h）のターゲット依存部の定義は，
target_sil.hまたはそこからインクルードされるファイル（開発環境依存部／
プロセッサコア依存部／チップ依存部で用意されるヘッダファイルなど）に含
める．

SILのサービスコールは，任意のシステム状態で呼び出すことができる．そのた
め，SILのターゲット依存部の関数は，任意のシステム状態で呼び出せるように
実装しなければならない．

4.1 全割込みロック状態の管理

SILのターゲット依存部では，全割込みロック状態へ遷移する機能と，元の状態
へ戻す機能（元の状態を記憶するために変数を使う）を提供する．全割込みロッ
ク状態であるかを判別する機能は提供する必要がない．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのため，
全割込みロック状態への遷移と元の状態への復帰は，カーネルを用いず，プロ
セッサのリソースを直接操作することによって実現する．また，全割込みロッ
ク状態への遷移と元の状態への復帰は，全割込みロック状態やCPUロック状態で
も行える必要がある．

保護機能を持ったカーネルでは，ユーザタスクからプロセッサのリソースを直
接操作することができないため，ユーザタスクからはこれらの機能を用いるこ
とができない．用いた場合の振舞いはターゲットプロセッサに依存するが，典
型的には，特権命令違反などのCPU例外が発生することになる．

(4-1-1) SIL_PRE_LOC

全割込みロックフラグの状態を保存するための変数を定義するマクロ．型名の
後に，変数名を続けたものに定義する．変数名は，他の名前と衝突しないよう
に，"TOPPERS_"で始まる名前にする．

(4-1-2) SIL_LOC_INT()

現在の全割込みロックフラグの状態をSIL_PRE_LOCで定義した変数に保存し，全
割込みロック状態に遷移させるマクロ．このマクロを実現する際には，「1.5
クリティカルセクションの出入処理の実現に関する制約」の節に記述されてい
る制約に従わなければならない．

(4-1-3) SIL_UNL_INT()

SIL_LOC_INT()によって変数に保存した状態に戻すマクロ．このマクロを実現す
る際には，「1.5 クリティカルセクションの出入処理の実現に関する制約」の
節に記述されている制約に従わなければならない．

4.2 微少時間待ち

(4-2-1) void sil_dly_nse(ulong_t dlytim)

dlytimで指定された以上の時間（単位はナノ秒），ループなどによって待つ関
数．

以下の関数と等価な処理を，アセンブリ言語で記述する方法を，標準的な実装
方法とする．アセンブリ言語で記述するのは，コンパイラの最適化に依存しな
いようにするためである．またこの関数は，キャッシュ等の影響を受けないよ
うに，できる限りメモリアクセスを行わないように実装すべきである．

	void sil_dly_nse(ulong_t dlytim)
	{
		dlytim -= SIL_DLY_TIM1;
		if (結果が0より大きい) {
			do {
				dlytim -= SIL_DLY_TIM2;
			} while (結果が0より大きい);
		}
	}

この関数の動作は次の通りである．dlytimがSIL_DLY_TIM1以下の場合には，最
初のif文の条件が成立せず，すぐに関数から抜ける．dlytimがSIL_DLY_TIM1よ
り大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2)以下の場合には，最初のif文の条件は
成立するが，doループは1回も回らずに関数から抜ける．dlytimが
(SIL_DLY_TIM1+SIL_DLY_TIM2)より大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2*2)以
下の場合には，doループを1回だけ回って関数から抜ける．その後，dlytimが
SIL_DLY_TIM2大きくなる度に，whileループを回る回数が1回ずつ増える．

なお，この関数をアセンブリ言語（または，C言語）で記述する場合，どのファ
イルに記述するかが問題になる．SILのターゲット依存部には，標準では，アセ
ンブリ言語（または，C言語）の関数定義を記述するためのファイルを用意して
いない．ターゲット依存で用意してもよいが，例外的に，カーネル実装のター
ゲット依存モジュール（target_support.Sまたはtarget_kernel_impl.c）に記
述してもよいことにする．

(4-2-2) SIL_DLY_TIM1（オプション）
(4-2-3) SIL_DLY_TIM2（オプション）

sil_dly_nseを上記の標準的な方法で実現した場合，この2つの定数をターゲッ
ト依存部でマクロ定義する．

SIL_DLY_TIM2は，上記の関数において，doループ1回の実行時間（単位はナノ秒）
に設定する．ターゲットプロセッサの命令セットにもよるが，おおよそ，減算
命令と条件分岐命令各1回の実行時間になる．SIL_DLY_TIM2が決まれば，関数呼
出しも含めた全体の時間がdlytimで指定された以上の時間になるように，
SIL_DLY_TIM1を決める．

この2つの定数値の決定を支援するプログラムとして，testディレクトリに，
test_dlynseを用意している．test_dlynseを実行すると，次のような出力が得
られる．

-- for fitting parameters --
sil_dly_nse(0): 430 OK
sil_dly_nse(420): 430 OK
sil_dly_nse(510): 520 OK
sil_dly_nse(600): 610 OK
<中略>
-- for checking boundary conditions --
sil_dly_nse(421): 520 OK
sil_dly_nse(511): 610 OK
sil_dly_nse(601): 700 OK

"for fitting parameters"に続く出力は，sil_dly_nse(dlytim)を呼び出した場
合の待ち時間を測定した結果である．このプログラムを用いて，":"の右側の数
値が，dlytimよりも大きい範囲でなるべく近い値になるように，2つの定数値を
調整する．"for checking boundary conditions"に続く出力は，プログラムの
妥当性をチェックするためのもので，":"の右側の数値が，dlytimよりも大きい
ことを確認する（近い値になる必要はない）．

4.3 プロセッサのエンディアン

(4-3-1) SIL_ENDIAN_BIG
(4-3-2) SIL_ENDIAN_LITTLE

プロセッサのエンディアンにより，いずれか片方のシンボルをマクロ定義する．

(4-3-3) TOPPERS_SIL_REV_ENDIAN_UINT16（オプション）
(4-3-4) TOPPERS_SIL_REV_ENDIAN_UINT32（オプション）

それぞれ，16ビット，32ビットの符号無し整数のエンディアンを反転させるマ
クロ．プロセッサがエンディアン反転のための命令を持つ場合には，その命令
を用いて実現する．これらのシンボルをマクロ定義しない場合には，デフォル
トの定義が使われる．

4.4 メモリ空間アクセス関数

(4-4-1) TOPPERS_OMIT_SIL_ACCESS

標準のメモリ空間アクセス関数（メモリ空間同期書込み関数を除く）を使用せ
ず，ターゲット依存部で用意する場合には，このシンボルをマクロ定義する．

(4-4-2) TOPPERS_OMIT_SIL_REH_LEM
(4-4-3) TOPPERS_OMIT_SIL_WRH_LEM
(4-4-4) TOPPERS_OMIT_SIL_REH_BEM
(4-4-5) TOPPERS_OMIT_SIL_WRH_BEM
(4-4-6) TOPPERS_OMIT_SIL_REW_LEM
(4-4-7) TOPPERS_OMIT_SIL_WRW_LEM
(4-4-8) TOPPERS_OMIT_SIL_REW_BEM
(4-4-9) TOPPERS_OMIT_SIL_WRW_BEM

それぞれ，標準のsil_reh_lem，sil_wrh_lem，sil_reh_bem，sil_wrh_bem，
sil_rew_lem，sil_wrw_lem，sil_rew_bem，sil_wrw_bemを使用せず，ターゲッ
ト依存部で用意する場合には，これらのシンボルをマクロ定義する．

(4-4-10) TOPPERS_OMIT_SIL_SYNC_WRITE

標準のメモリ空間同期書込み関数を使用せず，ターゲット依存部で用意する場
合には，このシンボルをマクロ定義する．

(4-4-11) TOPPERS_SIL_WRITE_SYNC()

先行するメモリへの書込みアクセスが完了するのを待つマクロ．標準のメモリ
空間同期書込み関数を使用しない場合は，このマクロを用意する必要はない．

4.5 I/O空間アクセス関数

メモリ空間とは別にI/O空間を持つプロセッサでは，I/O空間にあるデバイスレ
ジスタをアクセスするための関数として，sil_reb_iop，sil_wrb_iop，
sil_reh_iop，sil_wrh_iop，sil_reh_lep，sil_wrh_lep，sil_reh_bep，
sil_wrh_bep，sil_rew_iop，sil_wrw_iop，sil_rew_lep，sil_wrw_lep，
sil_rew_bep，sil_wrw_bep，sil_swrb_iop，sil_swrh_iop，sil_swrh_lep，
sil_swrh_bep，sil_swrw_iop，sil_swrw_lep，sil_swrw_bepの中で必要なもの
を，ターゲット依存部で用意する．


５．カーネルAPIのターゲット依存部

カーネルAPI（kernel.h）のターゲット依存部の定義は，target_kernel.hまた
はそこからインクルードされるファイル（開発環境依存部／プロセッサコア依
存部／チップ依存部で用意されるヘッダファイルなど）に含める．

5.1 ターゲット定義でサポートする機能

(5-1-1) TOPPERS_TARGET_SUPPORT_DIS_INT		dis_intをサポートする
(5-1-2) TOPPERS_TARGET_SUPPORT_ENA_INT		ena_intをサポートする
(5-1-3) TOPPERS_TARGET_SUPPORT_CLR_INT		clr_intをサポートする
(5-1-4) TOPPERS_TARGET_SUPPORT_RAS_INT		ras_intをサポートする
(5-1-5) TOPPERS_TARGET_SUPPORT_PRB_INT		prb_intをサポートする

dis_int，ena_int，clr_int，ras_int，prb_intをサポートする場合に，それ
ぞれのシンボルをマクロ定義する．

5.2 割込み優先度の範囲

(5-2-1) TMIN_INTPRI				割込み優先度の最小値（最高値）
(5-2-2) TMAX_INTPRI				割込み優先度の最大値（最低値）

それぞれ，カーネル管理の割込み優先度の最小値（＝優先度が最高），カーネ
ル管理の割込み優先度の最大値（優先度が最低）に定義する．TMAX_INTPRIは-1
に固定されているが，対称性のために，ターゲット依存部で定義することにし
ている．

5.3 高分解能タイマのタイマ周期とカウント値の進み幅

高分解能タイマドライバに関して，アプリケーションから参照できるマクロを
定義する．高分解能タイマドライバの詳細に関しては，「6.13 高分解能タイマ
ドライバ」の節を参照すること．

(5-3-1) TCYC_HRTCNT		高分解能タイマのタイマ周期

HRTCNT型が32ビットで，高分解能タイマのタイマ周期が2^32でない場合には，
タイマ周期をこのマクロに定義する．USE_64BIT_HRTCNTをマクロ定義して
HRTCNT型を64ビットにした場合と，HRTCNT型を32ビットでタイマ周期が2^32の
場合には，このマクロを定義しない．

(5-3-2) TSTEP_HRTCNT	高分解能タイマのカウント値の進み幅

高分解能タイマのカウント値の進み幅を，このマクロに定義する．例えば，高
分解能タイマが，2マイクロ秒間隔で2ずつカウントアップする場合には，
TSTEP_HRTCNTを2に定義する．

高分解能タイマのカウントアップ間隔が一定でない場合には，「高分解能タイ
マのカウント値の，連続して進む時刻に対する遅れの最大値を，マイクロ秒単
位の整数値に切り上げた値」をこのマクロに定義する．

なお，高分解能タイマのカウントアップ間隔が一定である場合には，この定義
は，高分解能タイマのカウント値の進み幅に一致する．例えば，高分解能タイ
マが2マイクロ秒間隔で2ずつカウントアップする場合，カウントアップする直
前には，カウント値はほぼ2マイクロ秒遅れていることになる．

5.4 メモリ領域確保のための型定義

(5-4-1) TOPPERS_STK_T	スタック領域を確保するための型（オプション）
(5-4-2) TOPPERS_MPF_T	固定長メモリプール領域を確保するための型（オプション）

スタック領域と固定長メモリプール領域は，標準ではintptr_t型の配列として
確保するが，より大きい単位でアラインさせたいなどの理由でそれ以外の型の
配列として確保する場合には，それぞれTOPPERS_STK_TとTOPPERS_MPF_Tを，配
列のベースとなるデータ型にマクロ定義する．

5.5 ビットパターンのビット数

(5-5-1) TBIT_FLGPTN		イベントフラグのビット数（オプション）

TBIT_FLGPTNの標準の定義では，整数型の有効ビット数が，その型のsizeofに
CHAR_BITを乗じたものと一致していることを仮定している．多くのコンパイラ
でこの仮定が成り立つが，そうでない場合には，ターゲット依存部でこれらの
定義を上書きする必要がある．ただし，これらの値は16以上でなければならな
い．

5.6 メモリ領域確保のためのマクロ

(5-6-1) TOPPERS_ROUND_SZ（オプション）
(5-6-2) TOPPERS_COUNT_SZ（オプション）

TOPPERS_COUNT_SZ(sz, unit)は，sz/unitを切り上げた値を求めるマクロで，サ
イズがszのメモリ領域をサイズがunitのデータ型の配列で確保する場合の要素
数を求めるために用いる．TOPPERS_ROUND_SZ(sz, unit)は，sz/unitを切り上げ
たものにunitをかけた値を求めるマクロで，サイズがszのメモリ領域をサイズ
がunitのデータ型の配列で確保する場合のトータルサイズを求めるために用い
る．

それぞれ，標準のTOPPERS_ROUND_SZ，TOPPERS_COUNT_SZが適切でなく，ターゲッ
ト依存部で用意する場合には，これらのシンボルを適切な値にマクロ定義する．

5.7 オーバランハンドラ機能拡張のための定義（オプション）

オーバランハンドラ機能拡張パッケージをサポートする（使用できるようにす
る）場合には，次の3つを実施することが必要である．

・この節で説明する定義を行う．
・６章に示すコード中で，TOPPERS_SUPPORT_OVRHDRがマクロ定義されている場
　合にのみ有効となるコードを実装する．
・オーバランタイマドライバを用意する．オーバランタイマドライバについて
　は，「6.14 オーバランタイマドライバ」の節を参照すること．

(5-7-1) TOPPERS_TARGET_SUPPORT_OVRHDR

オーバランハンドラ機能拡張パッケージをサポートする場合には，このシンボ
ルをマクロ定義する．

(5-7-2) TMAX_OVRTIM（オプション，デフォルトはUINT32_MAX）

プロセッサ時間としてオーバランタイマに設定できる最大値（単位はマイクロ
秒）にマクロ定義する．


６．カーネル実装のターゲット依存部

【TOPPERS/ASP1カーネルとの関係】

ASP1カーネルでは，カーネル実装のターゲット依存部を構成する関数を，タス
クコンテキスト専用（t_で始まるもの），非タスクコンテキスト専用（i_で始
まるもの），いずれのコンテキストからでも呼び出すことができるもの（x_で
始まるもの）に分けていたが，ASP3カーネルでは分けないことにした．

6.1 カーネル実装のターゲット依存部の共通事項

カーネル実装のターゲット依存部は，以下の要素で構成される．

(a) カーネル実装のターゲット依存の定義

カーネル実装のターゲット非依存部から参照されるターゲット依存の定義は，
target_kernel_impl.hまたはそこからインクルードされるファイル（開発環境
依存部／プロセッサコア依存部／チップ依存部で用意されるヘッダファイルな
ど）に含める．

ターゲットのハードウェア資源（割込みハンドラ番号やCPU例外ハンドラ番号，
デバイスレジスタの番地など）の定義は，システムサービスやアプリケーショ
ンにも有用であるため，カーネル実装のみに有用な定義を含むファイルとは切
り分けて，独立したヘッダファイルに含める．このヘッダファイルの標準的な
名称を，システム略称.h（または，チップ略称.h，プロセッサ略称.h）とする．

(b) カーネル実装のターゲット依存モジュール

カーネル実装のターゲット依存の変数定義や関数を含むモジュール．C言語で記
述される部分をtarget_kernel_impl.c，アセンブリ言語で記述される部分を
target_support.Sに含める．開発環境依存部／プロセッサコア依存部／チップ
依存部を切り分けることや，ファイルが大きくなる場合に複数のファイルに分
割することも可能である．

(c) カーネル実装のターゲット依存部のためのリネーム記述

カーネル実装のターゲット依存部の変数名や関数名を，先頭に_kernel_を付与
した名前にリネームするためのモジュール．target_rename.defを用意し，ツー
ル（utils/genrename.rb）により，target_rename.hとtarget_unrename.hを生
成する．開発環境依存部／プロセッサコア依存部／チップ依存部を切り分ける
場合には，リネーム記述も切り分ける．

(d) タイマドライバ

カーネルがシステム時刻の更新に用いるため高分解能タイマを抽象化するため
の高分解能タイマドライバのヘッダファイル，実装ファイル，システムコンフィ
ギュレーションファイルを，それぞれ，target_timer.h，target_timer.c，
target_timer.cfgに含める．開発環境依存部／プロセッサコア依存部／チップ
依存部を切り分けることも可能である．

また，オーバランハンドラ機能拡張パッケージをサポートする場合には，オー
バランハンドラを起動するためのオーバランタイマドライバも用意する．

なお，この章に示すコード中で，TOPPERS_SUPPORT_OVRHDRがマクロ定義されて
いる場合にのみ有効となるコードは，オーバランハンドラ機能拡張パッケージ
をサポートしない場合には，実装する必要がない．

(e) コンフィギュレータ設定ファイル

コンフィギュレータの設定ファイルのターゲット依存部を，
target_sym.def（または，同等の役割を持つファイル），target_kernel.trb，
target_check.trbに用意する．コンフィギュレータ設定ファイルの記述方法に
ついては，７章で説明する．

6.2 トレースログ機能への対応

カーネルのトレースログ機能の中で，ディスパッチャ，割込みハンドラ，CPU例
外ハンドラの開始・終了のトレースログ取得は，ターゲット依存部で実装する
必要がある．ほとんどのターゲットシステムにおいて，これらの処理はアセン
ブリ言語で記述されており，ターゲット非依存部向けのトレースログマクロと
同じ方法（トレースログマクロを，トレースログ取得処理のC言語記述にマクロ
定義する方法）は，用いることができない．

そこで，これらのトレースログ取得については，対応するトレースログマクロ
が定義されていれば，（それが何に定義されているかは無視して）C言語で記
述されたトレースログ関数を呼び出す．具体的には，下の表の左側に示したト
レースログマクロが定義されていれば，表の右側に示したC言語関数を呼び出
すようにコーディングする．

	トレースログマクロ		トレースログ取得処理
	-----------------------------------------------
	LOG_DSP_ENTER			log_dsp_enter(p_runtsk)
	LOG_DSP_LEAVE			log_dsp_leave(p_runtsk)
	LOG_INH_ENTER			log_inh_enter(inhno)
	LOG_INH_LEAVE			log_inh_leave(inhno)
	LOG_EXC_ENTER			log_exc_enter(excno)
	LOG_EXC_LEAVE			log_exc_leave(excno)

6.3 システム状態の管理

ASP3カーネルを新たなターゲットシステムにポーティングする際に，最も重要
な作業は，カーネルが定義するシステム状態を，ハードウェア（プロセッサ）
上でどのように実現するかである．以下の説明は，TOPPERS新世代カーネルにお
けるシステム状態の定義・意味を知っていることを前提に記述している．

6.3.1 全割込みロック状態の管理

全割込みロック状態は，NMIを除くすべての割込みをマスクした状態である．全
割込みロック状態を管理する機能は，システムインタフェースレイヤ（SIL）に
よって提供され，カーネルは全割込みロック状態を管理しない．

全割込みロック状態では，sns_kerとext_ker以外のカーネルのサービスコール
を呼ぶことはできないものとしており，呼んだ場合には何が起こるか保証して
いない．sns_kerとext_kerから呼び出す処理は，トレースログ取得処理とSILの
サービスコールを除くと，call_exit_kernelのみである．そのため，
call_exit_kernelから呼び出すものを除いて，カーネルのターゲット依存部の
関数が，全割込みロック状態で呼び出される状況は考える必要がない．

6.3.2 コンテキストの管理

処理単位が実行されるコンテキストは，タスクコンテキストと非タスクコンテ
キストに分類される．

ターゲット依存部は，実行中の処理単位が，タスクコンテキストで実行されて
いるか非タスクコンテキストで実行されているかを判別する機能を提供する．
また，CPU例外が発生したコンテキストについて判別する機能を提供する．

ターゲット依存部では，割込みハンドラとCPU例外ハンドラの入口処理で非タス
クコンテキストに切り換え，それらの出口処理で元のコンテキストに戻す．

(6-3-2-1) bool_t sense_context(void)

実行中の処理単位が，タスクコンテキストで実行されている場合にはfalse，非
タスクコンテキストで実行されている場合にはtrueを返す関数．この関数は，
CPUロック状態でもCPUロック解除状態でも呼び出せるように実装しなければな
らない．

6.3.3 CPUロック状態の管理

ターゲット依存部は，CPUロック状態へ遷移する機能，CPUロック解除状態へ遷
移する機能，CPUロック状態であるかを判別する機能を提供する．

(6-3-3-1) void lock_cpu(void)

CPUロック解除状態から，CPUロック状態へ遷移させる関数．この関数は，CPUロッ
ク状態で呼び出されることはなく，呼び出された場合の動作は保証する必要が
ない．

この関数を実現する際には，「1.5 クリティカルセクションの出入処理の実現
に関する制約」の節に記述されている制約に従わなければならない．

(6-3-3-2) void lock_cpu_dsp(void)

タスクディスパッチできる状態において，CPUロック解除状態から，CPUロック
状態へ遷移させる関数．

この関数は，ディスパッチできる状態でのみ呼び出される．ディスパッチでき
る状態においては，割込み優先度マスク全解除状態であるため，プロセッサに
よっては，lock_cpuより効率的に実装できる場合がある．そうでない場合には，
lock_cpuに定義すればよい．

lock_cpu_dspによってCPUロック状態に遷移した後，unlock_cpuによってCPUロッ
ク状態を解除する場合がある．そのため，lock_cpuでCPUロック状態に遷移する
前の状態を変数に保存する場合には，lock_cpu_dspでもその変数を設定する必
要がある．

(6-3-3-3) void unlock_cpu(void)

CPUロック状態から，CPUロック解除状態へ遷移させる関数．この関数は，CPUロッ
ク解除状態で呼び出されることはなく，呼び出された場合の動作は保証する必
要がない．

タスクコンテキストでCPUロック状態に遷移した場合には，CPUロック解除状態
に戻るのはタスクコンテキストに限られ，非タスクコンテキストでCPUロック解
除状態に戻ることはない．同様に，非タスクコンテキストでCPUロック状態に遷
移した場合には，CPUロック解除状態に戻るのは非タスクコンテキストに限られ，
タスクコンテキストでCPUロック解除状態に戻ることはない．

この関数を実現する際には，「1.5 クリティカルセクションの出入処理の実現
に関する制約」の節に記述されている制約に従わなければならない．

この関数は，コンフィギュレータがkernel_cfg.cに生成する割込みハンドラか
ら呼び出される．そのため，インライン関数で定義する場合でも，リネーム記
述（target_rename.def）にリストアップする必要がある．

(6-3-3-4) void unlock_cpu_dsp(void)

タスクディスパッチできる状態に戻る状況において，CPUロック状態から，CPU
ロック解除状態へ遷移させる関数．

この関数は，CPUロック解除後は，ディスパッチできる状態に戻る状況でのみ呼
び出される．ディスパッチできる状態においては，割込み優先度マスク全解除
状態であるため，プロセッサによっては，unlock_cpuより効率的に実装できる
場合がある．そうでない場合には，unlock_cpuに定義すればよい．

(6-3-3-5) bool_t sense_lock(void)

現在のシステム状態が，CPUロック状態の場合はtrue，CPUロック解除状態の場
合にはfalseを返す関数．

この関数が全割込みロック状態で呼び出される状況は考える必要がないことか
ら，全割込みロック状態とCPUロック状態を区別できる必要はない．NMI以外に
カーネルの管理外の割込みを設けない場合には，全割込みロック状態とCPUロッ
ク状態が全く同一の状態でもかまわない．

この関数は，コンフィギュレータがkernel_cfg.cに生成する割込みハンドラか
ら呼び出される．そのため，インライン関数で定義する場合でも，リネーム記
述（target_rename.def）にリストアップする必要がある．

(6-3-3-6) void delay_for_interrupt(void)

割込みが受け付けられるように処理を遅延させる関数．

カーネル内で，CPUロック状態での実行が長くなる場合に，一時的にCPUロック
状態を解除して，割込みを受け付けるようにしている．この時，unlock_cpuと
lock_cpuをこの順で呼び出すが，この2つの関数を連続して呼び出すと，ターゲッ
トによっては割込みが受け付けられない場合がある．そこで，unlock_cpuと
lock_cpuを呼び出す間に，この関数（delay_for_interrupt）を呼び出す．2つ
の関数を連続して呼び出すと割込みが受け付けられないターゲットでは，この
関数により，割込みが受け付けられるように実装する．

6.4 割込みに関連するシステム状態の管理

割込み番号と割込みハンドラ番号はターゲット定義で付与されるため，それら
が有効な値かどうかを判断する機能は，ターゲット依存部で用意する必要があ
る．

(6-4-0-1) bool_t VALID_INTNO(INTNO intno)

intnoが，割込み番号として有効な値である場合にtrue，そうでない場合に
falseを返すマクロ．

VALID_INTNO_DISINT，VALID_INTNO_CLRINT，VALID_INTNO_RASINT，
VALID_INTNO_PRBINT，VALID_INTNO_CREISRを個別に定義し，ターゲット依存部
でもこのマクロを使用しない場合には，用意する必要がない．

(6-4-0-2) bool_t VALID_INHNO(INHNO inhno)（オプション）

inhnoが，割込みハンドラ番号として有効な値である場合にtrue，そうでない場
合にfalseを返すマクロ．なお，ASP3カーネルでは，割込みハンドラ番号を用い
るAPIは，DEF_INHのみである．

ASP3カーネルのターゲット非依存部では，このマクロは使われていないため，
ターゲット依存部でも使用しない場合には，用意する必要がない．

(6-4-0-3) bool_t check_intno_cfg(INTNO intno)

intnoで指定された割込み要求ラインの割込み属性が設定されている場合に
true，そうでない場合にfalseを返す関数．

この関数は，VALID_INTNO_DISINT(intno)，VALID_INTNO_CLRINT(intno)，
VALID_INTNO_RASINT(intno)，VALID_INTNO_PRBINT(intno)のいずれかがtrueと
なるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合の動作
は保証する必要がない．

6.4.1 割込み優先度マスクの管理

ターゲット依存部は，割込み優先度マスクを設定する機能と，割込み優先度マ
スクを参照する機能を提供する．

(6-4-1-1) bool_t VALID_INTPRI_CHGIPM(PRI intpri)（オプション）

intpriが，chg_ipmに対する割込み優先度として有効な値である場合にtrue，そ
うでない場合にfalseを返すマクロ．標準では，TMIN_INTPRI以上，TIPM_ENAALL
（＝0）以下の値がchg_ipmに対する割込み優先度として有効であるが，ターゲッ
ト依存部でこのマクロを定義することで，TMIN_INTPRIよりも小さい値を有効と
することができる（有効な値の範囲を狭めてはならない）．

(6-4-1-2) void t_set_ipm(PRI intpri)

割込み優先度マスクの値をintpriに設定する関数．

この関数は，ターゲット非依存部からは，タスクコンテキストで，CPUロック状
態の場合にのみ呼び出される．

また，この関数は，VALID_INTPRI_CHGIPM(intpri)がtrueを返すintpriに対して
のみ呼ばれる．intpriにそうでない値が渡された場合の動作は保証する必要が
ない．

(6-4-1-3) PRI t_get_ipm(void)

割込み優先度マスクの値を参照して返す関数．

この関数は，ターゲット非依存部からは，タスクコンテキストで，CPUロック状
態の場合にのみ呼び出される．

割込み優先度マスクを用いてカーネル管理の割込みをすべてマスクした状態は，
CPUロック状態と区別できることが必要である．具体的には，CPUロック解除状
態において，t_set_ipmを用いてカーネル管理の割込みをすべてマスクした場合
でも，sense_lockはfalseを返す．

それに対して，割込み優先度マスクを用いてNMIを除くすべての割込みをマスク
できる場合，その状態と全割込みロック状態を区別できる必要はなく，全く同
一の状態でもかまわない．

6.4.2 割込み要求禁止フラグの管理

ターゲット依存部は，割込み要求禁止フラグをセットする機能とクリアする機
能を提供する．

(6-4-2-1) bool_t VALID_INTNO_DISINT(INTNO intno)（オプション）

intnoが，dis_int／ena_intに対する割込み番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．割込み要求禁止フラグがセット／
クリアできないintnoに対しては，このマクロがfalseを返すようにする．

このマクロを定義しない場合，VALID_INTNOが使われる．VALID_INTNOで有効と
判断される割込み番号が，dis_int／ena_intに対して有効な割込み番号と一致
している場合，このマクロを用意する必要はない．

(6-4-2-2) void disable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをセット
する関数．

この関数は，VALID_INTNO_DISINT(intno)とcheck_intno_cfg(intno)の両方が
trueとなるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合
の動作は保証する必要がない．

dis_intサービスコールをサポートする場合（TOPPERS_SUPPORT_DIS_INTをマク
ロ定義する場合）には，disable_intを用意しなければならない．

(6-4-2-3) void enable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをクリア
する関数．

この関数は，VALID_INTNO_DISINT(intno)とcheck_intno_cfg(intno)の両方が
trueとなるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合
の動作は保証する必要がない．

ena_intサービスコールをサポートする場合（TOPPERS_SUPPORT_ENA_INTをマク
ロ定義する場合）には，enable_intを用意しなければならない．

6.4.3 割込み要求のクリア

(6-4-3-1) bool_t VALID_INTNO_CLRINT(INTNO intno)（オプション）

intnoが，clr_intに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．割込み要求をクリアできないintnoに対して
は，このマクロがfalseを返すようにする．

このマクロを定義しない場合，VALID_INTNOが使われる．VALID_INTNOで有効と
判断される割込み番号が，clr_intに対して有効な割込み番号と一致している
場合，このマクロを用意する必要はない．

(6-4-3-2) bool_t check_intno_clear(INTNO intno)

intnoで指定された割込み要求ラインに対して，割込み要求をクリアできる場
合にtrue，できない場合にfalseを返す関数．intnoで指定された割込み要求ラ
インがレベルトリガである場合で，ターゲット定義でエラーとする場合には，
この関数がfalseを返すようにする．

この関数は，VALID_INTNO_CLRINT(intno)とcheck_intno_cfg(intno)の両方が
trueとなるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合
の動作は保証する必要がない．

(6-4-3-3) void clear_int(INTNO intno)

intnoで指定された割込み要求ラインがエッジトリガである場合に，トリガさ
れた割込み要求をクリアする関数．intnoで指定された割込み要求ラインがレ
ベルトリガである場合の振る舞いは，ターゲット定義である．

この関数は，VALID_INTNO_CLRINT(intno)，check_intno_cfg(intno)，
check_intno_clearのすべてがtrueとなるintnoに対してのみ呼ばれる．intno
にそうでない値が渡された場合の動作は保証する必要がない．

clr_intサービスコールをサポートする場合（TOPPERS_SUPPORT_CLR_INTをマク
ロ定義する場合）には，check_intno_clearとclear_intを用意しなければなら
ない．

6.4.4 割込みの要求

(6-4-4-1) bool_t VALID_INTNO_RASINT(INTNO intno)（オプション）

intnoが，ras_intに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．割込みを要求できないintnoに対しては，こ
のマクロがfalseを返すようにする．

このマクロを定義しない場合，VALID_INTNOが使われる．VALID_INTNOで有効と
判断される割込み番号が，ras_intに対して有効な割込み番号と一致している
場合，このマクロを用意する必要はない．

(6-4-4-2) bool_t check_intno_raise(INTNO intno)

intnoで指定された割込み要求ラインに対して，割込みを要求できる場合に
true，できない場合にfalseを返す関数．intnoで指定された割込み要求ライン
がレベルトリガである場合で，ターゲット定義でエラーとする場合には，この
関数がfalseを返すようにする．

この関数は，VALID_INTNO_RASINT(intno)とcheck_intno_cfg(intno)の両方が
trueとなるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合
の動作は保証する必要がない．

(6-4-3-3) void raise_int(INTNO intno)

intnoで指定された割込み要求ラインがエッジトリガである場合に，その割込
み要求ラインに対して割込みを要求する関数．intnoで指定された割込み要求
ラインがレベルトリガである場合の振る舞いは，ターゲット定義である．

この関数は，VALID_INTNO_RASINT(intno)，check_intno_cfg(intno)，
check_intno_raiseのすべてがtrueとなるintnoに対してのみ呼ばれる．intno
にそうでない値が渡された場合の動作は保証する必要がない．

ras_intサービスコールをサポートする場合（TOPPERS_SUPPORT_RAS_INTをマク
ロ定義する場合）には，check_intno_raiseとraise_intを用意しなければなら
ない．

6.4.5 割込み要求のチェック

(6-4-5-1) bool_t VALID_INTNO_PRBINT(INTNO intno)（オプション）

intnoが，prb_intに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．割込み要求をチェックできないintnoに対し
ては，このマクロがfalseを返すようにする．

このマクロを定義しない場合，VALID_INTNOが使われる．VALID_INTNOで有効と
判断される割込み番号が，prb_intに対して有効な割込み番号と一致している
場合，このマクロを用意する必要はない．

(6-4-5-2) bool_t probe_int(INTNO intno)

intnoで指定された割込み要求ライン（対象割込み要求ライン）に対する割込
み要求の有無をチェックする関数．具体的には，対象割込み要求ラインがレベ
ルトリガである場合，割込み要求ラインが割込みを要求する状態である場合に
はtrue，そうでない場合にはfalseが返す．対象割込み要求ラインがエッジト
リガである場合，対象割込み要求ラインの割込み要求フラグがセットされてい
る場合にはtrue，そうでない場合にはfalseが返す．

この関数は，VALID_INTNO_CLRINT(intno)とcheck_intno_cfg(intno)の両方が
trueとなるintnoに対してのみ呼ばれる．intnoにそうでない値が渡された場合
の動作は保証する必要がない．

prb_intサービスコールをサポートする場合（TOPPERS_SUPPORT_PRB_INTをマク
ロ定義する場合）には，probe_intを用意しなければならない．

6.5 タスクディスパッチャ

6.5.1 タスクコンテキストブロックとタスク初期化コンテキストブロック

(6-5-1-1) TSKCTXB

ターゲット依存のタスクコンテキストを保存するために，TCB中に持つことが必
要なデータ構造の型を，TSKCTXBに定義する．標準的には，TSKCTXBには，タス
クのスタックポインタと実行再開番地を格納する．

(6-5-1-2) USE_TSKINICTXB（オプション）
(6-5-1-3) TSKINICTXB（オプション）

ターゲット依存の情報をタスク初期化ブロック（TINIB）に入れたい場合や，
TINIB中のスタック領域のサイズと先頭番地の持ち方をターゲット依存に変更し
たい場合には，USE_TSKINICTXBをマクロ定義し，TINIB中に持つことが必要なデー
タ構造の型を，TSKINICTXBに定義する．

USE_TSKINICTXBをマクロ定義すると，TINIB中にスタック領域とサイズと先頭番
地が含まれなくなるため，それに代わる情報をTSKINICTXB中に持つ必要がある．
また，コンフィギュレータのパス2の生成スクリプトのターゲット非依存部で，
TSKINICTXBの初期化情報を生成するためのGenerateTskinictxbを，パス3の生成
スクリプトのターゲット非依存部で，TINIBからスタック領域の先頭番地を取り
出すためのGetStackTskinictxbを定義する必要がある．

さらに，動的生成機能拡張パッケージをサポートする場合には，TSKINICTXBを
初期化するためのinit_tskinictxb関数と，タスクの削除時に呼び出される
term_tskinictxb関数を用意する必要がある．

6.5.2 ディスパッチャ本体

ディスパッチャ本体（dispatcher）は，ターゲット非依存部から直接呼び出さ
れることはなく，カーネルのターゲット依存部の内部からのみ呼び出される．

dispatcherは，タスクコンテキスト・CPUロック状態・割込み優先度マスク全解
除状態・ディスパッチ許可状態で呼び出される．

dispatcherの処理内容は次の通り．

----------------------------------------
void
dispatcher(void)
{
#ifdef LOG_DSP_ENTER
	log_dsp_enter(p_runtsk);
#endif /* LOG_DSP_ENTER */

  dispatcher_0:
	p_runtsk = p_schedtsk;
	if (p_runtsk != NULL) {
		自タスク（p_runtsk）のTCBからスタックポインタを復帰する
#ifdef LOG_DSP_LEAVE
		log_dsp_leave(p_runtsk);
#endif /* LOG_DSP_LEAVE */
		自タスクのTCBから実行再開番地を復帰し，そこへ分岐する … (*a)
	}

	/*
	 *  アイドル処理
	 */
	割込みを許可したらCPUロック解除状態になるよう準備する
	割込みをすべて許可する
	while (true) {
		割込み発生を待つ … (*b)
	}
}
----------------------------------------

(*b)において，割込み発生を待つ命令が用意されていない場合や，それを発行
するのが不都合な場合には，割込み発生を待つ処理を省き，ループによって割
込み発生を待つようにしても良い．なお，ここで発生したカーネル管理の割込
みからはリターンしてくることはないが，カーネル管理外の割込みからはリター
ンする場合があるため，ループを省くことはできない．

割込み待ちの間は，p_runtskをNULL（＝0）に設定しなければならない（上の処
理内容をそのまま実装すればこうなる）．このように設定しないと，割込みハ
ンドラからget_tidを呼び出した際の動作が仕様に合致しなくなる．

dispatcherをアセンブリ言語で記述する場合には，トレースログ取得処理は，
「6.2 トレースログ機能への対応」の節で記述した方法でコーディングするこ
と．なお，log_dsp_enterは切換え前のタスクのスタックで，log_dsp_leaveは
切換え後のタスクのスタックで実行する．

なお，dispatcherに分岐してきた時，スタックポインタは，最後に実行状態で
あったタスクのスタックを指している．ただし，カーネル動作開始直後にアイ
ドルになった時には，IDが1のタスクのスタックを指している．

【TOPPERS/ASP1カーネルとの関係】

アイドル処理の設計を一新した．詳しくは，「TOPPERS/ASP3カーネル 設計メ
モ」の「ディスパッチャ本体とアイドル処理」の節を参照すること．

6.5.3 自発的なディスパッチ

(6-5-3-1) void dispatch(void)

タスクコンテキストから呼ばれたサービスコール処理において，タスク切換え
が必要になった場合には，タスクからの自発的なディスパッチ処理（dispatch）
が呼び出される．

dispatchは，タスクコンテキスト・CPUロック状態・割込み優先度マスク全解除
状態・ディスパッチ許可状態で呼び出される．

dispatchの処理内容は次の通り．

----------------------------------------
void
dispatch(void)
{
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_stop();					/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	スクラッチレジスタ(*)を除くすべてのレジスタをスタックに保存する
	スタックポインタを自タスク（p_runtsk）のTCBに保存する
	dispatch_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	dispatcherに分岐する

  dispatch_r:
	スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
}
----------------------------------------

ここでスクラッチレジスタ(*)とは，関数呼出しにより保存されないレジスタの
ことである．必要な場合には，関数を呼び出す側で保存しなければならないた
め，caller saved registerと呼ばれる場合もある．

dispatchを呼び出したタスクが次に実行される時には，実行再開番地として登
録したdispatch_rに戻ってくる．dispatch_rには，dispatcherのみから分岐し，
その時の状態は，タスクコンテキスト・CPUロック状態・割込み優先度マスク全
解除状態・ディスパッチ許可状態である．

(6-5-3-2) void request_dispatch_retint(void)

非タスクコンテキストにおいてタスク切換えが必要になった場合には，非タス
クコンテキストからの自発的なディスパッチ要求（request_dispatch_retint）
が呼び出される．

割込みハンドラの出入口処理を，標準通りに実装する（dispatchを明示的に呼
び出す）場合には，request_dispatch_retintでは何もする必要がない．

6.5.4 ディスパッチャの動作開始

(6-5-4-1) void start_dispatch(void)

ディスパッチャの動作開始処理（start_dispatch）は，カーネル起動時に，カー
ネルの初期化処理から呼び出される．start_dispatchは，リターンすることの
ない関数である．

start_dispatchは，非タスクコンテキストで，NMIを除くすべての割込みをマス
クした状態（全割込みロック状態と同等の状態）で呼び出される．
start_dispatch内で，タスクコンテキストに切り換え，CPUロック状態・割込み
優先度マスク全解除状態にしなければならない．また，スタックを，IDが1のタ
スクのスタック領域に切り換える．

start_dispatchの処理内容は次の通り．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
	スタックをIDが1のタスクのスタック領域に切り換える
	CPUロック状態・割込み優先度マスク全解除状態にする
	dispatcher_0に分岐する
}
----------------------------------------

6.5.5 現在のコンテキストを捨ててディスパッチ

(6-5-5-1) void exit_and_dispatch(void)

自タスクを終了させるサービス処理からは，現在のコンテキストを捨ててディ
スパッチする処理（exit_and_dispatch）が呼び出される．exit_and_dispatch
は，リターンすることのない関数である．

exit_and_dispatchは，タスクコンテキスト・CPUロック状態・割込み優先度マ
スク全解除状態・ディスパッチ許可状態で呼び出される．

exit_and_dispatchの処理内容は次の通り．

----------------------------------------
void
exit_and_dispatch(void)
{
	dispatcherに分岐する
}
----------------------------------------

6.5.6 タスクの起動準備

(6-5-6-1) void activate_context(TCB *p_tcb)

タスクの起動準備処理（activate_context）は，タスクを休止状態から実行で
きる状態にする時に呼ばれ，p_tcbで指定されたタスク（対象タスク）のTCB中
のスタックポインタを初期化し，実行再開番地をタスク開始時処理（start_r）
に設定する．この時点では，後述する理由で，対象タスクのスタック領域を使っ
てはならない．

対象タスクが最初に実行される時には，対象タスクを自タスクとして，実行再
開番地として登録したstart_rに分岐してくる．start_rには，dispatcherのみ
から分岐し，その時の状態は，タスクコンテキスト・CPUロック状態・割込み優
先度マスク全解除状態・ディスパッチ許可状態である．

start_rは，CPUロック状態を解除した後，タスクの起動番地を呼び出す．さら
に，タスクの起動番地から戻ってきた場合には，ext_tskを呼び出す．

activate_contextとstart_rの処理内容は次の通り．

----------------------------------------
void
activate_context(TCB *p_tcb)
{
	指定されたタスク（p_tcb）のTCB中のスタックポインタを初期化する
	start_rを，実行再開番地として自タスクのTCBに保存する … (*a)
	return;

  start_r:
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_start();					/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	CPUロック解除状態にする
	自タスク（p_runtsk）の起動番地を，拡張情報をパラメータとして呼び出す
	ext_tskに分岐する ... (*c)
}
----------------------------------------

(*c)でext_tskを呼ぶ代わりに，自タスクの起動番地を呼び出す時の返り番地を
ext_tskの番地としておく方法がある．

ここで，タスクの起動処理において対象タスクのスタック領域を使ってはなら
ない理由は，次の通り．制約タスク拡張パッケージにおいて，複数の制約タス
クがスタック領域を共有している場合に，タスクの起動時点では，そのタスク
とスタック領域を共有しているタスクが，スタック領域を使用している可能性
があるためである．

このポーティングガイドでは，タスクの実行再開番地をTCBに保存している
(*a)．これをスタックに保存する方法も考えられるが，タスクの起動処理でス
タック領域が使えないことから，タスクの起動処理だけは例外扱いしなければ
ならない．例えば，タスクの起動処理においてはTCB中のスタックポインタを特
殊な値（例えば0）に設定しておき，ディスパッチャ本体でTCB中のスタックポ
インタがその値の場合にはstart_rに分岐させ，start_rにおいてスタックポイ
ンタを初期化する方法が考えられる．

6.6 割込みハンドラ

6.6.1 割込みハンドラの出入口処理

カーネル管理の割込みハンドラの出入口処理は，以下の擬似コードと等価にな
るように実装する．処理内容が等価であれば，処理順序を変更してもかまわな
い．

プロセッサによっては，擬似コードに含まれる処理がハードウェアで実現され
ている場合もあるが，そのような処理はソフトウェアで行う必要はない．

擬似コード中で，「少なくともカーネル管理の割込みを禁止した状態」とは，
カーネル内部で用いる一時的な状態であり，この状態のままでカーネル外に出
ることはない．そのため，この状態では，CPUロック状態であると識別できなく
てもよい．例えば，CPUロック状態であることを示す変数を用意している場合に
は，この状態ではその変数をCPUロック状態を示す値に変更する必要はない．ま
た，この状態では，カーネル管理外の割込み（の一部）が禁止されていてもよ
い．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともカーネル管理の割込みを禁止した状態にする … (*d)
	スクラッチレジスタをスタックに保存する … (*p)
	if (割込みがタスクコンテキストで発生) {
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_stop();				/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
	割込み優先度マスクを，受け付けた割込みの割込み優先度に設定する
	割込みハンドラの入口で必要なIRCの操作を行う（割込み要求ラインがエッ
				ジトリガである場合のトリガされた割込み要求のクリアなど）
	CPUロック解除状態にする（受け付けた割込みよりも優先度の高い割込みを
												受け付けるようにする）

#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
	割込みハンドラを呼び出す
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */

	少なくともカーネル管理の割込みを禁止した状態にする
	割込みハンドラの出口で必要なIRCの操作を行う（IRCに対する割込み処理
														の終了通知など）
	割込み優先度マスクを，割込みを受け付ける前の値に戻す … (*f)

	if (割込みがタスクコンテキストで発生) {
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																… (*g)
		if (p_runtsk == NULL) {
			タスクのスタックに保存したスクラッチレジスタ等を捨てる … (*o)
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
			dispatcher_0に分岐する
		}

		if (p_runtsk != p_schedtsk) {
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
			スクラッチレジスタを除くすべてのレジスタをスタックに保存する
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する … (*a)
			dispatcherに分岐する

		  ret_int_r:
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
		}
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();				/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	}
	割込み処理からのリターンにより，CPUロック解除状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する … (*p)
	割込み処理からのリターン
}
----------------------------------------

(*p)においてスクラッチレジスタを保存／復帰するスタックは，割込みがタス
クコンテキストで発生した場合にはタスクのスタック，非タスクコンテキスト
で発生した場合には非タスクコンテキスト用のスタックである．

割込みの受付けにより割込みが禁止されないプロセッサでは，(*d)において，
少なくともカーネル管理の割込みを禁止する．これは，ovrtimer_stopやスタッ
クを切り換える処理等において，カーネルの内部変数をアクセスする（場合が
ある）ため，それらに対する排他制御が必要なためである．オーバランタイマ
をサポートせず，その他の処理でもカーネルの内部変数をアクセスしない場合
には，(*d)を省略できる場合がある．

ただし，ハードウェアによりスタックポインタを切り換える機能がないプロセッ
サでは，割込みハンドラの入口処理のできる限り早いタイミングで，カーネル
管理外の割込みも含めて，すべての割込みを禁止するのが望ましい．詳しくは，
「多重割込みとスタック」の項を参照すること．

割込みの受付けにより割込みが禁止されないプロセッサでは，(*e)の処理を，
if文の手前で（つまり，割込みが発生したコンテキストに依らずに）行うべき
である．これは，(*d)において割込みを禁止する前に多重割込みが受け付けら
れた場合に，その割込み処理の間もオーバランタイマの動作を止めておくため
に必要である．なお，ovrtimer_stopは，オーバランタイマが動作していない時
は何も行わないため，過剰に呼び出しても差し支えない．

(*f)において，割込み優先度マスクを割込みを受け付ける前の値に戻す処理は，
割込み処理からリターンするまでに行えばよい．割込み処理からのリターンに
より割込み優先度マスクを元に戻す機能がある場合には，それに委ねてもよい．
ただし，そのようにした場合には，(*i)において，割込み優先度マスクは全解
除状態（TIPM_ENAALL）にする処理を行う必要がある．

(*g)においてタスクコンテキストに切り換える処理は，割込み処理からのリター
ンによりスタックとコンテキストが元に戻るプロセッサでは，dispatcherに分
岐する場合にのみ行えばよい．dispatcherに分岐しない場合には，非タスクコ
ンテキストのまま処理を続け，割込み処理からのリターンでタスクコンテキス
トに戻ることになる．

アイドル処理中に割込みが発生した場合，(*g)においてスタックを戻す先は，
アイドル処理が使っていたスタック（すなわち，最後に実行状態であったタス
クのシステムスタック）になる．

(*o)の処理では，タスクのスタックに保存したスクラッチレジスタ等を捨て，
スタックポインタを割込み発生前の状態に戻す．これは，アイドル処理中に割
込みが発生し，その割込み処理中でいずれのタスクも実行できる状態にならず，
再度アイドル処理に分岐してくるまでの間に，スタック領域が消費されないよ
うにするためである．詳しくは，「TOPPERS/ASP3カーネル 設計メモ」の「ディ
スパッチャ本体とアイドル処理」の節を参照すること．

(*h)においてCPUロック状態にするのは，dispatcherに分岐する際に，CPUロッ
ク状態になっている必要があるためである．

(*i)の処理に到達するのは，割込み処理前に割込み優先度マスクが全解除状態
（TIPM_ENAALL）であった場合に限られるため，(*f)において割込み優先度マス
クを割込みを受け付ける前の値に戻していれば，ここでは何もしなくても良い．
ただし，割込み優先度マスクを戻す処理を後で行う場合には，(*i)において，
割込み優先度マスクを全解除状態に設定しなければならない．なお，ここで割
込み優先度マスクが全解除状態になっていなければならないのは，dispatcher
に分岐する際には，割込み優先度マスク全解除状態になっている必要があるた
めである．

タスクの実行中に割込みが発生し，割込みからの出口処理中でdispatcherに分
岐した場合，そのタスクが次に実行される時には，実行再開番地として登録し
たret_int_rに戻ってくる．ret_int_rには，dispatcherのみから分岐し，その
時の状態は，タスクコンテキスト・CPUロック状態・割込み優先度マスク全解除
状態・ディスパッチ許可状態である．

割込みの出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.2 トレースログ機能への対応」の節で記述した方法でコーディン
グすること．

〔多重割込みとスタック〕

ハードウェアによりスタックポインタを切り換える機能がないプロセッサでは，
割込みの入口処理において，非タスクコンテキスト用のスタックに切り換える
前に多重割込みを受け付けると，タスクのスタック領域が使用される．そのた
め，各タスクのスタック領域を確保する際に，ここで受け付ける割込みが使用
するスタックを見込んで確保しなければならない．

各タスクのスタック領域をなるべく小さくするためには，スタックをなるべく
使用しない内に，カーネル管理外の割込みも含めて，多重割込みを禁止するの
が望ましい．一方で，カーネル管理外の割込みの禁止時間が長くなると，カー
ネル管理外の割込みの応答性が低下するため，ユーザに注意を促す必要がある．

特に，割込みの受付により割込みが禁止されず，ハードウェアによりスタック
ポインタを切り換える機能がないプロセッサでは，次の点に注意が必要である．

このようなプロセッサでは，非タスクコンテキスト用のスタックに切り換える
前に，最大で割込み優先度の段数分の多重割込みが発生することを防ぐことは
できず，各タスクのスタック領域をその分を見込んで確保しなければならない．
そこで，スタックをなるべく使用しない内に多重割込みを禁止するために，ス
クラッチレジスタをスタックに保存する前に，すべての割込みを禁止するのが
望ましい．ただし，割込みの禁止処理に必要な最低限のレジスタについては，
割込みの禁止に先立ってスタックに保存する必要がある．

カーネルの管轄外ではあるが，カーネル管理外の割込み処理においても，非タ
スクコンテキスト用のスタック（または，カーネル管理外の割込み処理用のス
タック）に切り換えることが望ましい．

【TOPPERS/ASP1カーネルとの関係】

擬似コードの構成を見直した（擬似コードで想定しているプロセッサのタイプ
を変えた）．

reqflgを廃止した．また，p_schedtskの意味を変更した（割込み優先度マスク
全解除でない状態の間とディスパッチ禁止状態の間は，p_schedtskを更新しな
いことにした）ことにより，タスク切換えの条件判定で，dspflgをチェックす
る必要がなくなった．

アイドル処理の設計を変更したため，割込みハンドラの出口処理において，
p_runtskがNULLとなっている状況を考える必要が生じた．

6.6.2 割込みハンドラ毎の出入口処理の生成

割込みベクトルをハードウェアで実現している場合など，割込みハンドラ毎に
出入口処理を用意した方が効率が良いプロセッサのために，割込みハンドラ毎
に出入口処理を生成する機構を用意している．

以下のマクロは，標準の割込み管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．割込み管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-6-2-1) INT_ENTRY(inhno, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理のラベルを作るマクロ．INTHDR_ENTRYを用いて割込みハン
ドラ毎に出入口処理を生成する場合には，次のように定義する．

#define INT_ENTRY(inhno, inthdr)	_kernel_##inthdr##_##inhno

割込みハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，割込みハンドラの関数名をそのまま返す．

#define INT_ENTRY(inhno, inthdr)	inthdr

(6-6-2-2) INTHDR_ENTRY(inhno, inhno_num, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理を生成するマクロ．inhno_numには，アセンブリ言語記述用
に，割込みハンドラ番号が数値で渡される．割込みハンドラ毎に出入口処理を
作る必要がない場合には，空に定義する．

6.6.3 割込みハンドラの設定

(6-6-3-1) void define_inh(INHNO inhno, FP int_entry)

inhnoで指定された割込みハンドラの出入口処理の番地をint_entryに設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

指定された割込みハンドラ番号がDEF_INHに対するものとして有効な値でない場
合の動作は保証する必要がない（assertでエラーとするのが望ましい）．これ
は，コンフィギュレータが，パス2の生成スクリプトのターゲット依存部で定義
する$INHNO_VALIDを用いてエラーを検出するためである．

6.6.4 割込み要求ラインの属性の設定

(6-6-4-1) void config_int(INTNO intno, ATR intatr, PRI intpri)

intnoで指定された割込み要求ラインの割込み属性を，intatrで指定された通り
に設定する．また，割込み優先度を，intpriで指定された値に設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

intatrとして設定できる割込み属性は次の通り．

	TA_ENAINT		0x01	割込み要求禁止フラグをクリア
	TA_EDGE			0x02	エッジトリガ

この他に，ターゲット定義で割込み属性を追加してもよい．ターゲット定義で
追加するために，以下の属性名が予約されている．

	TA_POSEDGE				ポジティブエッジトリガ
	TA_NEGEDGE				ネガティブエッジトリガ
	TA_BOTHEDGE				両エッジトリガ
	TA_LOWLEVEL				ローレベルトリガ
	TA_HIGHLEVEL			ハイレベルトリガ

これらの属性名をターゲット定義で追加する場合には，その属性値を決定し，
定義をtarget_kernel.h（または，そこからインクルードされるファイル）に含
める．また，コンフィギュレータの生成スクリプトから参照できるように，
target_sym.def（または，同等の役割を持つファイル）に含める．さらに，コ
ンフィギュレータの生成スクリプトのターゲット非依存部でエラーとならない
ように，target_kernel.h（または，そこからインクルードされるファイル）で
TARGET_INTATRを定義する．

指定された割込み番号が有効な値でない場合や，その割込み要求ラインに対し
て設定できない属性を指定した場合，設定できない割込み優先度を指定した場
合の動作は保証する必要がない（assertでエラーとするのが望ましい）．この
ようなケースは，コンフィギュレータでエラーを検出すべきである．コンフィ
ギュレータの生成スクリプトのターゲット非依存部は，生成スクリプトのター
ゲット依存部で定義する$INTNO_CFGINT_VALID，$INTPRI_CFGINT_VALIDと，ター
ゲット依存部のヘッダファイルで定義するTARGET_INTATRを用いてエラーを検出
するが，標準の割込み属性（TA_ENAINT，TA_EDGE）が設定できない場合や，設
定できない属性や割込み優先度が割込み要求ラインによって異なる場合には，
生成スクリプトのターゲット依存部で検出しなければならない．

6.6.5 割込み管理機能の初期化処理の変更

(6-6-5-1) OMIT_INITIALIZE_INTERRUPT（オプション）

割込み管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義すると，INHINIB，INTINIB，initialize_interrupt
の定義が，カーネルのターゲット非依存部から取り除かれる．また，
TNUM_DEF_INHNO，tnum_def_inhno，inhinib_table，TNUM_CFG_INTNO，
tnum_cfg_intno，intinib_tableの定義と，割込みハンドラ毎の出入口処理を生
成するための記述（INTHDR_ENTRYマクロのリスト）が，コンフィギュレータの
パス2の生成スクリプトのターゲット非依存部によってkernel_cfg.cに生成され
なくなる．

(6-6-5-2) void initialize_interrupt(void)（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_INTERRUPTをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

(6-6-5-3) USE_INHINIB_TABLE（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義したが，割込みハンドラの初期化に必
要な情報をkernel_cfg.cに生成したい場合には，このシンボルをマクロ定義す
る．

このシンボルをマクロ定義すると，INHINIBの定義が，カーネルのターゲット非
依存部から取り除かれない．また，TNUM_DEF_INHNO，tnum_def_inhno，
inhinib_tableの定義と，割込みハンドラ毎の出入口処理を生成するための記述
（INTHDR_ENTRYマクロのリスト）が，ターゲット非依存部によって生成される．

(6-6-5-4) USE_INTINIB_TABLE（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義したが，割込み要求ラインの初期化に
必要な情報をkernel_cfg.cに生成したい場合には，このシンボルをマクロ定義
する．

このシンボルをマクロ定義すると，INTINIBの定義が，カーネルのターゲット非
依存部から取り除かれない．また，TNUM_CFG_INTNO，tnum_cfg_intno，
intinib_tableの定義が，ターゲット非依存部によって生成される．

6.6.6 デフォルトの割込みハンドラ

(6-6-6-1) void default_int_handler(void)（オプション）

コンフィギュレータにより割込みハンドラのテーブルを生成する場合などには，
割込みハンドラを登録しなかった割込みハンドラ番号に対して，デフォルトの
割込みハンドラとして，default_int_handlerを登録する．

default_int_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_INT_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_int_handlerとなる．

6.6.7 カーネル管理外の割込み

カーネル管理外の割込みハンドラは，カーネル内の割込み出入口処理を経由せ
ずに実行するのが基本である．

ただし，すべての割込みで同じアドレスに分岐するプロセッサでは，カーネル
内の割込み出入口処理を全く経由せずにカーネル管理外の割込みハンドラを実
行することができないため，割込み出入口処理のなるべく早いタイミングで，
カーネル管理外の割込みであるかを判別し，処理内容を分ける必要がある．具
体的には，カーネル管理外の割込みの出入口処理では，オーバランハンドラの
停止と動作開始を行ってはならない．また，タスク切換えを行う必要がない．
さらに，NMIの出入口処理では，トレースログ取得処理（log_inh_enterおよび
log_inh_leave）を呼び出してはならない．

カーネル管理外の割込みハンドラを実行する際に，カーネル内の割込み出入口
処理の一部分を経由する場合には，CPU例外が起こる可能性を極力減らすととも
に，CPU例外を起こす可能性がある場合には，その可能性をターゲット依存部の
ユーザーズマニュアルに記載しなければならない．

次に，カーネル管理外の割込みの設定方法に関して，「TOPPERS第3世代カーネ
ル（ITRON系）統合仕様書」の「2.7.8 カーネル管理外の割込みの設定方法」
の節の3つの方法のいずれを採用するかを決定する．

(a-1)または(a-2)を採用し，カーネル管理外とした割込みに対して，カーネル
のAPIによる割込みハンドラの登録と割込み要求ラインの属性の設定をサポート
しない場合には，それに代わる方法をターゲット依存部のユーザーズマニュア
ルに記述する．

(a-1)または(a-2)を採用してカーネルのAPIによる割込みハンドラの登録や割込
み要求ラインの属性の設定をサポートする場合や，(b)を採用した場合には，ター
ゲット依存部においてそれを実現する必要がある．

カーネル管理外の割込みに対して，DEF_INHによる割込みハンドラの登録をサポー
トするには，次の設定が必要になる．

・TARGET_INHATRに，TA_NONKERNELを設定する．

・(a-1)または(a-2)を採用した場合には，$INHNO_VALIDに，カーネル管理外と
　した割込みに対応する割込みハンドラ番号を含める．また，VALID_INHNOを，
　カーネル管理外とした割込みハンドラ番号を有効な値と判定するようにする．

・(a-1)または(a-2)を採用した場合には，$INHNO_FIX_KERNELにカーネル管理と
　した割込みハンドラ番号のリストを，$INHNO_FIX_NONKERNELにカーネル管理
　外とした割込みハンドラ番号のリスト設定する．

・DEF_INHがカーネル管理外の割込みに対応できるようにする．標準の割込み管
　理機能の初期化処理を用いる場合には，define_inhをカーネル管理外の割込
　みに対応させる．

・必要な場合には，TA_NONKERNEL属性が設定された割込みハンドラをカーネル
　管理外と扱うように，カーネル内の割込み出入口処理を修正する．標準の割
　込み管理機能の初期化処理を用いる場合，カーネル管理外の割込みに対して
　は，カーネル内の割込み出入口処理を生成せず，アプリケーションが登録し
　た割込みハンドラを直接呼び出すように，ターゲット非依存部により設定さ
　れるため，ターゲット依存部では対応する必要がない．

カーネル管理外の割込みに対して，CFG_INTによる割込み要求ラインの属性の設
定をサポートするには，次の設定が必要になる．

・(a-1)または(a-2)を採用した場合には，$INTNO_CFGINT_VALIDに，カーネル管
　理外とした割込みに対応する割込み番号を含める．また，VALID_INTNOを，カー
　ネル管理外とした割込み番号を有効な値と判定するようにする．必要であれ
　ば，VALID_INTNO_DISINTとVALID_INTNO_CREISRの定義を追加または変更する．

・(a-1)または(a-2)を採用した場合には，$INTNO_FIX_KERNELにカーネル管理と
　した割込み番号のリストを，$INTNO_FIX_NONKERNELにカーネル管理外とした
　割込み番号のリスト設定する．

・$INTPRI_CFGINT_VALIDに，カーネル管理外の割込みとなる優先度を含める．

・CFG_INTがカーネル管理外の割込みに対応できるようにする．標準の割込み管
　理機能の初期化処理を用いる場合には，config_intをカーネル管理外の割込
　みに対応させる．

chg_ipmにより，（NMI以外の）カーネル管理外の割込みをマスクできるように
する場合には，次の設定が必要になる．

・VALID_INTPRI_CHGIPMを，カーネル管理外の割込みとなる優先度を有効な値と
　判定するようにする．

・t_set_ipmを，カーネル管理外の割込みとなる優先度を扱えるようにする．

6.6.8 割込みサービスルーチンの生成

(6-6-8-1) bool_t VALID_INTNO_CREISR(INTNO intno)（オプション）

intnoが，acre_isrに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．動的生成機能拡張パッケージを使用しない場
合には，定義する必要がない．

このマクロを定義しない場合，VALID_INTNOが使われる．VALID_INTNOで有効と
判断される割込み番号が，acre_isrに対して有効な割込み番号と一致している
場合，このマクロを用意する必要はない．

6.7 CPU例外ハンドラとCPU例外発生時のシステム状態の参照

6.7.1 CPU例外ハンドラの出入口処理

CPU例外ハンドラの出入口処理は，以下の擬似コードと等価になるように実装す
る．処理内容が等価であれば，処理順序を変更してもかまわない．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する … (*p)
	CPU例外が発生した状況を判断するための追加情報をスタックに保存する … (*j)
	この時点でのスタックポインタ±nを，CPU例外の情報を記憶している領域の
										先頭番地とする（必要なら保存する）
	if (カーネル管理外のCPU例外) {
		if (CPU例外がタスクコンテキストで発生) {
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える … (*k)
		}
		割込みの禁止に関する状態（どの割込みを禁止しているか）を，
											CPU例外発生時の状態にする
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，
									タスクコンテキストに切り換える … (*k)
		}
		CPU例外処理からのリターン後に，CPU例外発生時のシステム状態に
													戻るように準備する
	}
	else {
		if (CPU例外がタスクコンテキストで発生) {
			少なくともカーネル管理の割込みを禁止した状態にする
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_stop();			/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える
		}
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*l)
		CPUロック解除状態にする（CPU例外発生時の割込み優先度マスクよりも
							優先度の高い割込みを受け付けるようにする）

#ifdef LOG_EXC_ENTER
		log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
#ifdef LOG_EXC_LEAVE
		log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */

		少なくともカーネル管理の割込みを禁止した状態にする … (*m)
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*n)

		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																	… (*g)
			if (p_runtsk == NULL) {									… (*q)
				タスクのスタックに保存したスクラッチレジスタ，追加
													情報等を捨てる … (*o)
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
				dispatcher_0に分岐する
			}

			if (p_runtsk != p_schedtsk) {
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_exc_rを，実行再開番地として自タスクのTCBに保存する … (*a)
				dispatcherに分岐する

			  ret_exc_r:
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	CPU例外が発生した状況を判断するための追加情報をスタック上から捨てる
	スクラッチレジスタをスタックから復帰する … (*p)
	CPU例外処理からのリターン
}
----------------------------------------

CPU例外ハンドラは，非コンテキストに切り換えることを除いては，CPU例外発
生時と同じシステム状態で呼び出さなければならない．例えば，CPU例外がCPU
ロック状態で発生した場合にはCPUロック状態，CPUロック解除状態で発生した
場合にはCPUロック解除状態で，CPU例外ハンドラを呼び出さなければならない．
CPUロック状態で発生したCPU例外は，カーネル管理外のCPU例外となるため，カー
ネル管理のCPU例外ハンドラについては，CPUロック解除状態で呼び出すことに
なる．

(*j)では，CPU例外ハンドラの中（および，そこから呼び出されたxsns_dpn）で
は，CPU例外が発生した状況を判断するために必要となる追加情報をスタックに
保存する．追加情報が必要ない場合は，(*j)の処理は必要ない．

プロセッサによっては，カーネル管理外のCPU例外を正確に判定するのが難しい
場合がある．このような場合には，割込み優先度マスクが全解除でない状態で
発生したCPU例外を，カーネル管理外のCPU例外と扱ってもよい．これは，割込
み優先度マスクが全解除でない場合にはxsns_dpnがtrueを返すため，カーネル
機能を用いたリカバリができないためである．

具体的には，全割込みロック（またはCPUロック）を小さいオーバヘッドで実現
しようとすると，CPU例外ハンドラの中で，全割込みロック状態（またはCPUロッ
ク状態）と割込み優先度マスクを高いレベルに設定した状態を区別できない場
合がある．また，カーネル管理外の割込み処理中やカーネル実行中であること
を正確に判断することも難しい場合がある．

カーネル管理外のCPU例外の場合に，(*k)において，スタックを非タスクコンテ
キスト用のスタックに切り換え，非タスクコンテキストに切り換えているが，
この切換えはターゲット定義で省いても良い．これは，カーネル管理外のCPU例
外は，カーネル内のクリティカルセクション中で発生する可能性があるため，
安全に切り換えられるとは限らないためである．また，カーネル管理外の割込
みハンドラを呼ぶ時のコンテキストやスタックはターゲット依存なので，カー
ネル管理外のCPU例外ハンドラもそれと同様に扱って良いと考えられるためであ
る．

上の擬似コードでは，カーネル管理外のCPU例外に対して，トレースログ取得処
理（log_exc_enterおよびlog_exc_leave）を呼び出していないが，全割込みロッ
ク状態かNMIの処理中にCPU例外が発生した場合を除外すれば，呼び出してもか
まわない．全割込みロック状態かNMIの処理中に発生したCPU例外の場合には，
トレースログ取得処理を呼び出してはならない．

(*l)の処理は，CPU例外の発生／受付により，割込み優先度マスクが変化しない
プロセッサでは省いてもよい．それに対して(*n)の処理は，CPU例外ハンドラ中
で割込み優先度マスクが変更された場合に対応するためのものなので，省くこ
とはできない．

(*m)の処理は，プロセッサによっては，CPU例外がタスクコンテキストで発生し
た時のみに行ってもよい場合がある．

(*q)に到達するのは，カーネル管理外のCPU例外でなく，CPU例外がタスクコン
テキストで発生した場合である．そのため，(*q)の条件が成立するのは，アイ
ドル処理においてCPU例外が発生し，それがカーネル管理外のCPU例外とみなさ
れない場合に限られる．アイドル処理の本体はカーネル内の処理であるため，
CPU例外が発生することは考えにくいが，カーネル管理外のCPU例外であること
や，CPU例外がタスクコンテキストで発生したことの判定方法はターゲットに
よって異なるため，念のため，(*q)の条件が成立した場合の処理が入れてある．
ターゲットによって，(*q)の条件が成立する可能性がない場合には，この処理
を省いても差し支えない．

CPU例外ハンドラを実行する際に経由する部分では，CPU例外が起こる可能性を
極力減らすとともに，CPU例外を起こす可能性がある場合（例えば，スクラッチ
レジスタをスタックに保存する時に，バスエラーなどのCPU例外が発生する可能
性が考えられる）には，その可能性をターゲット依存部のユーザーズマニュア
ルに記載しなければならない．

CPU例外ハンドラの出口処理は，割込みハンドラの出口処理と共通部分が多いた
め，プロセッサによっては，共通のルーチンを用いることができる可能性があ
る．

CPU例外の出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.2 トレースログ機能への対応」の節で記述した方法でコーディン
グすること．

【TOPPERS/ASP1カーネルとの関係】

擬似コードの構成を見直した（擬似コードで想定しているプロセッサのタイプ
を変えた）．

reqflgを廃止した．また，タスク切換えの条件判定で，dspflgをチェックする
必要がなくなった．

アイドル処理の設計を変更したため，CPU例外ハンドラの出口処理において，
p_runtskがNULLとなっている状況を考える必要が生じた．

6.7.2 CPU例外ハンドラの出入口処理の生成

CPU例外ベクトルをハードウェアで実現している場合など，CPU例外ハンドラ毎
に出入口処理を用意した方が効率が良いターゲットのために，CPU例外ハンドラ
毎に出入口処理を生成する機構を用意している．

以下のマクロは，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．CPU例外管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-7-2-1) EXC_ENTRY(excno, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理のラベルを作るマクロ．EXCHDR_ENTRYを用いてCPU例外
ハンドラ毎に出入口処理を生成する場合には，次のように定義する．

#define EXC_ENTRY(excno, exchdr)	_kernel_##exchdr##_##excno

CPU例外ハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，CPU例外ハンドラの関数名をそのまま返す．

#define EXC_ENTRY(excno, exchdr)	exchdr

(6-7-2-2) EXCHDR_ENTRY(excno, excno_num, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理を生成するマクロ．excno_numには，アセンブリ言語記
述用に，CPU例外ハンドラ番号が数値で渡される．CPU例外ハンドラ毎に出入口
処理を作る必要がない場合には，空に定義する．

6.7.3 CPU例外ハンドラの設定

(6-7-3-1) bool_t VALID_EXCNO(EXCNO excno)（オプション）

excnoが，CPU例外ハンドラ番号として有効な値である場合にtrue，そうでない
場合にfalseを返すマクロ．なお，ASP3カーネルでは，CPU例外ハンドラ番号を
用いるAPIは，DEF_EXCのみである．

ASP3カーネルのターゲット非依存部では，このマクロは使われていないため，
ターゲット依存部で使わないなら，用意する必要がない．

(6-7-3-2) void define_exc(EXCNO excno, FP exc_entry)

excnoで指定されたCPU例外ハンドラの出入口処理の番地をexc_entryに設定する．

この関数は，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．CPU例外管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

指定されたCPU例外ハンドラ番号がDEF_EXCに対するものとして有効な値でない
場合の動作は保証する必要がない（assertでエラーとするのが望ましい）．こ
れは，コンフィギュレータが，パス2の生成スクリプトのターゲット依存部で定
義する$EXCNO_VALIDを用いてエラーを検出するためである．

6.7.4 CPU例外管理機能の初期化処理の変更

(6-7-4-1) OMIT_INITIALIZE_EXCEPTION（オプション）

CPU例外管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義すると，EXCINIBとinitialize_exceptionの定義が，
カーネルのターゲット非依存部から取り除かれる．また，TNUM_DEF_EXCNO，
tnum_def_excno，excinib_tableの定義と，CPU例外ハンドラ毎の出入口処理を
生成するための記述（EXCHDR_ENTRYマクロのリスト）を，コンフィギュレータ
のパス2の生成スクリプトのターゲット非依存部によってkernel_cfg.cに生成さ
れなくなる．

(6-7-4-2) void initialize_exception(void)（オプション）

OMIT_INITIALIZE_EXCEPTIONをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_EXCEPTIONをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

6.7.5 デフォルトのCPU例外ハンドラ

(6-7-5-1) void default_exc_handler(void *p_excinf)（オプション）

コンフィギュレータによりCPU例外ハンドラのテーブルを生成する場合などには，
CPU例外ハンドラを登録しなかったCPU例外ハンドラ番号に対して，デフォルト
のCPU例外ハンドラとして，default_exc_handlerを登録する．

default_exc_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_EXC_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_exc_handlerとなる．

6.7.6 CPU例外発生時のシステム状態の参照

(6-7-6-1) bool_t exc_sense_intmask(void *p_excinf)

CPU例外が発生した時のシステム状態が，以下の条件をすべて満たす場合に
true，そうでない時にfalseを返す関数．

　(1) カーネル内のクリティカルセクションの実行中でない
　(2) 全割込みロック状態でない
　(3) CPUロック状態でない
　(4) カーネル管理外の割込みハンドラ実行中でない
　(5) カーネル管理外のCPU例外ハンドラ実行中でない
　(6) タスクコンテキスト
　(7) 割込み優先度マスクが全解除

多くの場合，カーネル管理の割込みがすべてマスクされていることをチェック
することで，(1)〜(5)の判定を一括して行うことができる．また，割込み優先
度マスクを実現しているハードウェアレジスタをチェックすることで，(1)〜
(5)と(7)の判定を一括して行える場合も多い．

p_excinfには，CPU例外の情報を記憶している領域の先頭番地が渡される．

6.8 カーネルの起動・終了

(6-8-1) スタートアップモジュール

スタートアップモジュールは，システムのリセット後に最初に実行されるプロ
グラムである．スタートアップモジュールはカーネルの管理外であり，アプリ
ケーションで用意するのが基本であるが，スタートアップモジュールで行うべ
き処理を明確にするために，プロセッサ依存部またはチップ依存部で，標準の
スタートアップモジュールを用意する.

標準のスタートアップモジュールで行うべき処理は，以下の通り．

(a) プロセッサ状態の初期化

プロセッサモード，スタックポインタ，フレームポインタ等，プロセッサの状
態を初期化する．また，NMIを除くすべての割込みをマスクした状態（全割込み
ロック状態と同等の状態）とする．DRAMコントローラの初期化など，メモリを
アクセスするために必要な初期化処理をここで行ってもよい（次の
hardware_init_hookで行ってもよい）．

(b) hardware_init_hookを呼び出す

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行うために，hardware_init_hookを呼び出す．

hardware_init_hookは，ターゲット依存部で用意するのが標準であるが，シス
テムのリセット後すぐに行う必要のある初期化処理を追加するために，アプリ
ケーションで用意したものを用いる場合もある．

アプリケーションまたはターゲット依存部でhardware_init_hookが用意されて
いない場合のために，スタートアップモジュールの中に，何もせずにリターン
するhardware_init_hook関数をweak定義で用意しておく．

メモリアクセスに必要な初期化処理をhardware_init_hookで行う場合には，こ
れを呼び出す時点でメモリにアクセスすることができないため，関数（サブルー
チン）を呼び出すためにスタックを使用するプロセッサでは，戻り番地を汎用
レジスタに入れて呼び出すといった工夫が必要である．この場合，
hardware_init_hookをC言語で記述することはできなくなるが，やむをえない．

(c) bssセクションとdataセクションの初期化

bssセクションをクリアし，dataセクションに初期値を設定する．

ただし，カーネル本体は，kerflgがfalse（＝0）に初期化されること以外に，
これらのセクションが初期化されることに依存していない．そのため，スター
トアップモジュールをアプリケーションで用意する場合で，システムサービス
やアプリケーションがこれらのセクションが初期化されることに依存していな
い場合には，システムの起動時間を短縮するために，kerflgをfalseに初期化
するだけで十分である．

(d) software_init_hookを呼び出す

開発環境（特にライブラリ）に依存して必要な初期化処理を行うために，
software_init_hookを呼び出す．

software_init_hookは，ターゲット依存部で用意するのが標準である．

アプリケーションまたはターゲット依存部でsoftware_init_hookが用意されて
いない場合のために，スタートアップモジュールの中に，何もせずにリターン
するsoftware_init_hook関数をweak定義で用意しておく．

(e) sta_kerへ分岐

sta_kerを呼び出す．sta_kerは，NMIを除くすべての割込みをマスクした状態
（全割込みロック状態と同等の状態）で呼び出さなければならない．sta_kerか
らはリターンすることがないため，スタートアップモジュールに戻ってくるこ
とは考える必要がない．

(6-8-2) void target_initialize(void)

ターゲット依存部の初期化を行う関数．sta_kerの最初で呼び出される．開発環
境依存／プロセッサコア依存／チップ依存の初期化処理を，それらの依存部に
切り分けることも可能である．

この関数は，あくまでもカーネルのターゲット依存部の初期化処理を行うため
のものである．アプリケーションに必要な初期化処理は，初期化ルーチンで行
うのが基本であるが，システムのリセット後すぐに行う必要がある場合には，
hardware_init_hookを用いる．

(6-8-3) void call_exit_kernel(void)

非タスクコンテキストに切り換えて，exit_kernelへ分岐する関数．ext_kerか
ら呼び出される．exit_kernelからはリターンすることがないため，この関数に
戻ってくることは考える必要がない．

非タスクコンテキストに切り換えるのは，終了処理ルーチンを，非タスクコン
テキスト用のスタックで実行するためである．終了処理ルーチンをタスク用の
スタックで実行すると，各タスクのスタック領域のサイズを決定する際に，終
了処理ルーチンが使用するスタック領域を考慮しなければならない．これには，
終了処理ルーチンが使用するスタック領域が大きい場合に各タスクのスタック
領域を無駄に大きくしなければならないことに加えて，意図しないスタックオー
バーフローが発生する可能性を高めるという問題がある．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

(6-8-4) void target_exit(void)

ターゲット依存部の終了処理を行う関数．この関数は，カーネル終了処理の最
後に呼び出され，リターンしてはならない．開発環境依存／プロセッサコア依
存／チップ依存の終了処理を，それらの依存部に切り分けることも可能である．

この関数では，最初に，atexitによって登録された関数とデストラクタを呼び
出すことを意図しており，標準的には，software_term_hookを呼び出す．

アプリケーションまたはターゲット依存部でsoftware_term_hookが用意されて
いない場合のために，何もせずにリターンするsoftware_term_hook関数をweak
定義で用意しておく．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

6.9 カーネル内部のチューニング

6.9.1 ビットマップサーチ

(6-9-1-1) OMIT_BITMAP_SEARCH（オプション）
(6-9-1-2) uint_t bitmap_search(uint16_t bitmap)（オプション）

ターゲット非依存部で，uint16_t型の整数値（bitmap）中の1のビットの内，最
も下位（右）のものをサーチし，そのビット番号を返す関数bitmap_searchを用
意している．ここで，ビット番号は最下位ビットを0とし，bitmapに0を指定し
てはならないものとしている．

ビットサーチ命令を持つプロセッサでは，bitmap_searchを，ビットサーチ命令
を使うように書き直した方が効率が良い場合がある．このような場合には，ター
ゲット依存部でビットサーチ命令を使ったbitmap_searchを定義し，
OMIT_BITMAP_SEARCHをマクロ定義する．

標準ライブラリにビットサーチ命令を用いたffsがある場合，bitmap_searchを
(ffs(bitmap) - 1)に定義するとよい．

(6-9-1-3) uint16_t PRIMAP_BIT(PRI pri)（オプション）

ビットサーチ命令のサーチ方向が逆などの理由で，優先度とビットとの対応を
変更したい場合には，PRIMAP_BITをマクロ定義する．

6.9.2 ビットフィールド

(6-9-2-1) BIT_FIELD_UINT（オプション）

8ビット以下の幅のビットフィールドで，符号無し整数値を保持したい場合に用
いるべきデータ型．デフォルトの定義はunsigned intとなっているが，ターゲッ
トやツール依存で，unsigned charまたはunsigned shortに定義した方が効率が
良い場合がある．

(6-9-2-2) BIT_FIELD_BOOL（オプション）

1ビット幅のビットフィールドで，ブール値を保持したい場合に用いるべきデー
タ型．デフォルトではBIT_FIELD_UINTと同一に定義しているが，ブール値を保
持することを明示するために別の名前としている．

(6-9-2-3) TBIT_TCB_PRIORITY（オプション）

現在優先度（および，ミューテックス拡張におけるベース優先度）を保持する
ためのTCB中のフィールドのビット数．デフォルトでは8ビットに定義している
が，それ以外に定義したい場合に，ビット数をこの名前にマクロ定義する．

6.10 カーネル実装に関するその他の定義

6.10.1 ターゲット依存のオブジェクト属性

(6-10-1-1) TARGET_TSKATR（オプション）	ターゲット定義のタスク属性
(6-10-1-2) TARGET_ISRATR（オプション）	ターゲット定義のISR属性
(6-10-1-3) TARGET_INHATR（オプション）	ターゲット定義の割込みハンドラ属性
(6-10-1-4) TARGET_INTATR（オプション）	ターゲット定義の割込み属性
(6-10-1-5) TARGET_EXCATR（オプション）	ターゲット定義のCPU例外ハンドラ属性

各オブジェクトの属性をターゲット定義で拡張する場合に，該当するオブジェ
クト属性を示す変数に，拡張で使用するビットの論理和を定義する．これによ
り，拡張で使用するビットが設定されている場合にエラーになるのを防ぐ．

6.10.2 エラーチェック方法の指定

(6-10-2-1) TARGET_MIN_STKSZ（オプション）

ターゲット定義で，タスクのスタックサイズの最小値を設定する場合には，こ
の変数をスタックサイズの最小値（スタックサイズを，ターゲット定義の制約
に合致するように大きい方に丸める前の値での最小値）に定義する．定義しな
い場合のデフォルト値は1．

(6-10-2-2) TARGET_MIN_ISTKSZ（オプション）

ターゲット定義で，非タスクコンテキストのスタックサイズの最小値を設定す
る場合には，この変数をスタックサイズの最小値（スタックサイズを，ターゲッ
ト定義の制約に合致するように大きい方に丸める前の値での最小値）に定義す
る．定義しない場合のデフォルト値は1．

(6-10-2-3) CHECK_STKSZ_ALIGN（オプション）

スタック領域のサイズがある値（アライン単位）の倍数でなければならない場
合に，この変数をアライン単位に定義する．この変数を定義することで，コン
フィギュレータの生成スクリプトとacre_tsk（動的生成機能拡張パッケージの
み）において，スタック領域のサイズが正しくない（この変数に定義した値の
倍数でない）場合のエラーをチェックするようになる．チェックが必要ない場
合には，この変数を定義しない．

(6-10-2-4) CHECK_INTPTR_ALIGN（オプション）	intptr_t型の変数のアライン単位
(6-10-2-5) CHECK_INTPTR_NONNULL（オプション）intptr_t型の変数の非NULLチェック
(6-10-2-6) CHECK_FUNC_ALIGN（オプション）	処理単位のアライン単位
(6-10-2-7) CHECK_FUNC_NONNULL（オプション）	処理単位の非NULLチェック
(6-10-2-8) CHECK_STACK_ALIGN（オプション）	スタック領域のアライン単位
(6-10-2-9) CHECK_STACK_NONNULL（オプション）スタック領域の非NULLチェック
(6-10-2-10) CHECK_MPF_ALIGN（オプション）	固定長メモリプール領域のアライン単位
(6-10-2-11) CHECK_MPF_NONNULL（オプション）	固定長メモリプール領域の非NULL
											チェック

intptr_t型の変数／処理単位／スタック領域／固定長メモリプール領域の先頭
番地がある値（アライン単位）の倍数でなければならない場合に，それぞれ，
CHECK_INTPTR_ALIGN／CHECK_FUNC_ALIGN／CHECK_STACK_ALIGN／
CHECK_MPF_ALIGNをアライン単位に定義する．intptr_t型の変数／処理単位／ス
タック領域／固定長メモリプール領域の先頭番地がNULLでないかのチェックを
行う場合には，それぞれCHECK_INTPTR_NULL／CHECK_FUNC_NONNULL／
CHECK_STACK_NONNULL／CHECK_MPF_NONNULLを定義する．

(6-10-2-12) CHECK_MPK_ALIGN（オプション）	カーネルメモリプール領域の
											アライン単位
(6-10-2-13) CHECK_MPK_NONNULL（オプション）	カーネルメモリプール領域の
											非NULLチェック

カーネルメモリプール領域の先頭番地がある値（アライン単位）の倍数でなけ
ればならない場合に，CHECK_MPK_ALIGNをアライン単位に定義する．カーネル
メモリプール領域の先頭番地がNULLでないかのチェックを行う場合には，
CHECK_MPK_NONNULLを定義する．動的生成機能拡張パッケージを使用しない場
合には，定義する必要がない．

(6-10-2-14) CHECK_MB_ALIGN（オプション）	管理領域のアライン単位

カーネル内の管理領域（具体的には，データキュー管理領域，優先度データ
キュー管理領域，固定長メモリプール管理領域）の先頭番地がある値（アライ
ン単位）の倍数でなければならない場合に，この変数をアライン単位に定義す
る．動的生成機能拡張パッケージを使用しない場合には，定義する必要がない．

6.10.3 非タスクコンテキスト用のスタック領域

(6-10-3-1) DEFAULT_ISTKSZ

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域のサイズ．

(6-10-3-2) DEFAULT_ISTK（オプション）

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域の先頭番地．このマクロが定義されない場合には，
サイズがDEFAULT_ISTKSZのスタック領域が，配列により確保される．

(6-10-3-3) STK_T *TOPPERS_ISTKPT(STK_T *istk, size_t istksz)（オプション）

非タスクコンテキスト用のスタックポインタの初期値を保持する変数（istkpt）
を用いる場合に，このシンボルに，スタック領域の先頭番地（istk）とスタッ
ク領域のサイズ（istksz）から，スタックポインタの初期値を求めるマクロを
定義する．

(6-10-3-4) OMIT_ISTACK（オプション）

非タスクコンテキスト用のスタック領域を使用しない場合には，このシンボル
をマクロ定義する．

6.10.4 空ラベルの定義

(6-10-4-1) TOPPERS_EMPTY_LABEL(type, symbol)（オプション）

リンクエラーを防ぐために，データ型typeの配列である変数symbolに定義を与
えるためのマクロ．与えた定義が参照されることはないため，どのような定義
を与えてもよい．

デフォルトでは，symbolを，要素型がtypeでサイズが0の配列に定義している．
サイズが0の配列がエラーとならないコンパイラ（GCCはこれに該当）を用いる
場合には，ターゲット依存部で定義する必要はない．

6.11 トレースログ機能に関する設定

ASP3カーネルのソースコードには，カーネルの実行トレースログを取得するた
めのマクロ等が埋め込んである．デフォルトでは，これらのマクロは空に定義
されてトレースログの取得は行わないが，これらのマクロを適切に定義するこ
とでトレースログの取得を行うことができる．

6.11.1 取得できるトレースログの種類とマクロ

取得できるトレースログの種類と，それを取得するために定義するマクロは次
の通りである．

(a) カーネルの動作開始と終了

次のマクロを定義することで，カーネルの動作開始時と終了時のトレースログ
を取得することができる．

	LOG_KER_ENTER		カーネルが動作を開始する直前（初期化の完了後）
	LOG_KER_LEAVE		カーネルの終了（ext_ker）が呼ばれた直後（終了処
						理の実行前）

(b) 処理単位の実行開始と終了

次のマクロを定義することで，割込みハンドラ（INH），割込みサービスルーチ
ン（ISR），周期ハンドラ（CYC），アラームハンドラ（ALM），CPU例外ハンド
ラ（EXC）の実行開始前と終了後のトレースログを取得することができる．

	LOG_<処理単位略号>_ENTER	処理単位の実行開始直前
	LOG_<処理単位略号>_LEAVE	処理単位の終了直後

割込みハンドラは，アプリケーションが登録したもののみを対象とし，割込み
サービスルーチンを呼び出すためにカーネル内に生成されるものは対象としな
い．タスクの実行開始と終了は，他の方法で取得できるため，この方法は用意
していない．

なお，割込みハンドラとCPU例外ハンドラの実行開始と終了のトレースログ取得
は，ターゲット依存部で実装する必要がある．詳しくは，「6.2 トレースログ
機能への対応」「6.6.1 割込みハンドラの出入口処理」「6.7.1 CPU例外ハンド
ラの出入口処理」の節を参照すること．

(c) タスク状態の変化

次のマクロを定義することで，タスク状態が変化した時のトレースログを取得
することができる．ただし，実行状態と実行可能状態の間の遷移は，他の方法
で取得できるため，このマクロでは取得できない．

	LOG_TSKSTAT		タスク状態の変化

(d) ディスパッチャの実行開始と終了

次のマクロを定義することで，ディスパッチャが実行開始する時と，終了する
時のトレースログを取得することができる．

	LOG_DSP_ENTER	ディスパッチャの実行開始
	LOG_DSP_LEAVE	ディスパッチャの終了

ディスパッチャの実行開始は，タスクが実行状態から実行可能状態に遷移する
タイミングであるため，実行可能状態へ遷移するタスクのTCBへのポインタをパ
ラメータとする．逆に，ディスパッチャの終了は，タスクが実行可能状態から
実行状態に遷移するタイミングであるため，実行状態へ遷移するタスクのTCBへ
のポインタをパラメータとする．

ASP3カーネルでは，実行できるタスクがなく，カーネルがアイドル状態になる
場合には，ディスパッチャの中に留まる．そのため，アイドル状態への遷移と
アイドル状態から他の状態への遷移は，このマクロでは取得できない．

なお，ディスパッチャの実行開始と終了のトレースログ取得は，ターゲット依
存部で実装する必要がある．詳しくは，「6.2 トレースログ機能への対応」と
「6.5.2 ディスパッチャ本体」の節を参照すること．

(e) サービスコールの入口と出口

次のマクロを定義することで，各サービスコールの入口と出口のトレースログ
を取得することができる．

	LOG_<サービスコールの大文字表記>_ENTER		サービスコール名の入口
	LOG_<サービスコールの大文字表記>_LEAVE		サービスコール名の出口

それぞれのマクロの名称やパラメータの詳細については，カーネルのソースコー
ドを参照すること．

6.11.2 トレースログ記録のサンプルコード

トレースログを記録する方法の一例として，メモリ上にトレースログを記録す
るためのサンプルコードをarch/tracelogディレクトリに用意している．このサ
ンプルコードは，システムログ機能と同様のトレースログ機能を用意し，トレー
スログ情報をメモリ上に記録するとともに，それを読み出して表示する機能を
実現している．

このサンプルコードを用いて，トレースログを記録・ダンプする方法の例につ
いては，「TOPPERS/ASP3カーネル ユーザーズマニュアル」の「11.6 トレース
ログ記録のサンプルコードの使用方法」の節を参照すること．

なお，このサンプルコードでは，ディスパッチャの出口，タスクの状態遷移，
システムログの出力の3つのトレースログのみを記録している．他のトレース
ログを記録したい場合にはtrace_log.hを（ダンプしたい場合には，
tTraceLog.cも）修正する必要がある．

6.12 カーネル実装のターゲット依存部のためのリネーム記述

カーネル内部に閉じて使われる関数や変数などの名称で，オブジェクトファイ
ルの外部から参照できる名称は，C言語レベルで，先頭が"_kernel_"または
"_KERNEL_"である名称としている．ASP3カーネルでは，ソースコードをコンパ
クトに保ちつつこれを実現するために，リネーム記述ファイルを導入している．

具体的には，リネームすべき名称をリストアップしたxxx_rename.defを用意し，
このファイルからツール（utils/genrename.rb）により，名称をリネームする
ためのマクロ定義を含むxxx_rename.hと，それらのマクロ定義を解除するため
のxxx_unrename.hを生成する．ツールの起動方法は次の通りである．

	% ruby genrename.rb xxx

xxx_rename.defには，リネームすべき名称を1行に1つ記述する．xxxxという名
称が記述されている場合，xxx_rename.hには次のような記述が生成される．

#define xxxx				_kernel_xxxx

また，xxx_unrename.hには次のような記述が生成される．

#undef xxxx

ただし，先頭に"_"が1つ以上ある名称（例えば，_xxxxや__xxxx）が記述され
ている場合，"_kernel_"は先頭の"_"の列の後ろに付加され，xxx_rename.hに
生成される記述は次のようになる．

#define _xxxx				__kernel_xxxx
#define __xxxx				___kernel_xxxx

xxx_rename.defの中には，他のリネーム記述を取り込むために，「INCLUDE
"yyy"」または「INCLUDE <yyy>」という記述を含めることができる．この記述
がされている場合，xxx_rename.hには「#include "yyy_rename.h"」または
「#include <yyy_rename.h>」という記述が，xxx_unrename.hには「#include
"yyy_unrename.h"」または「#include <yyy_unrename.h>」という記述が生成さ
れる．

xxx_rename.defの中の"#"で始まる行はコメントとして扱われ，生成するファイ
ル中にコメントを生成する．xxx_rename.defの中の空行は無視される．

カーネルのターゲット非依存部で使われる名称をリネームするために，kernel
ディレクトリに，kernel_rename.defと，そこから生成したkernel_rename.hお
よびkernel_unrename.hが用意されている．kernel_rename.defには，
「INCLUDE "target"」という記述が含まれており，ターゲット依存部のリネー
ム記述を取り込むようになっている．ターゲット依存部で定義し，ターゲット
非依存部で参照される名称は，ターゲット依存部のリネーム記述に含める．

ターゲット依存部では，ターゲット依存部で使われる名称をリネームするため
に，target_rename.defと，そこから生成したtarget_rename.hおよび
target_unrename.hを用意する．ターゲット依存部から開発環境依存部／プロセッ
サコア依存部／チップ依存部を切り分ける場合には，target_rename.defに
INCLUDE記述を入れ，開発環境依存部／プロセッサコア依存部／チップ依存部の
リネーム記述を取り込むようにする．

アセンブリ言語レベルの識別名が，C言語レベルの識別名の先頭に"_"が付けた
ものになる場合，アセンブリ言語で定義／参照する関数や変数などについては，
アセンブリ言語レベルの（先頭に"_"が付いた）識別名もxxx_rename.defにリ
ストアップする必要がある．

【TOPPERS/ASP1カーネルとの関係】

TOPPERS_LABEL_ASMを定義した場合に，先頭に"_"を付けた識別名のリネームも
行う機能は廃止した．

6.13 高分解能タイマドライバ

高分解能タイマドライバは，カーネルがシステム時刻の更新に用いるための抽
象化された高分解能タイマを提供するためのデバイスドライバである．高分解
能タイマドライバに関連して，t_stddef.hのターゲット依存部に含めるべき定
義については「3.8 その他の定義」の節を，kernel.hのターゲット依存部に含
めるべき定義については「5.3 高分解能タイマのタイマ周期とカウント値の進
み幅」の節を，それぞれ参照すること．

【TOPPERS/ASP1カーネルとの関係】

ASP3カーネルでは，タイムティックを用いない時間管理のために，高分解能タ
イマを用いている．高分解能タイマを効率的に実現できないターゲットシステ
ム向けには，高分解能タイマドライバを，タイムティックを用いて実装する方
法もある．この実装方法については，「6.13.5 タイムティックを用いたタイマ
ドライバの実装」の節を参照すること．

6.13.1 高分解能タイマドライバのファイル構成

高分解能タイマドライバを組み込むための静的APIを記述したシステムコンフィ
ギュレーションファイルを，target_timer.cfgに用意する．このファイルには，
高分解能タイマドライバを初期化するための初期化ルーチンの追加，高分解能
タイマドライバを終了させるための終了処理ルーチンの追加，高分解能タイマ
割込みのための割込みハンドラの定義（または，割込みサービスルーチンの生
成），高分解能タイマ割込みのための割込み要求ラインの属性の設定の静的
APIなどを含むことになる．

高分解能タイマドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_timer.hに用意する．また，高分解能タイマドライバの実装ファイルを
target_timer.cに用意する．

システム時刻の経過をきっかけに行う処理の多くは，タスクの起動や待ち解除
を行うものであるため，高分解能タイマ割込みの割込み優先度は，割込みの中
で最低の優先度で十分である．ただし，周期ハンドラやアラームハンドラの実
行開始遅れが問題になる場合には，高分解能タイマ割込みの割込み優先度をよ
り高い値に設定したい．そこで，高分解能タイマ割込みの割込み優先度を変更
する方法を，ターゲット依存部のユーザーズマニュアルに記載すべきである．

6.13.2 高分解能タイマの操作と割込み処理

高分解能タイマドライバが提供する抽象化された高分解能タイマは，0から，1
マイクロ秒に1のペースでカウントアップし，タイマ周期（TCYC_HRTCNT）に達
したら0に戻るものとする（すなわち，高分解能タイマの現在値がTCYC_HRTCNT
になることはない）．1マイクロ秒に1のペースでカウントアップすれば，1ず
つ連続してカウントアップしなくてもよい．例えば，2マイクロ秒毎に2ずつカ
ウントアップしても良い．タイマ周期はターゲット依存であるが，2^32以下で，
実現可能な範囲でできる限り大きい値とする．

なお，ターゲット非依存部の実装制約［ASPD1021］より，高分解能タイマのカ
ウント値の進み幅は1秒以下，言い換えると，TSTEP_HRTCNTの値は1000000以下
でなければならない．

(6-13-2-1) void target_hrt_initialize(EXINF exinf)

高分解能タイマを初期化し，高分解能タイマの動作を開始させる．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチンと
してカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-13-2-2) void target_hrt_terminate(EXINF exinf)

高分解能タイマの動作を停止させ，高分解能タイマ割込みを発生しないように
する．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチン
としてカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-13-2-3) HRTCNT target_hrt_get_current(void)

高分解能タイマの現在値を返す．

(6-13-2-4) void target_hrt_set_event(HRTCNT hrtcnt)

高分解能タイマを，hrtcntで指定した値カウントアップしたら割込みを発生さ
せるように設定する．割込みを発生させるタイミングがすでに設定されていた
場合は，それまでに設定されていたタイミングはキャンセルする．hrtcntに0が
渡されることはない（そのような場合には，target_hrt_raise_eventが呼ばれ
る）．

高分解能タイマのカウント値が1ずつ連続してカウントアップしない場合には，
割込みを発生させるタイミングを遅い方に丸める．

(6-13-2-5) void target_hrt_clear_event(void)（オプション）

高分解能タイマを，割込みを発生させないように設定する．

この関数は，USE_64BIT_HRTCNTの場合にのみ用意する必要がある．

(6-13-2-6) void target_hrt_raise_event(void)

高分解能タイマ割込みを即座に発生させる．ハードウェアの機能的にこれが実
現できない場合には，最小のカウントアップ値で割込みを発生させる方法，言
い換えると「target_hrt_set_event(1U)」で実現してもよい．

(6-13-2-7) HRTCNT_BOUND

HRTCNT型が32ビットの場合には，高分解能タイマに設定するカウントアップ値
の上限値（割込みタイミングに指定する最大値）を，このマクロに定義する．
HRTCNT_BOUNDは，高分解能タイマのタイマ周期（TCYC_HRTCNT）からタイマ割
込みの遅延時間よりも長い値を減じた値に定義する．カーネルの実装上の都合
により，HRTCNT_BOUNDは，4,294,000,000未満の値に設定しなければならない．

HRTCNT_BOUNDを設けている理由は，高分解能タイマをタイマ周期のぎりぎりで
割込みがかかるように設定した場合，割込みハンドラ内で高分解能タイマを読
んだ時点でタイマ周期を越えており，高分解能タイマが周回したことを見落と
す可能性があるためである．

なお，USE_64BIT_HRTCNTをマクロ定義してHRTCNT型を64ビットにした場合には，
このマクロを定義してはならない．定義した場合，このターゲットでは
USE_64BIT_HRTCNTはサポートされていない旨のエラーとなる．

(6-13-2-8) void target_hrt_handler(void)
    または void target_hrt_isr(EXINF exinf)

高分解能タイマ割込みにより起動される割込み処理プログラム．割込みハンド
ラとして実現する場合にはtarget_hrt_handler，割込みサービスルーチンとし
て実現する場合にはtarget_hrt_isrの名称とする．ターゲット非依存部の
signal_timeを呼び出す．

target_hrt_handlerは，標準的には次のように定義する．

----------------------------------------
void
target_hrt_handler(void)
{
	高分解能タイマ割込み要求のクリア（必要なら）
	signal_time();
}
----------------------------------------

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラま
たは割込みサービスルーチンとしてカーネルに登録する．そのため，関数名を
変更しても差し支えない．

6.13.3 2つのタイマを用いた高分解能タイマドライバの実装

高分解能タイマドライバは，ハードウェアで高機能なタイマを持っている場合
には，1つのタイマだけで実装できる可能性もある（タイマの機能による）が，
そうでない場合には，タイマを2つ使って実装することを想定している．

具体的には，1つのタイマ（これをフリーランニングタイマと呼ぶ）は，無限
にカウントさせ（タイマのビット数が十分に長い場合の除いては巡回する），
高分解能タイマの現在値を返すのに用いる．もう1つのタイマ（これをイベン
トタイマと呼ぶ）は，割込みを発生させるために用いる．

この時，2つのタイマが全く同じタイミングでカウントアップ（またはカウント
ダウン）していれば問題ないが，実際には，2つのタイマに別々にプリスケーラ
が入っている場合や，2つのタイマを別のクロックで駆動する場合には，カウン
トアップのタイミングがずれることも考えられる．このような場合には，以下
の制約を満たすように実装することが必要である．

target_hrt_get_current()でタイマ値を読み，target_hrt_set_event(count)に
よりタイマ割込みを発生させた後，target_hrt_get_current()でタイマ値を読
んだ場合には，2回のtarget_hrt_get_current()の呼び出しの間に，タイマ値が
count以上進んでいなければならない．

より厳密には，以下のシーケンスで高分解能タイマドライバを呼び出した場合
に，(count2 - count1 >= count)を満たさなければならない．

	count1 = target_hrt_get_current();
	target_hrt_set_event(count);
	… ここで時間が経過 …
	割込みが発生
	count2 = target_hrt_get_current();

素直に実装するとこの条件を満たさない場合には，target_hrt_set_eventで割
込みを発生させるタイミングを遅い方に調整する．

6.13.4 高分解能タイマの現在値とタイマ周期

高分解能タイマドライバに用いるタイマ（2つのタイマを用いる場合には，フ
リーランニングタイマ）が，プリスケーラの設定等により1マイクロ秒間隔
（タイマへの入力クロックが1MHz）でカウントアップさせることができない場
合には，タイマの現在値の求め方と，タイマ周期の決め方が問題になる．

(1) タイマへの入力クロックが1MHzの整数倍の場合

タイマへの入力クロックが1MHzの整数倍（言い換えると，カウントアップ周期
が1マイクロ秒の整数分の1）の場合について，入力クロックが10MHz（カウン
トアップ周期が0.1マイクロ秒）の32ビットタイマを用いて高分解能タイマを
実装する方法を例にして説明する．

まず，タイマが0.1マイクロ秒間隔でカウントアップすることから，1マイクロ
秒間隔でカウントアップすべき高分解能タイマの現在値を返す
target_hrt_get_currentは，読み出したタイマ値を10で割った値を返すように
実装する．この場合，タイマ値は0〜2^32-1（＝4,294,967,295）の範囲の値を
とるので，抽象化された高分解能タイマは，それを10で割った値である0〜
429,496,729の範囲の値をとる．そこで，TCYC_HRTCNT（高分解能タイマのタイ
マ周期）は，429,496,730に定義することになる．

しかしこの方法には，高分解能タイマがカウントアップする間隔が大きくばら
つくという問題がある．具体的には，高分解能タイマは1マイクロ秒間隔でカ
ウントアップすべきであるのに対して，高分解能タイマが最大値
（429,496,729）から0になるまでの間隔は，0.6マイクロ秒になる．

この問題を解決するためには，タイマを32ビットの値全体を巡回させるのでは
なく，2^32／10×10（＝4,294,967,290，"／"は商を切り下げた値とする）に
達したら0に戻るようにタイマを設定し，TCYC_HRTCNTを429,496,729に定義す
る方法がある（方法A）．

タイマをこのように設定することができない場合には，タイマを32ビットの値
全体を巡回させつつ，高分解能タイマがカウントアップする間隔のばらつきを
小さくする方法が考えられる．具体的には，target_hrt_get_currentが返す値
を次の式で算出し，TCYC_HRTCNTを429,496,729に定義する（方法B）．

	(タイマ値−タイマ値／715,827,882)／10

単純に10で割る最初の方法では，高分解能タイマが最大値から0になるまでの
間隔が0.6マイクロ秒であったのに対して，この式は，32ビットタイマが巡回
する間に6回，カウントアップする間隔を1.1マイクロ秒とすることで，間隔の
ばらつきを最大0.1マイクロ秒に抑えている．ここで，715,827,882は，2^32／
6である．タイマ値が最大値（＝4,294,967,295）の時に，上の式で算出した値
は429,496,728（＝TCYC_HRTCNT−1）になる．

この方法では，32ビットタイマが巡回する間（約7分間）に，高分解能タイマ
の進みが0.6マイクロ秒遅くなる．すなわち，時間の進み方に誤差が生じるが，
この誤差は，水晶発振子の精度と比べて十分に小さいため，無視してかまわな
い．

(2) タイマへの入力クロックが1MHzの整数倍でない場合

タイマへの入力クロックが1MHzの整数倍（言い換えると，カウントアップ周期
が1マイクロ秒の整数分の1）でない場合についても，基本的な考え方は(1)と
同様である．ここでは，入力クロックが12.5MHz（カウントアップ周期が
1/12.5（＝2/25）マイクロ秒）の32ビットタイマを用いて高分解能タイマを実
装する方法を例にして説明する．

まず，タイマが2/25マイクロ秒間隔でカウントアップすることから，
target_hrt_get_currentは，読み出したタイマ値を2/25倍した値を返すように
実装する．高分解能タイマがカウントアップする間隔がばらつく問題を解決す
るために，(1)の方法Aを用いると，2^32／25×25（＝4,294,967,275）に達し
たら0に戻るようにタイマを設定し，TCYC_HRTCNTをその2/25倍の343,597,382
に定義すればよい．タイマをこのように設定することができない場合には，方
法Bを用いることもできる（詳細は省略）．

TSTEP_HRTCNTは，「高分解能タイマのカウント値の，連続して進む時刻に対す
る遅れの最大値を，マイクロ秒単位の整数値に切り上げた値」という厳密な定
義からは，2に定義すべきである．しかし，入力クロックが12.5MHzの場合，
「高分解能タイマのカウント値の，連続して進む時刻に対する遅れの最大値」
は1.04マイクロ秒であるため，TSTEP_HRTCNTを1に定義しても差し支えないだ
ろう．

読み出したタイマ値を2/25倍する時に，単純に「タイマ値×2／25」で実装す
ると，「タイマ値×2」の部分で32ビットの整数値がオーバフローしてしまう．
これを防ぐには，以下のような方法が考えられる．

・オーバフローを防ぐ計算式とする．具体的には，「タイマ値／25×2＋タイ
　マ値％25×2／25」のようにすれば良い（"％"は剰余演算を示す）．この方
　法の欠点は，除算の回数が増え，ターゲットによってはオーバヘッドが大き
　くなることである．

・タイマを2^32／2以下の周期で巡回させ，計算式を「タイマ値×2／25」とす
　る．具体的には，2^32／2／25×25（＝2,147,483,625）に達したら0に戻る
　ようにタイマを設定し，TCYC_HRTCNTを171,798,690に定義する．この方法の
　欠点は，タイマに設定できる最大値が小さくなることである．

・計算式を「タイマ値／25×2」とし，TSTEP_HRTCNTを2に定義する．この方法
　の欠点は，時間管理の粒度が大きくなってしまうことである．

6.13.5 タイムティックを用いたタイマドライバの実装

ASP1カーネルと同様に，タイムティックによる時間管理を行いたい場合に，高
分解能タイマドライバをタイムティックを用いて実装することで，ターゲット
依存部のみの修正で対応することができる．ただし，この方法は，カーネルの
時間管理機能に手を加えるわけではないため，カーネルが不必要な仕事をして
しまうことは許容する必要がある．

タイムティックを用いて高分解能タイマドライバを実装する場合には，各マク
ロおよび関数を次のように実装する．

・TCYC_HRTCNT（高分解能タイマのタイマ周期）は定義しない（タイマ周期が
　2^32の意味になる）．
・TSTEP_HRTCNT（高分解能タイマのカウント値の進み幅）を，タイムティック
　の周期に定義する（単位はマイクロ秒）．
・高分解能タイマの現時点の値を保持する変数（hrtcnt_current，HRTCNT型）
　を用意する．
・target_hrt_initializeでは，タイマを初期化し，タイマ割込みを周期的に発
　生させるようにする．また，hrtcnt_currentを0に初期化する．
・target_hrt_terminateでは，タイマの動作を停止させ，タイマ割込みを発生
　させないようにする．
・target_hrt_get_currentは，hrtcnt_currentの値を返す．
・target_hrt_set_eventとtarget_hrt_raise_eventでは何もしない．
・HRTCNT_BOUNDは，4000000002に定義することを推奨する．
・target_hrt_handlerまたはtarget_hrt_isrは，（必要なら）タイマ割込み要
　求をクリアし，hrtcnt_currentにタイムティックの周期を加えた後，ターゲッ
　ト非依存部のsignal_timeを呼び出す．

なお，この方法では，処理すべきタイムイベントがない場合にもsignal_time
が呼び出されるため，"no time event is processed in hrt interrupt."とい
うシステムログが頻繁に出力されることになる．このシステムログを削除する
には，timer_event.c中の該当処理を削除すれば良い．

6.14 オーバランタイマドライバ（オプション）

オーバランタイマドライバは，カーネルがオーバランハンドラ機能の実現に用
いるためのオーバランタイマを抽象化するためのデバイスドライバである．オー
バランハンドラ機能拡張パッケージをサポートしない場合には，オーバランタ
イマドライバを用意する必要はない．

6.14.1 オーバランタイマドライバのファイル構成

オーバランタイマドライバは，高分解能タイマドライバと同じファイルの中に
記述しても，別のファイルを用意して記述してもよい．いずれの場合も，オー
バランタイマドライバのための記述は，TOPPERS_SUPPORT_OVRHDRがマクロ定義
されている場合にのみ有効になるようにする．

具体的には，オーバランタイマドライバを組み込むためのシステムコンフィギュ
レーションファイル（target_timer.cfgの中に記述してもよい）には，オーバ
ランタイマドライバを初期化するための初期化ルーチンの追加，オーバランタ
イマドライバを終了させるための終了処理ルーチンの追加，オーバランタイマ
割込みのための割込みハンドラの定義（または，割込みサービスルーチンの生
成），オーバランタイマ割込みのための割込み要求ラインの属性の設定の静的
APIなどを含むことになる．

また，オーバランタイマドライバを呼び出すために必要な定義を含むヘッダファ
イル（target_timer.hの中に記述してもよい）と，オーバランタイマドライバ
の実装を含むファイル（target_timer.cの中に記述してもよい）を用意する．

オーバランハンドラは，タスクのオーバランに対する処理を行うものであるた
め，オーバランタイマ割込みの割込み優先度は，割込みの中で最低の優先度で
十分である．ただし，オーバランタイマ割込みの割込み優先度をより高い値に
設定したい場合もないとは言えないため，オーバランタイマ割込みの割込み優
先度を変更する方法を，ターゲット依存部のユーザーズマニュアルに記載すべ
きである．

6.14.2 オーバランタイマの操作と割込み処理

(6-14-2-1) void target_ovrtimer_initialize(EXINF exinf)

オーバランタイマの初期化処理を行う．タイマの動作開始は行わない．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチンと
してカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-14-2-2) void target_ovrtimer_terminate(EXINF exinf)

オーバランタイマを停止させ，オーバランタイマ割込みを発生しないようにす
る．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチン
としてカーネルに登録する．そのため，関数名を変更しても差し支えない．

(6-14-2-3) void target_ovrtimer_start(PRCTIM ovrtim)

オーバランタイマを，ovrtimで指定した時間が経過したら割込みが発生するよ
うに設定し，動作開始する．ovrtimが0の場合は，できる限り早くオーバランタ
イマ割込みを発生させる．ovrtimの単位はマイクロ秒とする．

(6-14-2-4) PRCTIM target_ovrtimer_stop(void)

オーバランタイマを停止し，タイマの残り時間（割込み発生までの時間）を返
す．残り時間がなくなっていた場合には，0を返す．また，オーバランタイマか
らの割込み要求をクリアする（クリアしないとスプリアス割込みが発生するが，
クリアすることは必須ではない）．

(6-14-2-5) PRCTIM target_ovrtimer_get_current(void)

オーバランタイマの残り時間（割込み発生までの時間）を読み出す．残り時間
がなくなっていた場合には，0を返す．オーバランタイマからの割込みはクリア
しない．

(6-14-2-6) void target_ovrtimer_handler(void)
    または void target_ovrtimer_isr(EXINF exinf)

オーバランタイマ割込みにより起動される割込み処理プログラム．割込みハン
ドラとして実現する場合にはtarget_ovrtimer_handler，割込みサービスルーチ
ンとして実現する場合にはtarget_ovrtimer_isrの名称とする．ターゲット非依
存部のcall_ovrhdrを呼び出す．

target_ovrtimer_handlerは，標準的には次のように定義する．

----------------------------------------
void
target_ovrtimer_handler(void)
{
	オーバランタイマ割込み要求のクリア（必要なら）
	call_ovrhdr();
}
----------------------------------------

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラま
たは割込みサービスルーチンとしてカーネルに登録する．そのため，関数名を
変更しても差し支えない．

(6-14-2-7) OMIT_OVRTIMER_START（オプション）
(6-14-2-8) OMIT_OVRTIMER_STOP（オプション）

オーバヘッドの低減のために，ovrtimer_start／ovrtimer_stopの処理をター
ゲット依存部（通常はアセンブリ言語コード）の中に展開し，ターゲット非依
存部中の関数が不要になる場合には，それぞれ，OMIT_OVRTIMER_START／
OMIT_OVRTIMER_STOPをマクロ定義する．

なお，ovrtimer_stopの処理をターゲット依存部の中に展開する場合，
dispatchの中に展開するovrtimer_stopの処理においては，p_runtskがNULLに
なることはないため，(p_runtsk != NULL)の条件判定は省くことができる．

6.15 動的メモリ管理（オプション）

動的生成機能拡張パッケージを使用する場合には，カーネルメモリプール領域
の動的メモリ管理の方法を決める必要がある．

動的生成機能拡張パッケージのターゲット非依存部では，メモリプール領域の
先頭から順に割り当てを行い，すべてのメモリ領域が解放されるまで解放され
たメモリ領域を再利用しないメモリプール管理機能のみを実装している．デフォ
ルトでは，このメモリプール管理機能が使用される．

本格的な動的メモリ管理を行いたい場合には，ターゲット依存部またはユーザ
側で，以下の関数を定義したメモリプール管理機能を用意する必要がある．

(6-15-1) OMIT_MEMPOOL_DEFAULT（オプション）

ターゲット非依存部のデフォルトのメモリプール管理機能を使用せず，ターゲッ
ト依存部またはユーザ側で用意する場合には，このシンボルをマクロ定義する．

(6-15-2) bool_t initialize_mempool(MB_T *mempool, size_t size)（オプション）

mempoolとsizeで先頭番地とサイズが指定されたメモリプール領域を初期化す
る関数．初期化に成功した場合にはtrue，失敗した場合（サイズが小さすぎる
場合など）にはfalseを返す．

(6-15-3) void *malloc_mempool(MB_T *mempool, size_t size)（オプション）

mempoolで先頭番地が指定されたメモリプール領域から，sizeで指定されたサ
イズのメモリ領域を割り付け，その先頭番地を返す関数．割り付けることがで
きない場合には，NULLを返す．

(6-15-4) void free_mempool(MB_T *mempool, void *ptr)（オプション）

mempoolで先頭番地が指定されたメモリプール領域に，ptrで先頭番地が指定さ
れたメモリ領域を解放する関数．

6.15.1 TLSFを用いたメモリプール管理機能の例

オープンソースのメモリ割付けライブラリであるTLSFを用いて動的メモリ管理
を実現するには，ターゲット依存部またはユーザ側で，以下の設定を行う必要
がある．

・TLSFのパッケージに含まれるtlsf.hとtlsf.cを，ソースファイルが置かれて
　いるディレクトリ（のいずれか）に置く．

・Makefile（または，そのターゲット依存部）で，KERNEL_COBJSにtlsf.oを追
　加する．

・OMIT_MEMPOOL_DEFAULTをマクロ定義し，以下を参考にメモリプール管理機能
　の各関数を定義する．ターゲット依存部で対応する場合には，ターゲット依
　存部のヘッダファイルに，OMIT_MEMPOOL_DEFAULTのマクロ定義と，以下の関
　数定義等を含めればよい．

----------------------------------------
#include "tlsf.h"

Inline bool_t
initialize_mempool(MB_T *mempool, size_t size)
{
	if (init_memory_pool(size, mempool) != -1) {
		return(true);
	}
	else {
		return(false);
	}
}

Inline void *
malloc_mempool(MB_T *mempool, size_t size)
{
	return(malloc_ex(size, mempool));
}

Inline void
free_mempool(MB_T *mempool, void *ptr)
{
	free_ex(ptr, mempool);
}
----------------------------------------

なお，TLSF（動作確認は，Version 2.4.6）は，以下のウェブサイトからダウン
ロードすることができる．

	http://www.gii.upv.es/tlsf/

6.16 カーネル実装のコンフィギュレーションファイル

カーネル実装に必要な静的APIを含むファイルとして，カーネル実装のコンフィ
ギュレーションファイル（target_kernel.cfg）を用意する．

標準的なターゲット依存部では，target_kernel.cfgには，高分解能タイマドラ
イバを組み込むためのコンフィギュレーションファイル（target_timer.cfg）
とオーバランタイマドライバを組み込むためのコンフィギュレーションファイ
ル（target_timer.cfgに含まれている場合もある）のインクルード記述のみが
含まれる．


７．コンフィギュレータ設定ファイルのターゲット依存部

7.1 設定ファイルとターゲット依存部の位置付け

ASP3カーネルのコンフィギュレータは，設定ファイルの記述に従って，ファイ
ルの生成およびエラーチェックを行う．コンフィギュレータの設定ファイルに
は，以下の4つがある．

(a) 静的APIテーブル

静的APIの一覧と，各静的APIのパラメータに関する情報を記述したファイル．
静的APIを拡張する場合以外は変更する必要がないため，ターゲット非依存部で
用意している（kernel/kernel_api.def）．

(b) 値取得シンボルテーブル

コンフィギュレータのパス1において，パラメータ計算用C言語ファイルに出力
し，値を求めたいシンボル（一般には式）を記述するためのファイル．ターゲッ
ト非依存部では，ターゲットに依存せずに必要となるシンボルを記述したファ
イルを用意している（kernel/kernel_sym.def）．

ターゲットに依存して必要となるシンボルがある場合には，ターゲット依存部
の値取得シンボルテーブル（標準的には，target_sym.def）を用意して，その
中に記述する．target_sym.def（または，同等の役割を持つファイル）の中に
記述して値を求めることができるシンボルは，kernel/kernel_int.hおよびそ
こからインクルードされるファイルで定義されていなければならない．
kernel_int.hからは，target_stddef.h，target_kernel.h，
target_kernel_impl.hを（間接的に）インクルードしているため，これらのファ
イルおよびそこからインクルードされるファイルで定義されるターゲット依存
のシンボルは，target_sym.def（または，同等の役割を持つファイル）の中に
記述することができる．

ここで値を求めたシンボルの値は，コンフィギュレータのパス2，パス3および
オフセット生成用の生成スクリプト中で，グローバル変数として参照すること
ができる．

(c) パス2の生成スクリプト

コンフィギュレータのパス2は，生成スクリプトにより，カーネルの構成・初期
化ファイル（kernel_cfg.c），構成・初期化ヘッダファイル（kernel_cfg.h）
などを生成する．この生成スクリプトは，ターゲット非依存部とターゲット依
存部に切り分けてあるが，他のファイルのターゲット依存部とは逆に，ターゲッ
ト依存部からターゲット非依存部をインクルードする形になっている．

具体的には，ターゲット依存部ディレクトリに置かれたtarget_kernel.trbで必
要な変数を定義した後，ターゲット非依存部（kernel/kernel.trb）をインクルー
ドする．kernel.trbでは，カーネルのターゲット非依存部で使用する変数定義
等を生成する．kernel.trbのインクルードの後，target_kernel.trbでは，カー
ネルのターゲット依存部で使用する変数定義等を生成する．target_kernel.trb
から，開発環境依存部／プロセッサコア依存部／チップ依存部を切り分けても
よい．

(d) パス3の生成スクリプト

コンフィギュレータのパス3は，生成スクリプトにより，静的APIの一般定数式
パラメータのチェックを行う．この生成スクリプトも，ターゲット非依存部と
ターゲット依存部に切り分けてあり，ターゲット依存部からターゲット非依存
部をインクルードする形になっている．

具体的には，ターゲット依存部ディレクトリに置かれたtarget_check.trbで，
必要な変数を定義した後，ターゲット非依存部（kernel/kernel_check.trb）を
インクルードする．kernel_check.trbでは，カーネルのターゲット非依存部で
初期化ブロックに出力した一般定数式パラメータのチェックを行う．
kernel_check.trbのインクルードの後，target_check.trbでは，ターゲットに
依存するチェックを行う．target_check.trbから，開発環境依存部／プロセッ
サコア依存部／チップ依存部を切り分けてもよい．

なお，コンフィギュレータの設定ファイルの記述方法については，「TOPPERS第
3世代カーネル向け Ruby版コンフィギュレータ ユーザーズマニュアル」を参照
すること．

7.2 パス2の生成スクリプトのターゲット依存部

この節では，パス2の生成スクリプトのターゲット依存部を記述する上で必要
な事項について説明する．

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

target_kernel.trbからkernel.trbをインクルードする前に，次の変数および関
数を定義しておかなければならない．なお，リストは，Rubyでは配列で実現す
る．

(7-2-1-1) $INTNO_VALID			有効な割込み番号のリスト
(7-2-1-2) $INHNO_VALID			有効な割込みハンドラ番号のリスト
(7-2-1-3) $EXCNO_VALID			有効なCPU例外ハンドラ番号のリスト

有効な割込み番号／割込みハンドラ番号／CPU例外ハンドラ番号のリストを，各
変数に定義する．

(7-2-1-4) $INTNO_CREISR_VALID（オプション）
(7-2-1-5) $INHNO_CREISR_VALID（オプション）

CRE_ISRで使用できる割込み番号のリストを$INTNO_CREISR_VALIDに，それに対
応する割込みハンドラ番号のリストを$INHNO_CREISR_VALIDに定義する．両者は，
順序まで含めて対応していなければならない．

これらの変数を定義しない場合，それぞれ$INTNO_VALIDと$INHNO_VALIDが使わ
れる．それで良い場合には，これらの変数を定義する必要はない．

(7-2-1-6) $EXCNO_DEFEXC_VALID（オプション）

DEF_EXCで使用できるCPU例外ハンドラ番号のリストを，$EXCNO_DEFEXC_VALID
に定義する．

この変数を定義しない場合，$EXCNO_VALIDが使われる．それで良い場合には，
これらの変数を定義する必要はない．逆に，$EXCNO_DEFEXC_VALIDを定義した
場合，ターゲット非依存部では，$EXCNO_VALIDは使われない．

(7-2-1-7) $INTPRI_CFGINT_VALID（オプション）

CFG_INTで使用できる割込み優先度のリストを定義する変数．標準では，
TMIN_INTPRI以上，TMIN_INTPRI（＝-1）以下の値がCFG_INTに対する割込み優先
度として有効であるが，ターゲット依存部でこの変数を定義することで，
TMIN_INTPRIよりも小さい値を有効とすることができる．

(7-2-1-8) $INTNO_FIX_KERNEL（オプション）	カーネル管理に固定されている
											割込み番号のリスト
(7-2-1-9) $INHNO_FIX_KERNEL（オプション）	カーネル管理に固定されている
		 									割込みハンドラ番号のリスト
(7-2-1-10) $INHNO_FIX_NONKERNEL（オプション）カーネル管理外に固定されている
											 割込み番号のリスト
(7-2-1-11) $INHNO_FIX_NONKERNEL（オプション）カーネル管理外に固定されてい
		 									 る割込みハンドラ番号のリスト

カーネル管理またはカーネル管理外に固定されている割込みがある場合には，
それらの割込み番号と割込みハンドラ番号のリストを，各変数に定義する．

(7-2-1-12) TargetTaskPrepare(key, params)（オプション）

タスク毎にターゲット依存の処理を追加したい場合には，追加したい処理を行
う関数TargetTaskPrepareを定義する．keyにはタスクのID番号（数値）が，
paramsにはパラメータ情報（ハッシュ）が渡される．

(7-2-1-13) GenerateTskinictxb(key, params)（オプション）

USE_TSKINICTXBをマクロ定義した場合，TSKINICTXBの初期化情報を生成するた
めの関数GenerateTskinictxbを定義する．keyにはタスクのID番号（数値）が，
paramsにはパラメータ情報（ハッシュ）が渡される．

(7-2-1-14) AllocStack(stack, size)（オプション）

スタック領域の生成方法をデフォルトから変更したい場合には，スタック領域
を生成するための関数AllocStackを定義する．stackとsizeには，スタック領
域の変数名と丸める前のサイズが渡されるので，スタック領域を生成するコー
ドを生成し，大きい方に丸めたサイズを表す文字列を返す．

(7-2-1-15) TargetCheckCfgInt(params)（オプション）
(7-2-1-16) TargetCheckDefInh(params)（オプション）
(7-2-1-17) TargetCheckCreIsr(params)（オプション）
(7-2-1-18) TargetCheckDefExc(params)（オプション）

CFG_INT，DEF_INH，CRE_ISR，DEF_EXCのパラメータに対して，ターゲット依存
のエラーチェックを行いたい場合には，エラーチェックを行う関数をこれらの
名称で定義する．paramsには，それぞれの静的APIのパラメータ情報（ハッシュ）
が渡される．

7.2.2 ターゲット非依存部で定義される変数

kernel.trbの中では次の変数が定義されるため，kernel.trbのインクルードの
後，target_kernel.trbの中でこれらを参照することができる．

(7-2-2-1) $toIntnoVal[inhnoVal]		割込みハンドラ番号inhnoValを，対応す
									る割込み番号に変換するためのハッシュ
(7-2-2-2) $toInhnoVal[intnoVal]		割込み番号intnoValを，対応する割込み
									ハンドラ番号に変換するためのハッシュ

7.3 パス3の生成スクリプトのターゲット依存部

この節では，パス3の生成スクリプトのターゲット依存部を記述する上で必要
な事項について説明する．

7.3.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

target_check.trbからkernel_check.trbをインクルードする前に，必要に応じ
て，次の変数および関数を定義しておかなければならない．

(7-3-1-1) GetStackTskinictxb(key, params, tinib)（オプション）

USE_TSKINICTXBをマクロ定義した場合，TINIBからスタック領域の先頭番地を
取り出すための関数GetStackTskinictxbを定義する．keyにはタスクのID番号
（値），paramsにはパラメータ情報（ハッシュ），tinibにはタスク初期化ブ
ロックの先頭番地が渡される．

(7-3-1-2) $lmaList（オプション）

パス3の生成スクリプトのターゲット依存部でdataセクションからデータを取得
する場合や，rodataセクションをRAMに置く場合（ユーザーズマニュアルの
「11.8 rodataセクションをRAMに置く場合」の節を参照）には，これらのセク
ションの内容を，配置アドレス（ROM内のアドレス，LMAと呼ぶ）からアクセス
アドレス（RAM内のアドレス，VMAと呼ぶ）にコピーする必要がある．

このコピーは，$lmaListに，コピーするセクション情報のリストを設定するこ
とで，パス3の生成スクリプトのターゲット非依存部で実施する．セクション情
報lmaは，lma[:START_DATA]にコピーするセクションのアクセスアドレスの先頭
のラベル，lma[:END_DATA]に末尾のラベル，lma[:START_IDATA]にその配置アド
レスの先頭のラベルを設定したハッシュで表す．

例えば，コピーするセクションのアクセスアドレスの先頭のラベルが
"__start_data"，末尾のラベルが"__end_data"，その配置アドレスの先頭のラ
ベルが"__start_idata"の場合には，パス3の生成スクリプトのターゲット依存
部に以下の記述を含める．

----------------------------------------
$lmaList = [ { :START_DATA => "__start_data",
               :END_DATA => "__end_data",
               :START_IDATA => "__start_idata" } ]
----------------------------------------

7.3.2 ターゲット依存部で行うべきエラーチェック

以下の先頭番地は，ターゲット非依存部で生成するテーブルに出力されないた
め，パス3のターゲット非依存部（kernel_check.trb）では，プログラムの開始
番地として正しくない場合のエラーをチェックしない．そのため，ターゲット
依存部でエラーチェックを行う必要がある．

・割込みサービスルーチンの先頭番地（CRE_ISRのisr）
・割込みハンドラの先頭番地（DEF_INHのinthdr）
・CPU例外ハンドラの先頭番地（DEF_EXCのexchdr）

ただし，ターゲット依存部においても，これらのエラーチェックを行えるとは
限らないため，ユーザーズマニュアルの「1.5 既知の問題」の節には，ターゲッ
ト依存でこれらのエラーが検出されないことがある旨を記載してある．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

コンフィギュレータに関してターゲット依存に用意する必要があるファイルと
して，設定ファイル以外に，cfg1_out.cをリンクするために必要なスタブの定
義ファイルがある．

コンフィギュレータのパス1では，静的APIの整数定数式パラメータの値をCコ
ンパイラを用いて求めるために，cfg1_out.cを生成する．これをコンパイル，
リンクしてロードモジュールを生成する際に，スタートアップモジュールから
参照されるシンボルの定義を与える必要がある．

この定義を与えるために，cfg1_out.cから，ターゲット依存部の
target_cfg1_out.hをインクルードしている．target_cfg1_out.h（または，そ
こからインクルードされるファイル）には，スタートアップモジュールから参
照されるシンボルのスタブの定義を含める．典型的には，以下のような定義を
含める必要がある．

----------------------------------------
void sta_ker(void)
{
}

void hardware_init_hook(void)
{
}

void software_init_hook(void)
{
}

const size_t	_kernel_istksz = 0;

STK_T *const	_kernel_istk = NULL;
----------------------------------------

また，target_cfg1_out.h（または，そこからインクルードされるファイル）に
は，コンフィギュレータを用いてオフセットファイル（offset.h）を生成する
ために必要な記述を含める．詳しくは，「2.5 オフセットファイルの生成方法」
の節を参照すること．


８．システムサービス等のターゲット依存部

ASP3カーネルでは，TOPPERS組込みコンポーネントシステム（TECS）を用いてシ
ステムサービスを構築している．TECSの仕様については，以下のURLにある
TECSリファレンスマニュアルを参考にすること．

	http://dev.toppers.jp/trac_user/tecs/wiki/WikiStart

【TOPPERS/ASP1カーネルとの関係】

TECSを用いてシステムサービスを構築しているため，その内部構造は，ASP1カー
ネルとは大きく異なる．

8.1 システムサービスの構成とターゲット依存部

ASP3カーネルの配布パッケージには，以下のシステムサービスが含まれている．

  ・システムログ機能
  ・シリアルインタフェースドライバ
	  - ターゲット非依存部
	  - ターゲット依存部
  ・システムログタスク
  ・低レベル出力（ターゲット依存部のみ）
  ・テストプログラム用サービス
  ・実行時間分布集計サービス
  ・カーネル起動メッセージ出力

これらの内，シリアルインタフェースドライバのターゲット依存部と低レベル
出力は，ターゲット依存部で用意する必要がある．システムサービスのターゲッ
ト依存部のコンポーネント記述は，target.cdlまたはそこからインポートされ
るファイル（開発環境依存部／プロセッサコア依存部／チップ依存部で用意さ
れるコンポーネント記述ファイルなど）に含める．

その他のシステムサービスは，ターゲット非依存部で用意されているが，ター
ゲット依存に設定を変更することができる．具体的には，システムサービスの
設定を変更するための定義を，target.cdlまたはそこからインポートされるファ
イルや，target_syssvc.hまたはそこからインクルードされるファイル（開発環
境依存部／プロセッサコア依存部／チップ依存部で用意されるヘッダファイル
など），target_stddef.hまたはそこからインクルードされるファイルに含める．

8.2 シリアルインタフェースドライバのターゲット依存部

8.2.1 ターゲット依存部の実現形態

シリアルインタフェースドライバのターゲット依存部は，非依存部と結合する
ための受け口と呼び口を1つずつ持つセルタイプとして実装する．非依存部と結
合しなくてもエラーとならないように，呼び口にはoptional指定を行う．受け
口（ターゲット依存部が非依存部に対してサービスを提供）と呼び口（ターゲッ
ト依存部が非依存部を呼び出すコールバック）のインタフェースについては，
以降の節で説明する．

ターゲット依存部のセルタイプ名と，セルタイプの定義を入れるコンポーネン
ト記述ファイルの名称は，次の通りとする．

	セルタイプ名	tSIOPort<システム略称>
	ファイル名		tSIOPort<システム略称>.cdl

シリアルインタフェースドライバのターゲット依存部のセルタイプは，内部に，
割込みサービスルーチンや終了処理ルーチン，シリアルI/Oデバイス（SIO）の
みに依存する部分（これを，SIOドライバと呼ぶ）などを含む複合コンポーネン
トになるのが通常である．

ターゲットシステムが複数のシリアルポートを持つ場合には，ポート毎にセル
を作成（インスタンシエート）できるセルタイプとして実装するのが望ましい．
この時，ポートの区別は，セルタイプの属性にSIOのデバイスレジスタの番地を
持たせるなどの方法で行う．また，SIOからの割込み番号や割込み優先度も，必
要に応じて，セルタイプの属性とする．

8.2.2 ターゲット依存部の受け口（提供するサービス）

ターゲット依存部が非依存部に対してサービスを提供する受け口のシグニチャ
は次の通りである．

----------------------------------------
signature sSIOPort {
	void	open(void);
	void	close(void);
	bool_t	putChar([in] char c);
	int_t	getChar(void);
	void	enableCBR([in] uint_t cbrtn);
	void	disableCBR([in] uint_t cbrtn);
};
----------------------------------------

このシグニチャに含まれる関数は，（少なくとも）SIOからの割込みがマスクさ
れた状態で呼び出される．また，タスクコンテキスト，非タスクコンテキスト
のいずれで呼び出される場合もある（いずれで呼び出されても動作するように
しなければならない）．

このシグニチャに含まれる各関数の仕様は次の通り．

(8-2-2-1) void open(void)

SIOポートをオープンする．

(8-2-2-2) void close(void)

SIOポートをクローズする．

(8-2-2-3) bool_t putChar([in] char c)

SIOポートから，文字cを送信する．文字を送信レジスタに入れた場合にはtrue
を，前に送信した文字の送信が終わっていないために，文字を送信レジスタに
入れられなかった場合にはfalseを返す．

(8-2-2-4) int_t getChar(void)

SIOポートから文字を読む．文字を受信していた場合，読んだ文字のコードは正
の値として返し，文字を受信していない場合には-1を返す．

(8-2-2-5) void enableCBR([in] uint_t cbrtn)

SIOポートからのcbrtnで指定されるコールバックを許可する．cbrtnには，
SIOSendReadyかSIOReceiveReadyを指定できる．

(8-2-2-6) void disableCBR([in] uint_t cbrtn)

SIOポートからのcbrtnで指定されるコールバックを禁止する．cbrtnには，
SIOSendReadyかSIOReceiveReadyを指定できる．

8.2.3 ターゲット依存部の呼び口（コールバック）

ターゲット依存部が非依存部を呼び出すコールバックの呼び口のシグニチャは
次の通りである．

----------------------------------------
[callback]
signature siSIOCBR {
	void	readySend(void);
	void	readyReceive(void);
};
----------------------------------------

ターゲット依存部は，指定されたタイミングで，このシグニチャに含まれるコー
ルバック関数を呼び出さなければならない．ただし，そのコールバックが禁止
されている時は，コールバック関数を呼び出してはならない．また，呼び口が
結合されていない場合にも，コールバック関数を呼び出してはならない．

このシグニチャに含まれる関数は，（少なくとも）SIOからの割込みが禁止され
た状態で，非タスクコンテキストで呼び出す．

このシグニチャに含まれる各関数の仕様は次の通り．

(8-2-3-1) void readySend(void)

送信可能コールバックルーチン．SIOポートに対して文字が送信できる状態になっ
た場合に呼び出す．シリアルインタフェースドライバのターゲット非依存部は，
このコールバックルーチンの中で，受け口のputCharを呼び出して次の文字を送
信するか，送信すべき文字がない場合には送信可能コールバックを禁止する．

(8-2-3-2) void readyReceive(void)

受信通知コールバックルーチン．SIOポートから文字を受信した場合に呼び出す．
シリアルインタフェースドライバのターゲット非依存部は，このコールバック
ルーチンの中で，受け口のgetCharを呼び出して受信した文字を取り出す．

8.3 低レベル出力

8.3.1 低レベル出力の実現形態

低レベル出力は，それを用いるコンポーネントと結合するための受け口を1つ持
つシングルトンのセルタイプとして実装する．受け口のインタフェースについ
ては，以降の節で説明する．

低レベル出力を，SIOポートからのポーリングによる出力で実現する場合には，
ターゲット非依存部で用意しているコンポーネントを用いることができる．そ
の方法に関しては，「8.3.3 SIOポートからの低レベル出力」の節を参照する
こと．

これを用いずに，ターゲット依存部で低レベル出力を実現する場合，低レベル
出力のセルタイプ名と，セルタイプの定義を入れるコンポーネント記述ファイ
ルの名称は，次の通りとするのを原則とする．

	セルタイプ名	tPutLog<システム略称>
	ファイル名		tPutLog<システム略称>.cdl

8.3.2 低レベル出力の受け口（提供するサービス）

低レベル出力がサービスを提供する受け口のシグニチャは次の通りである．

----------------------------------------
signature sPutLog {
	void	putChar([in] char c);
};
----------------------------------------

このシグニチャに含まれる関数の仕様は次の通り．

(8-3-2-1) void putChar([in] char c)

低レベル出力のための文字出力関数．ターゲット依存の方法で，文字cを表示/
出力/保存する．

この関数は，リエントラントに実装しなければならない．この関数内で排他制
御が必要な場合には，SILを用いて全割込みロック状態にすること．また，全割
込みロック状態で呼ばれる場合があるため，全割込みロック状態から呼び出す
ことができない関数を呼ばないように実装しなければならない．

8.3.3 SIOポートからの低レベル出力

低レベル出力を，SIOポートからポーリングにより出力するためのコンポーネ
ント（セルタイプ名：tPutLogSIOPort）を，ターゲット非依存部で用意してい
る．このセルタイプは，低レベル出力を行うSIOポートのSIOドライバと結合す
るための呼び口を持つ．

このコンポーネントをシステムに組み込むには，ターゲット依存部のコンポー
ネント記述ファイル（target.cdl）でsyssvc/tPutLogSIOPort.cdlをインポー
トし，以下のようなセルの組上げ記述を含める．

----------------------------------------
cell tPutLogSIOPort PutLogTarget {
	cSIOPort = SIOPortTarget1.eSIOPort;
};
----------------------------------------

また，SIOを初期化するために，ターゲット依存の初期化（target_initialize）
から，tPutLogSIOPort_initializeを呼び出す．

低レベル出力をSIOポートから行う場合，シリアルインタフェースドライバと
ポートを共用しないことが望ましいが，ポート数が足りないためにやむをえず
共用する場合には，両者が競合しないように注意が必要である．具体的には，
両者が同じ設定でSIOを使うようにし，シリアルインタフェースドライバの動
作中に低レベル出力が行われても差し支えないように設計する．また，低レベ
ル出力が動作開始後にシリアルインタフェースドライバがSIOを初期化すると，
文字化けが起こる可能性がある．これを避けるためには，低レベル出力側で初
期化したSIOポートは，シリアルインタフェースドライバでは初期化しないよ
うにするとよい．

8.4 ターゲット依存部のコンポーネント記述ファイル

ターゲット依存部のコンポーネント記述ファイル（target.cdl）には，以下の
内容を記述する．

(8-4-1) タスクのスタックサイズのデフォルト

そのターゲットシステムにおけるタスクのスタックサイズのデフォルト値を，
下の例のように，DefaultTaskStackSizeに定義する．

----------------------------------------
const size_t DefaultTaskStackSize = 4096;
----------------------------------------

(8-4-2) システムログタスクのスタックサイズの定義

そのターゲットシステムにおけるシステムログタスクのスタックサイズを，下
の例のように，LogTaskStackSizeに定義する．

----------------------------------------
const size_t LogTaskStackSize = DefaultTaskStackSize;
----------------------------------------

(8-4-3) カーネル起動メッセージに関する定義

カーネル起動メッセージ出力が表示するターゲット名と著作権表示を，下の例
のように，BannerTargetNameとBannerCopyrightNoticeに定義する．

----------------------------------------
const char *const BannerTargetName = "ARM CT11MPCore";
const char *const BannerCopyrightNotice =
						"Copyright (C) 2016 by Hiroaki Takada\n";
----------------------------------------

(8-4-4) ターゲット依存のセルタイプの定義のインポート

シリアルインタフェースドライバのターゲット依存部と低レベル出力のセルタ
イプの定義を入れたコンポーネント記述ファイルをインポートする．

(8-4-5) シリアルインタフェースドライバのターゲット依存部の組み上げ記述

シリアルインタフェースドライバのターゲット依存部のセルを，下の例のよう
に，SIOPortTarget1の名称で作成（インスタンシエート）する組上げ記述を行
う．システムログタスクは，ターゲット依存部がSIOPortTarget1の名称である
シリアルインタフェースドライバを用いる．

----------------------------------------
cell tSIOPortCT11MPCore SIOPortTarget1 {
	baseAddress     = C_EXP("EB_UART0_BASE");
	interruptNumber = C_EXP("EB_IRQNO_UART0");
};
----------------------------------------

ターゲットシステムが複数のシリアルポートを持つ場合には，複数のセルを作
成（インスタンシエート）してもよい．

(8-4-6) 低レベル出力の組み上げ記述

低レベル出力のセルを，下の例のように，PutLogTargetの名称で作成（インス
タンシエート）する組上げ記述を行う．システムログ機能とシステムログタス
クは，PutLogTargetの名称の低レベル出力を用いる．

----------------------------------------
cell tPutLogCT11MPCore PutLogTarget {
};
----------------------------------------

8.5 システムサービスのターゲット依存定義

システムログ機能，実行時間分布集計サービス，トレースログ機能の設定を変
更するための定義を，target_syssvc.h，target_stddef.h，またはそれらから
インクルードされるファイルに記述することができる．

8.5.1 システムログ機能の設定変更

(8-5-1-1) LOGTIM，SYSLOG_GET_LOGTIM（オプション）

システムログ機能において記録する時刻（ログ時刻）のデータ型をLOGTIMに，
時刻を取得するための処理をSYSLOG_GET_LOGTIMにマクロ定義する．これらを定
義しない場合，高分解能タイマのカウント値をログ時刻に用いる．

なお，LOGTIMの定義は，target_stddef.hまたはそこからインクルードされるファ
イルに含めなければならない．

(8-5-1-2) LOGPAR，ULOGPAR（オプション）

システムログ機能において記録するログパラメータのデータ型をLOGPARにマク
ロ定義する．LOGPARに定義したデータ型は，符号付きの整数型でなければなら
ない．また，LOGPARと同じサイズの符号無しの整数型を，ULOGPARにマクロ定義
する．これらを定義しない場合，ログパラメータのデータ型はintptr_tとする．

なお，LOGPARおよびULOGPARの定義は，target_stddef.hまたはそこからインク
ルードされるファイルに含めなければならない．

8.5.2 実行時間分布集計サービスの設定変更

(8-5-2-1) HISTTIM（オプション）

実行時間計測用の時刻のデータ型を定義するマクロ．定義しない場合のデフォ
ルトはHRTCNT．

(8-5-2-2) void HIST_GET_TIM(HISTTIM *p_time)（オプション）

実行時間計測用の現在時刻を*p_timeに取得する処理に定義するマクロ．定義し
ない場合のデフォルトは，fch_hrtの返値を*p_timeに取得する処理になる．

(8-5-2-3) uint_t HIST_CONV_TIM(HISTTIM time)（オプション）

実行時間計測用の時刻の差（時間）を，実行時間分布集計用の値に変換する処
理に定義するマクロ．時刻が過去に戻ったかオーバフローしたかの区別がつか
ない場合には，最上位ビットが1の値（INT_MAXよりも大きい値）を返す．定義
しない場合のデフォルトは，timeをuint_tにキャストする処理になる．

(8-5-2-4) void HIST_BM_HOOK(void)（オプション）

実行時間計測直前に行うべき処理に定義するマクロ．キャッシュのパージやフィ
ル，メモリバリア処理等を行いたい場合には，このマクロに定義する．定義し
ない場合のデフォルトは，空の処理になる．

8.5.3 トレースログ記録のサンプルコードの設定変更

システムログ機能の設定を変更するために，LOGTIM，LOGPAR，ULOGPARを定義
した場合，トレースログ記録のサンプルコードにも同じ設定が適用される．

(8-5-3-1) TRACE_GET_LOGTIM（オプション）

トレースログ記録のサンプルコードにおいて記録する時刻（ログ時刻）を取得
するための処理をTRACE_GET_LOGTIMにマクロ定義する．これを定義しない場合，
高分解能タイマのカウント値をログ時刻に用いる．

8.6 サンプルプログラムとテストプログラムのターゲット依存定義

ターゲット依存部で提供すべきサンプルプログラムおよびテストプログラムの
ための定義は次の通りである．これらの定義は，target_test.h（またはそれら
からインクルードされるファイル）に含める．

(8-6-1) STACK_SIZE（オプション）

サンプルプログラムおよびテストプログラムのタスクのスタックサイズを定義
するマクロ．定義しない場合のデフォルト値は4096．デフォルト設定ではメモ
リが不足する場合や，シミュレーション環境などで大きいスタック領域が必要
な場合には，ターゲット依存部でこのマクロを設定するスタックサイズに定義
する．

(8-6-2) CPUEXC1（オプション）

サンプルプログラムおよびテストプログラムで用いるCPU例外のCPU例外ハンド
ラ番号を定義するマクロ．このマクロを定義しない場合，CPU例外ハンドラを使
う部分がサンプルプログラムから除外される．CPU例外ハンドラのテストをする
テストプログラムはコンパイルできない．

(8-6-3) RAISE_CPU_EXCEPTION（オプション）

CPUEXC1に定義したCPU例外を発生させるC言語のプログラムを定義するマクロ．
CPUEXC1を定義した場合には必ず定義しなければならない．

(8-6-4) PREPARE_RETURN_CPUEXC（オプション）

CPU例外ハンドラから，CPU例外を起こした処理単位にリターンできるように準
備するためのマクロ．CPU例外を起こした命令をスキップするために，戻り番
地を修正するなどの準備を行う．準備が必要ない場合には，空に定義する．

ターゲットシステムの制約により，CPU例外ハンドラからリターンした後に，
処理単位の実行を継続できない場合には，このマクロを定義しない．このマク
ロを定義しないと，CPU例外ハンドラのテストをするテストプログラムから，
CPU例外ハンドラからリターンした後の処理が除外される．

(8-6-5) INTNO1（オプション）

サンプルプログラムおよびテストプログラムで用いる割込みの割込み番号を定
義するマクロ．このマクロを定義しない場合，割込みサービスルーチンを使う
部分がサンプルプログラムから除外される．割込みに関するテストをするテス
トプログラムはコンパイルできない．

(8-6-6) INTNO1_INTATR（オプション）

INTNO1で指定される割込み要求ラインの属性の設定する時の割込み要求ライン
属性を定義するマクロ．INTNO1を定義した場合には必ず定義しなければならな
い．

(8-6-7) INTNO1_INTPRI（オプション）

INTNO1で指定される割込み要求ラインの属性の設定する時の割込み優先度を定
義するマクロ．INTNO1を定義した場合には必ず定義しなければならない．

(8-6-8) intno1_clear(void)（オプション）

INTNO1で指定される割込み要求ラインへの割込み要求をクリアする．割込み要
求がカーネルによってクリアされる場合には，空に定義する．INTNO1を定義し
た場合には必ず定義しなければならない．

(8-6-9) TASK_PORTID（オプション）

サンプルプログラムにおいて，コマンド文字を読み込むシリアルポート番号を
定義するマクロ．定義しない場合のデフォルト値は1．

(8-6-10) LOOP_REF（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測するためのループ回数
を定義するマクロ．定義しない場合のデフォルト値は1000000．デフォルト設定
では，値が大き過ぎて計測に時間がかかりすぎる場合や，値が小さ過ぎて計測
結果が安定しない場合に，ターゲット依存部でこのマクロを設定するループ回
数に定義する．

(8-6-11) MEASURE_TWICE（オプション）

サンプルプログラムにおいて，プロセッサの速度を2度計測する場合に定義する
マクロ．シミュレーション環境などプロセッサの速度が変動する環境で，1度の
計測では計測結果が安定しない場合に定義する．

(8-6-12) TASK_LOOP（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測せずに，タスク内での
ループ回数を固定する場合に，ループ回数を定義するマクロ．ループ全体の実
行時間が0.4秒程度になるようなループ回数を，このマクロに定義する．

(8-6-13) TEST_TIME_PROC（オプション）

テストプログラムにおいて，一連の処理にかかるよりも長い時間に定義するマ
クロ（単位はマイクロ秒）．一連の処理の完了後にタイムアウトさせたい場合
などに，タイムアウト値にこのマクロを用いる．定義しない場合のデフォルト
値は1000（＝1ミリ秒）．

(8-6-14) TEST_TIME_CP（オプション）

テストプログラムにおいて，チェックポイントに到着したことを示すメッセー
ジを出力するのにかかるよりも長い時間に定義するマクロ（単位はマイクロ
秒）．メッセージの出力後に次の処理を実行したい場合などに，このマクロの
時間待たせる．定義しない場合のデフォルト値は50000（＝50ミリ秒）．


９．その他

9.1 ドキュメント

ターゲット依存部のユーザーズマニュアルを，target_user.txtに用意する．開
発環境依存部／プロセッサコア依存部／チップ依存部のユーザーズマニュアル
を切り分けてもよいし，ファイルが大きくなる場合には複数のファイルに分割
してよいが，その場合には，target_user.txt中にそれらのファイル名を記述す
ること．

ターゲット依存部のユーザーズマニュアルには，少なくとも次のような内容を
記述することが望ましい．

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・ターゲットハードウェア（ボード等）の名称と対応している構成
	・ターゲット略称
	・ターゲット非依存部のバージョン番号
	・開発環境依存部／プロセッサコア依存部／チップ依存部の構成とバージョ
	　ン番号

(2) 使用する開発環境と動作検証した条件（バージョン，オプション等）
	・言語処理系（コンパイラ，アセンブラ，リンカ等）
	・デバッグ環境

(3) ターゲット定義事項の規定

(3-1) データ型に関する規定
	・int_t型，long_t型のサイズ
	・char型，int_least8_t型，void *型，intptr_t型のサイズ
	・int8_t型，uint8_t型，int64_t型，uint64_t型，int128_t型，
	　uint128_t型，float32_t型，double64_t型のサポートの有無

(3-2) 割込み処理に関する規定
	・割込みハンドラ番号と割込み番号の割当て，両者の対応
	・割込み優先度の段階数（TMIN_INTPRIの値）
	・dis_intとena_intのサポートの有無，その制限事項
	・CFG_INTの制限事項と拡張（ターゲット定義で使用できる割込み属性）
	・TOPPERS標準割込み処理モデルからのその他の逸脱
	・デフォルトの割込みハンドラ（default_int_handler）の有無と処理内容

(3-3) カーネル管理外の割込みに関する規定
	・TMIN_INTPRIは固定か設定できるか，その設定方法
	・NMI以外にカーネル管理外の割込みを設けるか（設けられるようにするか）
	・カーネル管理外の割込みの設定方法
	・カーネル管理外の割込みに対してDEF_INH，CFG_INTをサポートするか
	・カーネル管理外の割込みハンドラが実行開始される時のシステム状態と
	　コンテキスト
	・割込みハンドラの終了時に行われる処理
	・カーネル管理外の割込みハンドラの記述方法
	・カーネル内の割込み出入口処理で起こる可能性のあるCPU例外

(3-4) CPU例外処理に関する規定
	・CPU例外ハンドラ番号の割当て
	・割込み優先度マスクをTMIN_INTPRIと同じかそれよりも高い値に設定して
	　いる状態で発生したCPU例外を，カーネル管理外のCPU例外と扱うか
	・カーネル内のCPU例外出入口処理で起こる可能性のあるCPU例外
	・デフォルトのCPU例外ハンドラ（default_exc_handler）の有無と処理内容

(3-5) 拡張パッケージに関する規定
	・各拡張パッケージのサポートの有無
		- ドリフト調整機能拡張パッケージ
		- メッセージバッファ機能拡張パッケージ
		- オーバランハンドラ機能拡張パッケージ
		- タスク優先度拡張パッケージ
		- 制約タスク拡張パッケージ
		- サブ優先度機能拡張パッケージ
		- 動的生成機能拡張パッケージ
	・オーバランハンドラ機能拡張パッケージをサポートする場合に，残りプ
	　ロセッサ時間に指定できる値の最大値（TMAX_OVRTIMの値）
	・動的生成機能拡張パッケージをサポートする場合に，動的メモリ管理の
	　方法

(3-6) その他
	・その他の制限事項
	・その他の拡張機能

(4) カーネルの起動／終了処理に関する情報
	・用意しているスタートアップモジュールの処理内容
	・スタートアップモジュールからhardware_init_hookを呼び出している場
	　合には，hardware_init_hookをアプリケーションで用意する場合の作成
	　方法や制限事項など
	・カーネルを終了した後の振舞い

(5) メモリマップ
	・デフォルトのメモリマップ，その変更方法

(6) タイマドライバ関連の情報
	・高分解能タイマの周期とカウントアップの進み幅
	・使用するリソース（タイマ）
	・高分解能タイマ割込みの割込み優先度の変更方法
	・オーバランタイマ割込みの割込み優先度の変更方法

(7) シリアルインタフェースドライバの情報
	・使用するリソース（SIOコントローラ）
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビット）

(8) システムログ機能の情報
	・システムログの低レベル出力の実現方法
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビット）

(9) システム構築手順

(10) ターゲットシステム固有の注意事項
	・タスクコンテキストに含まれるレジスタ，含まれないレジスタ

(11) 類似のターゲットにポーティングする開発者向けの参考情報

(12) ディレクトリ構成・ファイル構成

(13) バージョン履歴

また，必要に応じて，ターゲット依存部の設計メモを，target_design.txtに用
意する．開発環境依存部／プロセッサコア依存部／チップ依存部に関する設計
メモを切り分けてもよいし，ファイルが大きくなる場合には複数のファイルに
分割してもよいが，その場合には，target_design.txt中にそれらのファイル名
を記述すること．

9.2 パッケージ記述ファイル

リリースパッケージ（個別パッケージおよび簡易パッケージ）を作成するため
に，パッケージに含めるファイルを記述したパッケージ記述ファイルを用意す
る．パッケージ記述ファイルの名称は，個別パッケージ用をMANIFEST，簡易パッ
ケージ用をE_PACKAGEとする．

例えば，arch/arm_gccディレクトリに置かれたMANIFESTファイルを用いて個別
パッケージを作成する場合には，次のコマンドを実行する．

	% ruby utils/makerelease.rb arch/arm_gcc/MANIFEST

このコマンドにより，RELEASE/asp3_arch_arm_gcc-<バージョン番号>.tar.gzが
作成される．また，target/ct11mpcore_gccディレクトリに置かれたE_PACKAGE
ファイルを用いて簡易パッケージを作成する場合には，次のコマンドを実行す
る．

	% ruby utils/makerelease.rb target/ct11mpcore_gcc/E_PACKAGE

このコマンドにより，RELEASE/asp3_ct11mpcore_gcc-<バージョン番号>.tar.gz
が作成される（RELEASEディレクトリがない場合には，ディレクトリが作られ
る）．

なお，makerelease.rbは，ASP3カーネルのソースファイルが置かれたディレク
トリが，asp3という名称であることを仮定している（異なる名称の場合でもパッ
ケージは作成できるが，パッケージを展開した時に展開されるディレクトリが
asp3でなくなる）．

また，標準のtarコマンドがzオプションに対応していること（GNU tar，MacOS
の標準のtarは対応している）を想定している．MacOS（10.5以降）でパッケー
ジを作成する場合，"._"で始まるファイルがパッケージに含まれてしまうこと
がある．これを回避するために，環境変数COPYFILE_DISABLEを1に設定してお
くことが望ましい．

パッケージ記述ファイルには，パッケージに含めるファイル名を，パッケージ
記述ファイルが置かれたディレクトリからの相対パス名で，1行に1つずつ記述
する．また，必要に応じて，以下のディレクティブを含める．

(a) E_PACKAGE <簡易パッケージ名>

簡易パッケージ名を指定する．簡易パッケージ記述ファイル（E_PACKAGE）の先
頭に記述する．簡易パッケージ名は，asp3_<ターゲット略称>とする．例えば，
ターゲット略称がct11mpcore_gccの場合には，asp3_ct11mpcore_gccとなる．個
別パッケージと区別するために，簡易パッケージのファイル名には"target"を
含めない．

(b) PACKAGE <個別パッケージ名>

個別パッケージ名を指定する．個別パッケージ記述ファイル（MANIFEST）の先
頭に記述する．また，そこからインクルードされる各ファイルの先頭にも記述
し，それをインクルードしている個別パッケージ名を指定する．ターゲット依
存部の個別パッケージ名は，個別パッケージ記述ファイルが置かれたディレク
トリの相対パス中の"/"を"_"に置き換えた文字列を，"asp3_"の後につなげたも
のとする．例えば，個別パッケージ記述ファイルがarch/arm_gcc/MANIFESTの場
合には，asp3_arch_arm_gccとなる．

(c) VERSION <バージョン番号>

パッケージのバージョン番号を指定する．簡易パッケージ記述ファイルおよび
個別パッケージ記述ファイルの中に記述する．簡易パッケージにおいて，バー
ジョン番号をパッケージ化した日付とする場合には，パッケージ番号の代わり
に%dateと記述する．

バージョン番号の付与方法については，「TOPPERS/ASP3カーネル ユーザーズマ
ニュアル」の「2.2 簡易パッケージ」および「2.3 個別パッケージ」の節を参
照すること．

(d) INCLUDE <ファイル名>

別のパッケージ記述ファイルをインクルードする．簡易パッケージ記述ファイ
ルからは，個別パッケージ記述ファイルのみをインクルードするのを原則とす
る．個別パッケージ記述ファイルからインクルードされるファイル中で指定さ
れる個別パッケージ名は，すべて一致していなければならない．


１０．リファレンス

10.1 ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである（ターゲット依存
部の実装方法によって変わる部分がある）．

Makefile.target		Makefileのターゲット依存部（２章）
target_offset.trb	オフセットファイル生成用の生成スクリプト（2.5.1節，
					オプション）

target_stddef.h		TOPPERS共通定義（t_stddef.h）のターゲット依存部（３
					章）．アプリケーションとカーネルの両方からインクルー
					ドされる
target_sil.h		システムインタフェースレイヤ（sil.h）のターゲット依
					存部（４章）．アプリケーションとカーネルの両方から
					インクルードされる
target_kernel.h		カーネルAPI（kernel.h）のターゲット依存部（５章）．
					アプリケーションとカーネルの両方からインクルードさ
					れる

target_kernel_impl.h	カーネル実装のターゲット依存部のヘッダファイル
						（６章）．カーネルのみからインクルードされる
target_kernel_impl.c	カーネル実装のターゲット依存部のC言語で記述され
						る部分（６章，オプション）
target_support.S	ターゲット依存部のアセンブリ言語で記述される部分（６
					章，オプション）
target_rename.def	ターゲット依存部のためのリネーム記述（6.12節）
target_rename.h		target_rename.defから生成されるファイル（6.12節）
target_unrename.h	target_rename.defから生成されるファイル（6.12節）
target_timer.cfg	タイマドライバのシステムコンフィギュレーションファ
					イル（6.13節）
target_timer.h		タイマドライバのヘッダファイル（6.13節）．カーネル
					のみからインクルードされる
target_timer.c		タイマドライバの実装ファイル（6.13節，オプション）
target_kernel.cfg	カーネル実装のコンフィギュレーションファイル（6.16節）
システム略称.h		ターゲットのハードウェア資源（割込みハンドラ番号や
					CPU例外ハンドラ番号，デバイスレジスタの番地など）の
					定義を含むヘッダファイル．アプリケーションとカーネ
					ルの両方からインクルードされる（６章，オプション）

target_sym.def		コンフィギュレータの値取得シンボルテーブルのターゲッ
					ト依存部（７章，オプション）
target_kernel.trb	コンフィギュレータのパス2の生成スクリプトのターゲッ
					ト依存部（7.2節）
target_check.trb	コンフィギュレータのパス3の生成スクリプト（7.3節）
target_cfg1_out.h	cfg1_out.cのリンクに必要なスタブの定義ファイル（7.4
					節）

tSIOPort<システム略称>.cdl		シリアルインタフェースドライバのターゲッ
								ト依存部のセルタイプの定義（8.2節）
tSIOPort<システム略称>.c 		シリアルインタフェースドライバのターゲッ
								ト依存部の実装ファイル（8.2節）
tPutLog<システム略称>.cdl		低レベル出力のセルタイプの定義（8.3節，オ
								プション）
tPutLog<システム略称>.c			低レベル出力のセルタイプの実装ファイル
								（8.3節，オプション）
target.cdl			ターゲット依存部のコンポーネント記述ファイル（8.4節）
target_syssvc.h		システムサービスのターゲット依存定義（8.5節）
target_test.h		テストプログラムのターゲット依存定義（8.6節）

target_user.txt		ユーザーズマニュアル（9.1節）
target_design.txt	設計メモ（9.1節，オプション）
MANIFEST			個別パッケージに含めるファイルのリスト（9.2節，オプ
					ション）
E_PACKAGE			簡易パッケージに含めるファイルのリスト（9.2節，オプ
					ション）

以上
